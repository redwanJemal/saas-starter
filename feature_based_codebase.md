# tsconfig.json

```json
{ "compilerOptions": { "target": "ESNext", "lib": [ "dom", "dom.iterable", "esnext" ], "allowJs": true, "skipLibCheck": true, "strict": true, "noEmit": true, "esModuleInterop": true, "module": "esnext", "moduleResolution": "bundler", "resolveJsonModule": true, "isolatedModules": true, "jsx": "preserve", "incremental": true, "baseUrl": ".", "plugins": [ { "name": "next" } ], "paths": { "@/*": [ "./*" ] } }, "include": [ "next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts" ], "exclude": [ "node_modules" ] }
```

# README.md

```md
# Next.js SaaS Starter This is a starter template for building a SaaS application using **Next.js** with support for authentication, Stripe integration for payments, and a dashboard for logged-in users. **Demo: [https://next-saas-start.vercel.app/](https://next-saas-start.vercel.app/)** ## Features - Marketing landing page (`/`) with animated Terminal element - Pricing page (`/pricing`) which connects to Stripe Checkout - Dashboard pages with CRUD operations on users/teams - Basic RBAC with Owner and Member roles - Subscription management with Stripe Customer Portal - Email/password authentication with JWTs stored to cookies - Global middleware to protect logged-in routes - Local middleware to protect Server Actions or validate Zod schemas - Activity logging system for any user events ## Tech Stack - **Framework**: [Next.js](https://nextjs.org/) - **Database**: [Postgres](https://www.postgresql.org/) - **ORM**: [Drizzle](https://orm.drizzle.team/) - **Payments**: [Stripe](https://stripe.com/) - **UI Library**: [shadcn/ui](https://ui.shadcn.com/) ## Getting Started \`\`\`bash git clone https://github.com/nextjs/saas-starter cd saas-starter pnpm install \`\`\` ## Running Locally [Install](https://docs.stripe.com/stripe-cli) and log in to your Stripe account: \`\`\`bash stripe login \`\`\` Use the included setup script to create your `.env` file: \`\`\`bash pnpm db:setup \`\`\` Run the database migrations and seed the database with a default user and team: \`\`\`bash pnpm db:migrate pnpm db:seed \`\`\` This will create the following user and team: - User: `test@test.com` - Password: `admin123` You can also create new users through the `/sign-up` route. Finally, run the Next.js development server: \`\`\`bash pnpm dev \`\`\` Open [http://localhost:3000](http://localhost:3000) in your browser to see the app in action. You can listen for Stripe webhooks locally through their CLI to handle subscription change events: \`\`\`bash stripe listen --forward-to localhost:3000/api/stripe/webhook \`\`\` openssl rand -hex 32 ## Testing Payments To test Stripe payments, use the following test card details: - Card Number: `4242 4242 4242 4242` - Expiration: Any future date - CVC: Any 3-digit number ## Going to Production When you're ready to deploy your SaaS application to production, follow these steps: ### Set up a production Stripe webhook 1. Go to the Stripe Dashboard and create a new webhook for your production environment. 2. Set the endpoint URL to your production API route (e.g., `https://yourdomain.com/api/stripe/webhook`). 3. Select the events you want to listen for (e.g., `checkout.session.completed`, `customer.subscription.updated`). ### Deploy to Vercel 1. Push your code to a GitHub repository. 2. Connect your repository to [Vercel](https://vercel.com/) and deploy it. 3. Follow the Vercel deployment process, which will guide you through setting up your project. ### Add environment variables In your Vercel project settings (or during deployment), add all the necessary environment variables. Make sure to update the values for the production environment, including: 1. `BASE_URL`: Set this to your production domain. 2. `STRIPE_SECRET_KEY`: Use your Stripe secret key for the production environment. 3. `STRIPE_WEBHOOK_SECRET`: Use the webhook secret from the production webhook you created in step 1. 4. `POSTGRES_URL`: Set this to your production database URL. 5. `AUTH_SECRET`: Set this to a random string. `openssl rand -base64 32` will generate one. ## Other Templates While this template is intentionally minimal and to be used as a learning resource, there are other paid versions in the community which are more full-featured: - https://achromatic.dev - https://shipfa.st - https://makerkit.dev - https://zerotoshipped.com - https://turbostarter.dev
```

# postcss.config.mjs

```mjs
export default { plugins: { '@tailwindcss/postcss': {}, }, };
```

# package.json

```json
{ "private": true, "scripts": { "dev": "next dev --turbopack", "build": "next build", "start": "next start", "db:setup": "npx tsx lib/db/setup.ts", "db:seed": "npx tsx lib/db/seed/index.ts", "db:generate": "drizzle-kit generate", "db:migrate": "drizzle-kit migrate", "db:studio": "drizzle-kit studio" }, "dependencies": { "@radix-ui/react-avatar": "^1.1.10", "@radix-ui/react-checkbox": "^1.3.2", "@radix-ui/react-collapsible": "^1.1.11", "@radix-ui/react-dialog": "^1.1.14", "@radix-ui/react-dropdown-menu": "^2.1.15", "@radix-ui/react-label": "^2.1.7", "@radix-ui/react-progress": "^1.1.7", "@radix-ui/react-radio-group": "^1.3.7", "@radix-ui/react-select": "^2.2.5", "@radix-ui/react-separator": "^1.1.7", "@radix-ui/react-slot": "^1.2.3", "@radix-ui/react-switch": "^1.2.5", "@radix-ui/react-tabs": "^1.1.12", "@supabase/supabase-js": "^2.53.0", "@tailwindcss/postcss": "4.1.7", "@tanstack/react-query": "^5.8.4", "@tanstack/react-query-devtools": "^5.8.4", "@tanstack/react-table": "^8.21.3", "@types/node": "^22.15.18", "@types/react": "19.1.4", "@types/react-dom": "19.1.5", "autoprefixer": "^10.4.21", "axios": "^1.6.2", "bcryptjs": "^3.0.2", "class-variance-authority": "^0.7.1", "clsx": "^2.1.1", "date-fns": "^4.1.0", "dotenv": "^16.5.0", "drizzle-kit": "^0.31.4", "drizzle-orm": "^0.44.3", "lucide-react": "^0.511.0", "next": "15.4.0-canary.47", "next-themes": "^0.4.6", "postcss": "^8.5.3", "postgres": "^3.4.7", "react": "19.1.0", "react-dom": "19.1.0", "react-error-boundary": "^4.0.11", "recharts": "^3.1.0", "server-only": "^0.0.1", "sonner": "^2.0.6", "tailwind-merge": "^3.3.0", "tailwindcss": "4.1.7", "tw-animate-css": "^1.3.0", "typescript": "^5.8.3", "zustand": "^4.4.7" } }
```

# next.config.ts

```ts
import type { NextConfig } from 'next'; const nextConfig: NextConfig = { experimental: { ppr: true, clientSegmentCache: true, nodeMiddleware: true } }; export default nextConfig;
```

# next-env.d.ts

```ts
/// <reference types="next" /> /// <reference types="next/image-types/global" /> // NOTE: This file should not be edited // see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```

# middleware.ts

```ts
import { NextResponse } from 'next/server'; import type { NextRequest } from 'next/server'; // Simple middleware for clean starter - no authentication required export function middleware(request: NextRequest) { // For now, just pass through all requests // In a real app, you would add authentication logic here return NextResponse.next(); } export const config = { matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'], runtime: 'nodejs' };
```

# LICENSE

```
MIT License Copyright (c) 2025 Vercel Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

# drizzle.config.ts

```ts
import type { Config } from 'drizzle-kit'; export default { schema: './lib/db/schema', out: './lib/db/migrations', dialect: 'postgresql', dbCredentials: { url: process.env.POSTGRES_URL!, }, } satisfies Config;
```

# components.json

```json
{ "$schema": "https://ui.shadcn.com/schema.json", "style": "new-york", "rsc": true, "tsx": true, "tailwind": { "config": "", "css": "app/globals.css", "baseColor": "zinc", "cssVariables": true, "prefix": "" }, "aliases": { "components": "@/components", "utils": "@/lib/utils", "ui": "@/components/ui", "lib": "@/lib", "hooks": "@/hooks" }, "iconLibrary": "lucide" }
```

# .gitignore

```
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files. # dependencies /node_modules /.pnp .pnp.js .yarn/install-state.gz # testing /coverage codebase.md # next.js /.next/ /out/ # production /build # misc .DS_Store *.pem # debug npm-debug.log* yarn-debug.log* yarn-error.log* # local env files .env # vercel .vercel # typescript *.tsbuildinfo next-env.d.ts .vscode # Docker postgres_data/ .env*.local
```

# lib\utils.ts

```ts
import { type ClassValue, clsx } from "clsx" import { twMerge } from "tailwind-merge" export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)) }
```

# app\providers.tsx

```tsx
'use client'; import { QueryClientProvider } from '@tanstack/react-query'; import { ReactQueryDevtools } from '@tanstack/react-query-devtools'; import { queryClient } from '@/shared/lib/query-client'; import { ErrorBoundary } from '@/shared/components/error-boundary'; import { Toaster } from 'sonner'; export function Providers({ children }: { children: React.ReactNode }) { return ( <QueryClientProvider client={queryClient}> <ErrorBoundary> <Toaster position="top-right" richColors /> {children} {process.env.NODE_ENV === 'development' && ( <ReactQueryDevtools initialIsOpen={false} /> )} </ErrorBoundary> </QueryClientProvider> ); }
```

# app\page.tsx

```tsx
'use client'; import Link from 'next/link'; import { Button } from '@/components/ui/button'; import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'; import { Package, Users, BarChart3, ArrowRight } from 'lucide-react'; export default function HomePage() { return ( <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100"> <div className="container mx-auto px-4 py-16"> {/* Header */} <div className="text-center mb-16"> <h1 className="text-4xl font-bold text-gray-900 mb-4"> Package Forwarding Platform </h1> <p className="text-xl text-gray-600 max-w-2xl mx-auto"> A modern, clean starter built with TanStack Query + Zustand architecture </p> </div> {/* Feature Cards */} <div className="grid md:grid-cols-2 gap-8 mb-16"> <Card className="hover:shadow-lg transition-shadow"> <CardHeader> <CardTitle className="flex items-center gap-2"> <Package className="h-6 w-6 text-blue-600" /> Package Management </CardTitle> <CardDescription> Track and manage packages with real-time updates and optimistic UI </CardDescription> </CardHeader> <CardContent> <ul className="space-y-2 text-sm text-gray-600 mb-4"> <li>• TanStack Query for data fetching</li> <li>• Optimistic updates</li> <li>• Real-time status tracking</li> <li>• Bulk operations</li> </ul> <Link href="/packages"> <Button className="w-full"> View Packages <ArrowRight className="h-4 w-4 ml-2" /> </Button> </Link> </CardContent> </Card> <Card className="hover:shadow-lg transition-shadow"> <CardHeader> <CardTitle className="flex items-center gap-2"> <Users className="h-6 w-6 text-green-600" /> Customer Management </CardTitle> <CardDescription> Manage customer accounts with advanced filtering and search </CardDescription> </CardHeader> <CardContent> <ul className="space-y-2 text-sm text-gray-600 mb-4"> <li>• Zustand for global state</li> <li>• Advanced table filtering</li> <li>• Customer analytics</li> <li>• Status management</li> </ul> <Link href="/customers"> <Button className="w-full" variant="outline"> View Customers <ArrowRight className="h-4 w-4 ml-2" /> </Button> </Link> </CardContent> </Card> </div> {/* Architecture Highlights */} <Card className="mb-16"> <CardHeader> <CardTitle className="flex items-center gap-2"> <BarChart3 className="h-6 w-6 text-purple-600" /> Architecture Highlights </CardTitle> <CardDescription> Built with modern React patterns and best practices </CardDescription> </CardHeader> <CardContent> <div className="grid md:grid-cols-3 gap-6"> <div className="text-center"> <div className="bg-blue-100 rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3"> <Package className="h-6 w-6 text-blue-600" /> </div> <h3 className="font-semibold mb-2">TanStack Query</h3> <p className="text-sm text-gray-600"> Powerful data fetching with caching, background updates, and optimistic UI </p> </div> <div className="text-center"> <div className="bg-green-100 rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3"> <Users className="h-6 w-6 text-green-600" /> </div> <h3 className="font-semibold mb-2">Zustand</h3> <p className="text-sm text-gray-600"> Lightweight state management for global UI state and selections </p> </div> <div className="text-center"> <div className="bg-purple-100 rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3"> <BarChart3 className="h-6 w-6 text-purple-600" /> </div> <h3 className="font-semibold mb-2">TypeScript</h3> <p className="text-sm text-gray-600"> Full type safety with proper API contracts and error handling </p> </div> </div> </CardContent> </Card> {/* Quick Stats */} <div className="grid grid-cols-2 md:grid-cols-4 gap-4"> <Card> <CardContent className="p-4 text-center"> <div className="text-2xl font-bold text-blue-600">3</div> <div className="text-sm text-gray-600">Total Packages</div> </CardContent> </Card> <Card> <CardContent className="p-4 text-center"> <div className="text-2xl font-bold text-green-600">3</div> <div className="text-sm text-gray-600">Active Customers</div> </CardContent> </Card> <Card> <CardContent className="p-4 text-center"> <div className="text-2xl font-bold text-purple-600">100%</div> <div className="text-sm text-gray-600">TypeScript</div> </CardContent> </Card> <Card> <CardContent className="p-4 text-center"> <div className="text-2xl font-bold text-orange-600">0</div> <div className="text-sm text-gray-600">TS Errors</div> </CardContent> </Card> </div> </div> </div> ); }
```

# app\layout.tsx

```tsx
import './globals.css'; import type { Metadata, Viewport } from 'next'; import { Manrope } from 'next/font/google'; import { Providers } from './providers'; export const metadata: Metadata = { title: 'Package Forwarding Platform', description: 'Global package forwarding and personal shopping service.', }; export const viewport: Viewport = { maximumScale: 1 }; const manrope = Manrope({ subsets: ['latin'] }); export default function RootLayout({ children, }: { children: React.ReactNode; }) { return ( <html lang="en" className={`bg-white dark:bg-gray-950 text-black dark:text-white ${manrope.className}`}> <body className="min-h-[100dvh] bg-gray-50"> <Providers> {children} </Providers> </body> </html> ); }
```

# app\globals.css

```css
@import "tailwindcss"; /* ---break--- */ @custom-variant dark (&:is(.dark *)); @import "tw-animate-css"; @variant dark (&:is(.dark *)); @theme { --color-background: hsl(var(--background)); --color-foreground: hsl(var(--foreground)); --color-card: hsl(var(--card)); --color-card-foreground: hsl(var(--card-foreground)); --color-popover: hsl(var(--popover)); --color-popover-foreground: hsl(var(--popover-foreground)); --color-primary: hsl(var(--primary)); --color-primary-foreground: hsl(var(--primary-foreground)); --color-secondary: hsl(var(--secondary)); --color-secondary-foreground: hsl(var(--secondary-foreground)); --color-muted: hsl(var(--muted)); --color-muted-foreground: hsl(var(--muted-foreground)); --color-accent: hsl(var(--accent)); --color-accent-foreground: hsl(var(--accent-foreground)); --color-destructive: hsl(var(--destructive)); --color-destructive-foreground: hsl(var(--destructive-foreground)); --color-border: hsl(var(--border)); --color-input: hsl(var(--input)); --color-ring: hsl(var(--ring)); --color-chart-1: hsl(var(--chart-1)); --color-chart-2: hsl(var(--chart-2)); --color-chart-3: hsl(var(--chart-3)); --color-chart-4: hsl(var(--chart-4)); --color-chart-5: hsl(var(--chart-5)); --color-sidebar: hsl(var(--sidebar-background)); --color-sidebar-foreground: hsl(var(--sidebar-foreground)); --color-sidebar-primary: hsl(var(--sidebar-primary)); --color-sidebar-primary-foreground: hsl(var(--sidebar-primary-foreground)); --color-sidebar-accent: hsl(var(--sidebar-accent)); --color-sidebar-accent-foreground: hsl(var(--sidebar-accent-foreground)); --color-sidebar-border: hsl(var(--sidebar-border)); --color-sidebar-ring: hsl(var(--sidebar-ring)); --radius-lg: var(--radius); --radius-md: calc(var(--radius) - 2px); --radius-sm: calc(var(--radius) - 4px); } /* The default border color has changed to `currentColor` in Tailwind CSS v4, so we've added these compatibility styles to make sure everything still looks the same as it did with Tailwind CSS v3. If we ever want to remove these styles, we need to add an explicit border color utility to any element that depends on these defaults. */ @layer base { *, ::after, ::before, ::backdrop, ::file-selector-button { border-color: var(--color-gray-200, currentColor); } } @layer utilities { body { font-family: "Manrope", Arial, Helvetica, sans-serif; } } @layer base { :root { --background: 0 0% 100%; --foreground: 222.2 84% 4.9%; --card: 0 0% 100%; --card-foreground: 222.2 84% 4.9%; --popover: 0 0% 100%; --popover-foreground: 222.2 84% 4.9%; --primary: 222.2 47.4% 11.2%; --primary-foreground: 210 40% 98%; --secondary: 210 40% 96.1%; --secondary-foreground: 222.2 47.4% 11.2%; --muted: 210 40% 96.1%; --muted-foreground: 215.4 16.3% 46.9%; --accent: 210 40% 96.1%; --accent-foreground: 222.2 47.4% 11.2%; --destructive: 0 84.2% 60.2%; --destructive-foreground: 210 40% 98%; --border: 214.3 31.8% 91.4%; --input: 214.3 31.8% 91.4%; --ring: 222.2 84% 4.9%; --chart-1: 12 76% 61%; --chart-2: 173 58% 39%; --chart-3: 197 37% 24%; --chart-4: 43 74% 66%; --chart-5: 27 87% 67%; --radius: 0.5rem; --sidebar-background: 0 0% 98%; --sidebar-foreground: 240 5.3% 26.1%; --sidebar-primary: 240 5.9% 10%; --sidebar-primary-foreground: 0 0% 98%; --sidebar-accent: 240 4.8% 95.9%; --sidebar-accent-foreground: 240 5.9% 10%; --sidebar-border: 220 13% 91%; --sidebar-ring: 217.2 91.2% 59.8%; } .dark { --background: 222.2 84% 4.9%; --foreground: 210 40% 98%; --card: 222.2 84% 4.9%; --card-foreground: 210 40% 98%; --popover: 222.2 84% 4.9%; --popover-foreground: 210 40% 98%; --primary: 210 40% 98%; --primary-foreground: 222.2 47.4% 11.2%; --secondary: 217.2 32.6% 17.5%; --secondary-foreground: 210 40% 98%; --muted: 217.2 32.6% 17.5%; --muted-foreground: 215 20.2% 65.1%; --accent: 217.2 32.6% 17.5%; --accent-foreground: 210 40% 98%; --destructive: 0 62.8% 30.6%; --destructive-foreground: 210 40% 98%; --border: 217.2 32.6% 17.5%; --input: 217.2 32.6% 17.5%; --ring: 212.7 26.8% 83.9%; --chart-1: 220 70% 50%; --chart-2: 160 60% 45%; --chart-3: 30 80% 55%; --chart-4: 280 65% 60%; --chart-5: 340 75% 55%; --sidebar-background: 240 5.9% 10%; --sidebar-foreground: 240 4.8% 95.9%; --sidebar-primary: 224.3 76.3% 48%; --sidebar-primary-foreground: 0 0% 100%; --sidebar-accent: 240 3.7% 15.9%; --sidebar-accent-foreground: 240 4.8% 95.9%; --sidebar-border: 240 3.7% 15.9%; --sidebar-ring: 217.2 91.2% 59.8%; } } @layer base { * { @apply border-border; } body { @apply bg-background text-foreground; } } /* ---break--- */ :root { --background: hsl(0 0% 100%); --foreground: hsl(240 10% 3.9%); --card: hsl(0 0% 100%); --card-foreground: hsl(240 10% 3.9%); --popover: hsl(0 0% 100%); --popover-foreground: hsl(240 10% 3.9%); --primary: hsl(240 5.9% 10%); --primary-foreground: hsl(0 0% 98%); --secondary: hsl(240 4.8% 95.9%); --secondary-foreground: hsl(240 5.9% 10%); --muted: hsl(240 4.8% 95.9%); --muted-foreground: hsl(240 3.8% 46.1%); --accent: hsl(240 4.8% 95.9%); --accent-foreground: hsl(240 5.9% 10%); --destructive: hsl(0 84.2% 60.2%); --destructive-foreground: hsl(0 0% 98%); --border: hsl(240 5.9% 90%); --input: hsl(240 5.9% 90%); --ring: hsl(240 10% 3.9%); --chart-1: hsl(12 76% 61%); --chart-2: hsl(173 58% 39%); --chart-3: hsl(197 37% 24%); --chart-4: hsl(43 74% 66%); --chart-5: hsl(27 87% 67%); --radius: 0.6rem; } /* ---break--- */ .dark { --background: hsl(240 10% 3.9%); --foreground: hsl(0 0% 98%); --card: hsl(240 10% 3.9%); --card-foreground: hsl(0 0% 98%); --popover: hsl(240 10% 3.9%); --popover-foreground: hsl(0 0% 98%); --primary: hsl(0 0% 98%); --primary-foreground: hsl(240 5.9% 10%); --secondary: hsl(240 3.7% 15.9%); --secondary-foreground: hsl(0 0% 98%); --muted: hsl(240 3.7% 15.9%); --muted-foreground: hsl(240 5% 64.9%); --accent: hsl(240 3.7% 15.9%); --accent-foreground: hsl(0 0% 98%); --destructive: hsl(0 62.8% 30.6%); --destructive-foreground: hsl(0 0% 98%); --border: hsl(240 3.7% 15.9%); --input: hsl(240 3.7% 15.9%); --ring: hsl(240 4.9% 83.9%); --chart-1: hsl(220 70% 50%); --chart-2: hsl(160 60% 45%); --chart-3: hsl(30 80% 55%); --chart-4: hsl(280 65% 60%); --chart-5: hsl(340 75% 55%); } /* ---break--- */ @theme inline { --color-background: var(--background); --color-foreground: var(--foreground); --color-card: var(--card); --color-card-foreground: var(--card-foreground); --color-popover: var(--popover); --color-popover-foreground: var(--popover-foreground); --color-primary: var(--primary); --color-primary-foreground: var(--primary-foreground); --color-secondary: var(--secondary); --color-secondary-foreground: var(--secondary-foreground); --color-muted: var(--muted); --color-muted-foreground: var(--muted-foreground); --color-accent: var(--accent); --color-accent-foreground: var(--accent-foreground); --color-destructive: var(--destructive); --color-destructive-foreground: var(--destructive-foreground); --color-border: var(--border); --color-input: var(--input); --color-ring: var(--ring); --color-chart-1: var(--chart-1); --color-chart-2: var(--chart-2); --color-chart-3: var(--chart-3); --color-chart-4: var(--chart-4); --color-chart-5: var(--chart-5); --radius-sm: calc(var(--radius) - 4px); --radius-md: calc(var(--radius) - 2px); --radius-lg: var(--radius); --radius-xl: calc(var(--radius) + 4px); } /* ---break--- */ @layer base { * { @apply border-border outline-ring/50; } body { @apply bg-background text-foreground; } }
```

# shared\stores\global-store.ts

```ts
import { create } from 'zustand'; // Define the state interface interface GlobalState { // UI State sidebarOpen: boolean; theme: 'light' | 'dark' | 'system'; // Selection State (for tables across features) selections: Record<string, Set<string>>; // Notifications notifications: Array<{ id: string; type: 'success' | 'error' | 'warning' | 'info'; message: string; timestamp: number; }>; // Actions setSidebarOpen: (open: boolean) => void; setTheme: (theme: 'light' | 'dark' | 'system') => void; setSelection: (feature: string, selection: Set<string>) => void; clearSelection: (feature: string) => void; addNotification: (notification: Omit<GlobalState['notifications'][0], 'id' | 'timestamp'>) => void; removeNotification: (id: string) => void; } // Create the store with a simpler implementation to avoid middleware typing issues export const useGlobalStore = create<GlobalState>((set) => ({ // Initial state sidebarOpen: true, theme: 'system', selections: {}, notifications: [], // Actions setSidebarOpen: (open: boolean) => set({ sidebarOpen: open }), setTheme: (theme: 'light' | 'dark' | 'system') => set({ theme }), setSelection: (feature: string, selection: Set<string>) => set((state) => ({ selections: { ...state.selections, [feature]: selection } })), clearSelection: (feature: string) => set((state) => ({ selections: { ...state.selections, [feature]: new Set() } })), addNotification: (notification: Omit<GlobalState['notifications'][0], 'id' | 'timestamp'>) => set((state) => ({ notifications: [ ...state.notifications, { ...notification, id: Math.random().toString(36).substring(7), timestamp: Date.now(), } ] })), removeNotification: (id: string) => set((state) => ({ notifications: state.notifications.filter((n) => n.id !== id) })), })); // Note: We've temporarily removed the middleware (devtools, subscribeWithSelector) // to fix the typing issues. Once the build error is resolved, we can revisit this.
```

# shared\components\navigation.tsx

```tsx
'use client'; import Link from 'next/link'; import { usePathname } from 'next/navigation'; import { Button } from '@/components/ui/button'; import { Package, Users, Home } from 'lucide-react'; import { cn } from '@/lib/utils'; const navigation = [ { name: 'Dashboard', href: '/', icon: Home }, { name: 'Packages', href: '/packages', icon: Package }, { name: 'Customers', href: '/customers', icon: Users }, ]; export function Navigation() { const pathname = usePathname(); return ( <nav className="bg-white border-b border-gray-200 px-4 py-3"> <div className="container mx-auto flex items-center justify-between"> <div className="flex items-center space-x-8"> <Link href="/" className="text-xl font-bold text-gray-900"> Package Forward </Link> <div className="flex space-x-1"> {navigation.map((item) => { const Icon = item.icon; const isActive = pathname === item.href; return ( <Link key={item.name} href={item.href}> <Button variant={isActive ? 'default' : 'ghost'} size="sm" className={cn( 'flex items-center gap-2', isActive && 'bg-primary text-primary-foreground' )} > <Icon className="h-4 w-4" /> {item.name} </Button> </Link> ); })} </div> </div> <div className="flex items-center space-x-4"> <div className="text-sm text-gray-600"> TanStack Query + Zustand </div> </div> </div> </nav> ); }
```

# shared\components\error-boundary.tsx

```tsx
'use client'; import { ErrorBoundary as ReactErrorBoundary } from 'react-error-boundary'; import { Button } from '@/components/ui/button'; import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'; import { AlertTriangle, RefreshCw } from 'lucide-react'; interface ErrorFallbackProps { error: Error; resetErrorBoundary: () => void; } export function ErrorFallback({ error, resetErrorBoundary }: ErrorFallbackProps) { return ( <Card className="w-full max-w-md mx-auto"> <CardHeader> <CardTitle className="flex items-center gap-2 text-destructive"> <AlertTriangle className="h-5 w-5" /> Something went wrong </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-sm text-muted-foreground"> {error.message || 'An unexpected error occurred'} </p> <div className="flex gap-2"> <Button onClick={resetErrorBoundary} size="sm"> <RefreshCw className="h-4 w-4 mr-2" /> Try again </Button> <Button variant="outline" size="sm" onClick={() => window.location.reload()} > Reload page </Button> </div> </CardContent> </Card> ); } interface ErrorBoundaryProps { children: React.ReactNode; fallback?: React.ComponentType<ErrorFallbackProps>; } export function ErrorBoundary({ children, fallback }: ErrorBoundaryProps) { return ( <ReactErrorBoundary FallbackComponent={fallback || ErrorFallback} onError={(error, errorInfo) => { // Log to monitoring service console.error('Error caught by boundary:', error, errorInfo); }} > {children} </ReactErrorBoundary> ); }
```

# shared\lib\query-keys.ts

```ts
export const queryKeys = { // Packages packages: { all: ['packages'] as const, lists: () => [...queryKeys.packages.all, 'list'] as const, list: (filters: any) => [...queryKeys.packages.lists(), { filters }] as const, details: () => [...queryKeys.packages.all, 'detail'] as const, detail: (id: string) => [...queryKeys.packages.details(), id] as const, stats: () => [...queryKeys.packages.all, 'stats'] as const, }, // Customers customers: { all: ['customers'] as const, lists: () => [...queryKeys.customers.all, 'list'] as const, list: (filters: any) => [...queryKeys.customers.lists(), { filters }] as const, details: () => [...queryKeys.customers.all, 'detail'] as const, detail: (id: string) => [...queryKeys.customers.details(), id] as const, search: (query: string) => [...queryKeys.customers.all, 'search', query] as const, }, // Dashboard dashboard: { all: ['dashboard'] as const, stats: (userId?: string) => [...queryKeys.dashboard.all, 'stats', userId] as const, activity: () => [...queryKeys.dashboard.all, 'activity'] as const, }, } as const;
```

# shared\lib\query-client.ts

```ts
import { QueryClient } from '@tanstack/react-query'; export const queryClient = new QueryClient({ defaultOptions: { queries: { staleTime: 5 * 60 * 1000, // 5 minutes gcTime: 10 * 60 * 1000, // 10 minutes retry: (failureCount, error: any) => { // Don't retry on 4xx errors if (error?.response?.status >= 400 && error?.response?.status < 500) { return false; } return failureCount < 3; }, refetchOnWindowFocus: false, refetchOnReconnect: true, }, mutations: { retry: 1, onError: (error: any) => { // Global error handling console.error('Mutation error:', error); }, }, }, });
```

# lib\db\supabase.ts

```ts
import { createClient } from '@supabase/supabase-js'; const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!; const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!; if (!supabaseUrl || !supabaseAnonKey) { throw new Error('Missing Supabase environment variables'); } // Create a single supabase client for the entire app export const supabase = createClient(supabaseUrl, supabaseAnonKey); // For server-side operations, you might want a service role client const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY; export const supabaseAdmin = supabaseServiceKey ? createClient(supabaseUrl, supabaseServiceKey, { auth: { autoRefreshToken: false, persistSession: false } }) : null;
```

# lib\db\index.ts

```ts
import { drizzle } from 'drizzle-orm/postgres-js'; import postgres from 'postgres'; import * as schema from './schema'; import dotenv from 'dotenv'; dotenv.config(); if (!process.env.POSTGRES_URL) { throw new Error('POSTGRES_URL environment variable is not set'); } export const client = postgres(process.env.POSTGRES_URL); export const db = drizzle(client, { schema });
```

# components\ui\textarea.tsx

```tsx
import * as React from "react" import { cn } from "@/lib/utils" function Textarea({ className, ...props }: React.ComponentProps<"textarea">) { return ( <textarea data-slot="textarea" className={cn( "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", className )} {...props} /> ) } export { Textarea }
```

# components\ui\tabs.tsx

```tsx
"use client" import * as React from "react" import * as TabsPrimitive from "@radix-ui/react-tabs" import { cn } from "@/lib/utils" function Tabs({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Root>) { return ( <TabsPrimitive.Root data-slot="tabs" className={cn("flex flex-col gap-2", className)} {...props} /> ) } function TabsList({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.List>) { return ( <TabsPrimitive.List data-slot="tabs-list" className={cn( "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]", className )} {...props} /> ) } function TabsTrigger({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Trigger>) { return ( <TabsPrimitive.Trigger data-slot="tabs-trigger" className={cn( "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className )} {...props} /> ) } function TabsContent({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Content>) { return ( <TabsPrimitive.Content data-slot="tabs-content" className={cn("flex-1 outline-none", className)} {...props} /> ) } export { Tabs, TabsList, TabsTrigger, TabsContent }
```

# components\ui\table.tsx

```tsx
"use client" import * as React from "react" import { cn } from "@/lib/utils" function Table({ className, ...props }: React.ComponentProps<"table">) { return ( <div data-slot="table-container" className="relative w-full overflow-x-auto" > <table data-slot="table" className={cn("w-full caption-bottom text-sm", className)} {...props} /> </div> ) } function TableHeader({ className, ...props }: React.ComponentProps<"thead">) { return ( <thead data-slot="table-header" className={cn("[&_tr]:border-b", className)} {...props} /> ) } function TableBody({ className, ...props }: React.ComponentProps<"tbody">) { return ( <tbody data-slot="table-body" className={cn("[&_tr:last-child]:border-0", className)} {...props} /> ) } function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) { return ( <tfoot data-slot="table-footer" className={cn( "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0", className )} {...props} /> ) } function TableRow({ className, ...props }: React.ComponentProps<"tr">) { return ( <tr data-slot="table-row" className={cn( "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors", className )} {...props} /> ) } function TableHead({ className, ...props }: React.ComponentProps<"th">) { return ( <th data-slot="table-head" className={cn( "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", className )} {...props} /> ) } function TableCell({ className, ...props }: React.ComponentProps<"td">) { return ( <td data-slot="table-cell" className={cn( "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", className )} {...props} /> ) } function TableCaption({ className, ...props }: React.ComponentProps<"caption">) { return ( <caption data-slot="table-caption" className={cn("text-muted-foreground mt-4 text-sm", className)} {...props} /> ) } export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption, }
```

# components\ui\switch.tsx

```tsx
"use client" import * as React from "react" import * as SwitchPrimitive from "@radix-ui/react-switch" import { cn } from "@/lib/utils" function Switch({ className, ...props }: React.ComponentProps<typeof SwitchPrimitive.Root>) { return ( <SwitchPrimitive.Root data-slot="switch" className={cn( "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", className )} {...props} > <SwitchPrimitive.Thumb data-slot="switch-thumb" className={cn( "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0" )} /> </SwitchPrimitive.Root> ) } export { Switch }
```

# components\ui\sonner.tsx

```tsx
"use client" import { useTheme } from "next-themes" import { Toaster as Sonner, ToasterProps } from "sonner" const Toaster = ({ ...props }: ToasterProps) => { const { theme = "system" } = useTheme() return ( <Sonner theme={theme as ToasterProps["theme"]} className="toaster group" style={ { "--normal-bg": "var(--popover)", "--normal-text": "var(--popover-foreground)", "--normal-border": "var(--border)", } as React.CSSProperties } {...props} /> ) } export { Toaster }
```

# components\ui\skeleton.tsx

```tsx
// components/ui/skeleton.tsx import { cn } from "@/lib/utils" function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) { return ( <div className={cn("animate-pulse rounded-md bg-gray-200", className)} {...props} /> ) } export { Skeleton }
```

# components\ui\sheet.tsx

```tsx
"use client" import * as React from "react" import * as SheetPrimitive from "@radix-ui/react-dialog" import { XIcon } from "lucide-react" import { cn } from "@/lib/utils" function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) { return <SheetPrimitive.Root data-slot="sheet" {...props} /> } function SheetTrigger({ ...props }: React.ComponentProps<typeof SheetPrimitive.Trigger>) { return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} /> } function SheetClose({ ...props }: React.ComponentProps<typeof SheetPrimitive.Close>) { return <SheetPrimitive.Close data-slot="sheet-close" {...props} /> } function SheetPortal({ ...props }: React.ComponentProps<typeof SheetPrimitive.Portal>) { return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} /> } function SheetOverlay({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Overlay>) { return ( <SheetPrimitive.Overlay data-slot="sheet-overlay" className={cn( "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className )} {...props} /> ) } function SheetContent({ className, children, side = "right", ...props }: React.ComponentProps<typeof SheetPrimitive.Content> & { side?: "top" | "right" | "bottom" | "left" }) { return ( <SheetPortal> <SheetOverlay /> <SheetPrimitive.Content data-slot="sheet-content" className={cn( "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500", side === "right" && "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm", side === "left" && "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm", side === "top" && "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b", side === "bottom" && "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t", className )} {...props} > {children} <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none"> <XIcon className="size-4" /> <span className="sr-only">Close</span> </SheetPrimitive.Close> </SheetPrimitive.Content> </SheetPortal> ) } function SheetHeader({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="sheet-header" className={cn("flex flex-col gap-1.5 p-4", className)} {...props} /> ) } function SheetFooter({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="sheet-footer" className={cn("mt-auto flex flex-col gap-2 p-4", className)} {...props} /> ) } function SheetTitle({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Title>) { return ( <SheetPrimitive.Title data-slot="sheet-title" className={cn("text-foreground font-semibold", className)} {...props} /> ) } function SheetDescription({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Description>) { return ( <SheetPrimitive.Description data-slot="sheet-description" className={cn("text-muted-foreground text-sm", className)} {...props} /> ) } export { Sheet, SheetTrigger, SheetClose, SheetContent, SheetHeader, SheetFooter, SheetTitle, SheetDescription, }
```

# components\ui\separator.tsx

```tsx
"use client" import * as React from "react" import * as SeparatorPrimitive from "@radix-ui/react-separator" import { cn } from "@/lib/utils" function Separator({ className, orientation = "horizontal", decorative = true, ...props }: React.ComponentProps<typeof SeparatorPrimitive.Root>) { return ( <SeparatorPrimitive.Root data-slot="separator" decorative={decorative} orientation={orientation} className={cn( "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px", className )} {...props} /> ) } export { Separator }
```

# components\ui\select.tsx

```tsx
"use client" import * as React from "react" import * as SelectPrimitive from "@radix-ui/react-select" import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react" import { cn } from "@/lib/utils" function Select({ ...props }: React.ComponentProps<typeof SelectPrimitive.Root>) { return <SelectPrimitive.Root data-slot="select" {...props} /> } function SelectGroup({ ...props }: React.ComponentProps<typeof SelectPrimitive.Group>) { return <SelectPrimitive.Group data-slot="select-group" {...props} /> } function SelectValue({ ...props }: React.ComponentProps<typeof SelectPrimitive.Value>) { return <SelectPrimitive.Value data-slot="select-value" {...props} /> } function SelectTrigger({ className, size = "default", children, ...props }: React.ComponentProps<typeof SelectPrimitive.Trigger> & { size?: "sm" | "default" }) { return ( <SelectPrimitive.Trigger data-slot="select-trigger" data-size={size} className={cn( "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className )} {...props} > {children} <SelectPrimitive.Icon asChild> <ChevronDownIcon className="size-4 opacity-50" /> </SelectPrimitive.Icon> </SelectPrimitive.Trigger> ) } function SelectContent({ className, children, position = "popper", ...props }: React.ComponentProps<typeof SelectPrimitive.Content>) { return ( <SelectPrimitive.Portal> <SelectPrimitive.Content data-slot="select-content" className={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md", position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", className )} position={position} {...props} > <SelectScrollUpButton /> <SelectPrimitive.Viewport className={cn( "p-1", position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1" )} > {children} </SelectPrimitive.Viewport> <SelectScrollDownButton /> </SelectPrimitive.Content> </SelectPrimitive.Portal> ) } function SelectLabel({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Label>) { return ( <SelectPrimitive.Label data-slot="select-label" className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)} {...props} /> ) } function SelectItem({ className, children, ...props }: React.ComponentProps<typeof SelectPrimitive.Item>) { return ( <SelectPrimitive.Item data-slot="select-item" className={cn( "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", className )} {...props} > <span className="absolute right-2 flex size-3.5 items-center justify-center"> <SelectPrimitive.ItemIndicator> <CheckIcon className="size-4" /> </SelectPrimitive.ItemIndicator> </span> <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText> </SelectPrimitive.Item> ) } function SelectSeparator({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Separator>) { return ( <SelectPrimitive.Separator data-slot="select-separator" className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)} {...props} /> ) } function SelectScrollUpButton({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) { return ( <SelectPrimitive.ScrollUpButton data-slot="select-scroll-up-button" className={cn( "flex cursor-default items-center justify-center py-1", className )} {...props} > <ChevronUpIcon className="size-4" /> </SelectPrimitive.ScrollUpButton> ) } function SelectScrollDownButton({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) { return ( <SelectPrimitive.ScrollDownButton data-slot="select-scroll-down-button" className={cn( "flex cursor-default items-center justify-center py-1", className )} {...props} > <ChevronDownIcon className="size-4" /> </SelectPrimitive.ScrollDownButton> ) } export { Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectScrollDownButton, SelectScrollUpButton, SelectSeparator, SelectTrigger, SelectValue, }
```

# components\ui\radio-group.tsx

```tsx
"use client"; import * as React from "react"; import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"; import { CircleIcon } from "lucide-react"; import { cn } from "@/lib/utils"; function RadioGroup({ className, ...props }: React.ComponentProps<typeof RadioGroupPrimitive.Root>) { return ( <RadioGroupPrimitive.Root data-slot="radio-group" className={cn("grid gap-3", className)} {...props} /> ); } function RadioGroupItem({ className, ...props }: React.ComponentProps<typeof RadioGroupPrimitive.Item>) { return ( <RadioGroupPrimitive.Item data-slot="radio-group-item" className={cn( "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", className )} {...props} > <RadioGroupPrimitive.Indicator data-slot="radio-group-indicator" className="relative flex items-center justify-center" > <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" /> </RadioGroupPrimitive.Indicator> </RadioGroupPrimitive.Item> ); } export { RadioGroup, RadioGroupItem };
```

# components\ui\progress.tsx

```tsx
"use client" import * as React from "react" import * as ProgressPrimitive from "@radix-ui/react-progress" import { cn } from "@/lib/utils" function Progress({ className, value, ...props }: React.ComponentProps<typeof ProgressPrimitive.Root>) { return ( <ProgressPrimitive.Root data-slot="progress" className={cn( "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full", className )} {...props} > <ProgressPrimitive.Indicator data-slot="progress-indicator" className="bg-primary h-full w-full flex-1 transition-all" style={{ transform: `translateX(-${100 - (value || 0)}%)` }} /> </ProgressPrimitive.Root> ) } export { Progress }
```

# components\ui\label.tsx

```tsx
"use client"; import * as React from "react"; import * as LabelPrimitive from "@radix-ui/react-label"; import { cn } from "@/lib/utils"; function Label({ className, ...props }: React.ComponentProps<typeof LabelPrimitive.Root>) { return ( <LabelPrimitive.Root data-slot="label" className={cn( "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", className )} {...props} /> ); } export { Label };
```

# components\ui\input.tsx

```tsx
import * as React from "react"; import { cn } from "@/lib/utils"; function Input({ className, type, ...props }: React.ComponentProps<"input">) { return ( <input type={type} data-slot="input" className={cn( "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", className )} {...props} /> ); } export { Input };
```

# components\ui\dropdown-menu.tsx

```tsx
"use client"; import * as React from "react"; import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"; import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"; import { cn } from "@/lib/utils"; function DropdownMenu({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) { return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />; } function DropdownMenuPortal({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) { return ( <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} /> ); } function DropdownMenuTrigger({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) { return ( <DropdownMenuPrimitive.Trigger data-slot="dropdown-menu-trigger" {...props} /> ); } function DropdownMenuContent({ className, sideOffset = 4, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) { return ( <DropdownMenuPrimitive.Portal> <DropdownMenuPrimitive.Content data-slot="dropdown-menu-content" sideOffset={sideOffset} className={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md", className )} {...props} /> </DropdownMenuPrimitive.Portal> ); } function DropdownMenuGroup({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) { return ( <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} /> ); } function DropdownMenuItem({ className, inset, variant = "default", ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & { inset?: boolean; variant?: "default" | "destructive"; }) { return ( <DropdownMenuPrimitive.Item data-slot="dropdown-menu-item" data-inset={inset} data-variant={variant} className={cn( "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className )} {...props} /> ); } function DropdownMenuCheckboxItem({ className, children, checked, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) { return ( <DropdownMenuPrimitive.CheckboxItem data-slot="dropdown-menu-checkbox-item" className={cn( "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className )} checked={checked} {...props} > <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center"> <DropdownMenuPrimitive.ItemIndicator> <CheckIcon className="size-4" /> </DropdownMenuPrimitive.ItemIndicator> </span> {children} </DropdownMenuPrimitive.CheckboxItem> ); } function DropdownMenuRadioGroup({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) { return ( <DropdownMenuPrimitive.RadioGroup data-slot="dropdown-menu-radio-group" {...props} /> ); } function DropdownMenuRadioItem({ className, children, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) { return ( <DropdownMenuPrimitive.RadioItem data-slot="dropdown-menu-radio-item" className={cn( "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className )} {...props} > <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center"> <DropdownMenuPrimitive.ItemIndicator> <CircleIcon className="size-2 fill-current" /> </DropdownMenuPrimitive.ItemIndicator> </span> {children} </DropdownMenuPrimitive.RadioItem> ); } function DropdownMenuLabel({ className, inset, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & { inset?: boolean; }) { return ( <DropdownMenuPrimitive.Label data-slot="dropdown-menu-label" data-inset={inset} className={cn( "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", className )} {...props} /> ); } function DropdownMenuSeparator({ className, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) { return ( <DropdownMenuPrimitive.Separator data-slot="dropdown-menu-separator" className={cn("bg-border -mx-1 my-1 h-px", className)} {...props} /> ); } function DropdownMenuShortcut({ className, ...props }: React.ComponentProps<"span">) { return ( <span data-slot="dropdown-menu-shortcut" className={cn( "text-muted-foreground ml-auto text-xs tracking-widest", className )} {...props} /> ); } function DropdownMenuSub({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) { return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />; } function DropdownMenuSubTrigger({ className, inset, children, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & { inset?: boolean; }) { return ( <DropdownMenuPrimitive.SubTrigger data-slot="dropdown-menu-sub-trigger" data-inset={inset} className={cn( "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8", className )} {...props} > {children} <ChevronRightIcon className="ml-auto size-4" /> </DropdownMenuPrimitive.SubTrigger> ); } function DropdownMenuSubContent({ className, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) { return ( <DropdownMenuPrimitive.SubContent data-slot="dropdown-menu-sub-content" className={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg", className )} {...props} /> ); } export { DropdownMenu, DropdownMenuPortal, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuGroup, DropdownMenuLabel, DropdownMenuItem, DropdownMenuCheckboxItem, DropdownMenuRadioGroup, DropdownMenuRadioItem, DropdownMenuSeparator, DropdownMenuShortcut, DropdownMenuSub, DropdownMenuSubTrigger, DropdownMenuSubContent };
```

# components\ui\dialog.tsx

```tsx
"use client" import * as React from "react" import * as DialogPrimitive from "@radix-ui/react-dialog" import { XIcon } from "lucide-react" import { cn } from "@/lib/utils" function Dialog({ ...props }: React.ComponentProps<typeof DialogPrimitive.Root>) { return <DialogPrimitive.Root data-slot="dialog" {...props} /> } function DialogTrigger({ ...props }: React.ComponentProps<typeof DialogPrimitive.Trigger>) { return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} /> } function DialogPortal({ ...props }: React.ComponentProps<typeof DialogPrimitive.Portal>) { return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} /> } function DialogClose({ ...props }: React.ComponentProps<typeof DialogPrimitive.Close>) { return <DialogPrimitive.Close data-slot="dialog-close" {...props} /> } function DialogOverlay({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Overlay>) { return ( <DialogPrimitive.Overlay data-slot="dialog-overlay" className={cn( "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className )} {...props} /> ) } function DialogContent({ className, children, showCloseButton = true, ...props }: React.ComponentProps<typeof DialogPrimitive.Content> & { showCloseButton?: boolean }) { return ( <DialogPortal data-slot="dialog-portal"> <DialogOverlay /> <DialogPrimitive.Content data-slot="dialog-content" className={cn( "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", className )} {...props} > {children} {showCloseButton && ( <DialogPrimitive.Close data-slot="dialog-close" className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4" > <XIcon /> <span className="sr-only">Close</span> </DialogPrimitive.Close> )} </DialogPrimitive.Content> </DialogPortal> ) } function DialogHeader({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="dialog-header" className={cn("flex flex-col gap-2 text-center sm:text-left", className)} {...props} /> ) } function DialogFooter({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="dialog-footer" className={cn( "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className )} {...props} /> ) } function DialogTitle({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Title>) { return ( <DialogPrimitive.Title data-slot="dialog-title" className={cn("text-lg leading-none font-semibold", className)} {...props} /> ) } function DialogDescription({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Description>) { return ( <DialogPrimitive.Description data-slot="dialog-description" className={cn("text-muted-foreground text-sm", className)} {...props} /> ) } export { Dialog, DialogClose, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogOverlay, DialogPortal, DialogTitle, DialogTrigger, }
```

# components\ui\collapsible.tsx

```tsx
// components/ui/collapsible.tsx "use client" import * as React from "react" import * as CollapsiblePrimitive from "@radix-ui/react-collapsible" const Collapsible = CollapsiblePrimitive.Root const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent export { Collapsible, CollapsibleTrigger, CollapsibleContent }
```

# components\ui\checkbox.tsx

```tsx
"use client" import * as React from "react" import * as CheckboxPrimitive from "@radix-ui/react-checkbox" import { CheckIcon } from "lucide-react" import { cn } from "@/lib/utils" function Checkbox({ className, ...props }: React.ComponentProps<typeof CheckboxPrimitive.Root>) { return ( <CheckboxPrimitive.Root data-slot="checkbox" className={cn( "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", className )} {...props} > <CheckboxPrimitive.Indicator data-slot="checkbox-indicator" className="flex items-center justify-center text-current transition-none" > <CheckIcon className="size-3.5" /> </CheckboxPrimitive.Indicator> </CheckboxPrimitive.Root> ) } export { Checkbox }
```

# components\ui\card.tsx

```tsx
import * as React from "react"; import { cn } from "@/lib/utils"; function Card({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="card" className={cn( "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm", className )} {...props} /> ); } function CardHeader({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="card-header" className={cn( "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6", className )} {...props} /> ); } function CardTitle({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="card-title" className={cn("leading-none font-semibold", className)} {...props} /> ); } function CardDescription({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="card-description" className={cn("text-muted-foreground text-sm", className)} {...props} /> ); } function CardAction({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="card-action" className={cn( "col-start-2 row-span-2 row-start-1 self-start justify-self-end", className )} {...props} /> ); } function CardContent({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="card-content" className={cn("px-6", className)} {...props} /> ); } function CardFooter({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="card-footer" className={cn("flex items-center px-6 [.border-t]:pt-6", className)} {...props} /> ); } export { Card, CardHeader, CardFooter, CardTitle, CardAction, CardDescription, CardContent };
```

# components\ui\button.tsx

```tsx
import * as React from "react"; import { Slot as SlotPrimitive } from "@radix-ui/react-slot"; import { cva, type VariantProps } from "class-variance-authority"; import { cn } from "@/lib/utils"; const buttonVariants = cva( "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", { variants: { variant: { default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90", destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60", outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50", secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-9 px-4 py-2 has-[>svg]:px-3", sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5", lg: "h-10 rounded-md px-6 has-[>svg]:px-4", icon: "size-9" } }, defaultVariants: { variant: "default", size: "default" } } ); function Button({ className, variant, size, asChild = false, ...props }: React.ComponentProps<"button"> & VariantProps<typeof buttonVariants> & { asChild?: boolean; }) { const Comp = asChild ? SlotPrimitive : "button"; return ( <Comp data-slot="button" className={cn(buttonVariants({ variant, size, className }))} {...props} /> ); } export { Button, buttonVariants };
```

# components\ui\badge.tsx

```tsx
import * as React from "react" import { Slot } from "@radix-ui/react-slot" import { cva, type VariantProps } from "class-variance-authority" import { cn } from "@/lib/utils" const badgeVariants = cva( "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden", { variants: { variant: { default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90", secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90", destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60", outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground", }, }, defaultVariants: { variant: "default", }, } ) function Badge({ className, variant, asChild = false, ...props }: React.ComponentProps<"span"> & VariantProps<typeof badgeVariants> & { asChild?: boolean }) { const Comp = asChild ? Slot : "span" return ( <Comp data-slot="badge" className={cn(badgeVariants({ variant }), className)} {...props} /> ) } export { Badge, badgeVariants }
```

# components\ui\avatar.tsx

```tsx
"use client"; import * as React from "react"; import * as AvatarPrimitive from "@radix-ui/react-avatar"; import { cn } from "@/lib/utils"; function Avatar({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Root>) { return ( <AvatarPrimitive.Root data-slot="avatar" className={cn( "relative flex size-8 shrink-0 overflow-hidden rounded-full", className )} {...props} /> ); } function AvatarImage({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Image>) { return ( <AvatarPrimitive.Image data-slot="avatar-image" className={cn("aspect-square size-full", className)} {...props} /> ); } function AvatarFallback({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Fallback>) { return ( <AvatarPrimitive.Fallback data-slot="avatar-fallback" className={cn( "bg-muted flex size-full items-center justify-center rounded-full", className )} {...props} /> ); } export { Avatar, AvatarImage, AvatarFallback };
```

# components\ui\alert.tsx

```tsx
import * as React from "react" import { cva, type VariantProps } from "class-variance-authority" import { cn } from "@/lib/utils" const alertVariants = cva( "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current", { variants: { variant: { default: "bg-card text-card-foreground", destructive: "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90", }, }, defaultVariants: { variant: "default", }, } ) function Alert({ className, variant, ...props }: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) { return ( <div data-slot="alert" role="alert" className={cn(alertVariants({ variant }), className)} {...props} /> ) } function AlertTitle({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="alert-title" className={cn( "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className )} {...props} /> ) } function AlertDescription({ className, ...props }: React.ComponentProps<"div">) { return ( <div data-slot="alert-description" className={cn( "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed", className )} {...props} /> ) } export { Alert, AlertTitle, AlertDescription }
```

# app\packages\page.tsx

```tsx
'use client'; import { useState } from 'react'; import { Button } from '@/components/ui/button'; import { PackageTable } from '@/features/packages/components/package-table'; import { PackageFilters } from '@/features/packages/types/package.types'; import { useGlobalStore } from '@/shared/stores/global-store'; import { Plus, Package } from 'lucide-react'; import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'; import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'; export default function PackagesPage() { const [filters, setFilters] = useState<PackageFilters>({}); const selections = useGlobalStore(state => state.selections.packages || new Set()); const handleStatusFilter = (status: string) => { setFilters(prev => ({ ...prev, status: status === 'all' ? undefined : status })); }; return ( <div className="space-y-6"> <div className="flex justify-between items-center"> <div> <h1 className="text-3xl font-bold tracking-tight flex items-center gap-2"> <Package className="h-8 w-8" /> Package Management </h1> <p className="text-muted-foreground"> Manage incoming packages and track their status </p> </div> <Button> <Plus className="h-4 w-4 mr-2" /> Add Package </Button> </div> {/* Stats Cards */} <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4"> <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Total Packages</CardTitle> <Package className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">3</div> <p className="text-xs text-muted-foreground"> All time packages </p> </CardContent> </Card> <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Processing</CardTitle> <Package className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">1</div> <p className="text-xs text-muted-foreground"> Currently processing </p> </CardContent> </Card> <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Ready to Ship</CardTitle> <Package className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">1</div> <p className="text-xs text-muted-foreground"> Ready for shipment </p> </CardContent> </Card> <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Received</CardTitle> <Package className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">1</div> <p className="text-xs text-muted-foreground"> Recently received </p> </CardContent> </Card> </div> {/* Filters and Table */} <Card> <CardHeader> <CardTitle>Packages</CardTitle> <CardDescription> View and manage all packages in the system </CardDescription> </CardHeader> <CardContent> <Tabs defaultValue="all" className="space-y-4"> <TabsList> <TabsTrigger value="all" onClick={() => handleStatusFilter('all')}> All </TabsTrigger> <TabsTrigger value="received" onClick={() => handleStatusFilter('received')}> Received </TabsTrigger> <TabsTrigger value="processing" onClick={() => handleStatusFilter('processing')}> Processing </TabsTrigger> <TabsTrigger value="ready_to_ship" onClick={() => handleStatusFilter('ready_to_ship')}> Ready to Ship </TabsTrigger> <TabsTrigger value="shipped" onClick={() => handleStatusFilter('shipped')}> Shipped </TabsTrigger> </TabsList> <TabsContent value="all" className="space-y-4"> <PackageTable filters={filters} variant="admin" onPackageClick={(pkg) => console.log('Package clicked:', pkg)} /> </TabsContent> <TabsContent value="received" className="space-y-4"> <PackageTable filters={filters} variant="admin" onPackageClick={(pkg) => console.log('Package clicked:', pkg)} /> </TabsContent> <TabsContent value="processing" className="space-y-4"> <PackageTable filters={filters} variant="admin" onPackageClick={(pkg) => console.log('Package clicked:', pkg)} /> </TabsContent> <TabsContent value="ready_to_ship" className="space-y-4"> <PackageTable filters={filters} variant="admin" onPackageClick={(pkg) => console.log('Package clicked:', pkg)} /> </TabsContent> <TabsContent value="shipped" className="space-y-4"> <PackageTable filters={filters} variant="admin" onPackageClick={(pkg) => console.log('Package clicked:', pkg)} /> </TabsContent> </Tabs> </CardContent> </Card> </div> ); }
```

# app\customers\page.tsx

```tsx
'use client'; import { useState } from 'react'; import { Button } from '@/components/ui/button'; import { CustomerTable } from '@/features/customers/components/customer-table'; import { CustomerFilters } from '@/features/customers/types/customer.types'; import { Plus, Users } from 'lucide-react'; import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'; import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'; export default function CustomersPage() { const [filters, setFilters] = useState<CustomerFilters>({}); const handleStatusFilter = (status: string) => { setFilters(prev => ({ ...prev, status: status === 'all' ? undefined : status })); }; return ( <div className="space-y-6"> <div className="flex justify-between items-center"> <div> <h1 className="text-3xl font-bold tracking-tight flex items-center gap-2"> <Users className="h-8 w-8" /> Customer Management </h1> <p className="text-muted-foreground"> Manage customer accounts and track their activity </p> </div> <Button> <Plus className="h-4 w-4 mr-2" /> Add Customer </Button> </div> {/* Stats Cards */} <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4"> <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Total Customers</CardTitle> <Users className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">3</div> <p className="text-xs text-muted-foreground"> All registered customers </p> </CardContent> </Card> <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Active</CardTitle> <Users className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">2</div> <p className="text-xs text-muted-foreground"> Currently active </p> </CardContent> </Card> <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Total Revenue</CardTitle> <Users className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">$2,051</div> <p className="text-xs text-muted-foreground"> From all customers </p> </CardContent> </Card> <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Avg. Packages</CardTitle> <Users className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">3.0</div> <p className="text-xs text-muted-foreground"> Per customer </p> </CardContent> </Card> </div> {/* Filters and Table */} <Card> <CardHeader> <CardTitle>Customers</CardTitle> <CardDescription> View and manage all customers in the system </CardDescription> </CardHeader> <CardContent> <Tabs defaultValue="all" className="space-y-4"> <TabsList> <TabsTrigger value="all" onClick={() => handleStatusFilter('all')}> All </TabsTrigger> <TabsTrigger value="active" onClick={() => handleStatusFilter('active')}> Active </TabsTrigger> <TabsTrigger value="inactive" onClick={() => handleStatusFilter('inactive')}> Inactive </TabsTrigger> <TabsTrigger value="suspended" onClick={() => handleStatusFilter('suspended')}> Suspended </TabsTrigger> </TabsList> <TabsContent value="all" className="space-y-4"> <CustomerTable filters={filters} onCustomerClick={(customer) => console.log('Customer clicked:', customer)} /> </TabsContent> <TabsContent value="active" className="space-y-4"> <CustomerTable filters={filters} onCustomerClick={(customer) => console.log('Customer clicked:', customer)} /> </TabsContent> <TabsContent value="inactive" className="space-y-4"> <CustomerTable filters={filters} onCustomerClick={(customer) => console.log('Customer clicked:', customer)} /> </TabsContent> <TabsContent value="suspended" className="space-y-4"> <CustomerTable filters={filters} onCustomerClick={(customer) => console.log('Customer clicked:', customer)} /> </TabsContent> </Tabs> </CardContent> </Card> </div> ); }
```

# shared\services\supabase\client.ts

```ts
import { createClient } from '@supabase/supabase-js'; // These environment variables need to be set in your .env.local file const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''; const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''; // Create a single supabase client for the entire app export const supabase = createClient(supabaseUrl, supabaseAnonKey); // Export a function to get the client for easier mocking/testing export const getSupabaseClient = () => supabase;
```

# shared\services\api\client.ts

```ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios'; export interface ApiResponse<T = any> { data: T; message?: string; success: boolean; } export interface PaginatedResponse<T> extends ApiResponse<T[]> { pagination: { page: number; limit: number; total: number; pages: number; }; } class ApiClient { private client: AxiosInstance; constructor() { this.client = axios.create({ baseURL: process.env.NEXT_PUBLIC_API_URL || '/api', timeout: 15000, headers: { 'Content-Type': 'application/json', }, }); this.setupInterceptors(); } private setupInterceptors() { // Request interceptor this.client.interceptors.request.use( (config) => { // Add auth token if available const token = this.getAuthToken(); if (token) { config.headers.Authorization = `Bearer ${token}`; } return config; }, (error) => Promise.reject(error) ); // Response interceptor this.client.interceptors.response.use( (response) => response.data, (error) => { if (error.response?.status === 401) { // Handle unauthorized this.handleUnauthorized(); } return Promise.reject(error); } ); } private getAuthToken(): string | null { // Implementation depends on your auth strategy if (typeof window !== 'undefined') { return localStorage.getItem('auth_token'); } return null; } private handleUnauthorized() { // Redirect to login or refresh token if (typeof window !== 'undefined') { window.location.href = '/login'; } } async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> { return this.client.get(url, config); } async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> { return this.client.post(url, data, config); } async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> { return this.client.put(url, data, config); } async patch<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> { return this.client.patch(url, data, config); } async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> { return this.client.delete(url, config); } } export const apiClient = new ApiClient();
```

# shared\components\data-table\data-table.tsx

```tsx
'use client'; import * as React from 'react'; import { ColumnDef, ColumnFiltersState, SortingState, VisibilityState, flexRender, getCoreRowModel, getFilteredRowModel, getPaginationRowModel, getSortedRowModel, useReactTable, } from '@tanstack/react-table'; import { ChevronDown, Search, RefreshCw } from 'lucide-react'; import { Button } from '@/components/ui/button'; import { Input } from '@/components/ui/input'; import { DropdownMenu, DropdownMenuCheckboxItem, DropdownMenuContent, DropdownMenuTrigger, } from '@/components/ui/dropdown-menu'; import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow, } from '@/components/ui/table'; import { Card, CardContent } from '@/components/ui/card'; interface DataTableProps<TData, TValue> { columns: ColumnDef<TData, TValue>[]; data: TData[]; searchKey?: string; searchPlaceholder?: string; isLoading?: boolean; loadingMessage?: string; emptyMessage?: string; onRefresh?: () => void; // Server-side pagination props pagination?: { page: number; limit: number; total: number; pages: number; }; onPaginationChange?: (page: number, limit: number) => void; // Additional filters filters?: React.ReactNode; // Actions actions?: React.ReactNode; // Row click handler onRowClick?: (row: TData) => void; } export function DataTable<TData, TValue>({ columns, data, searchKey, searchPlaceholder = 'Search...', isLoading = false, loadingMessage = 'Loading...', emptyMessage = 'No results found.', onRefresh, pagination, onPaginationChange, filters, actions, onRowClick, }: DataTableProps<TData, TValue>) { const [sorting, setSorting] = React.useState<SortingState>([]); const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([]); const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>({}); const [rowSelection, setRowSelection] = React.useState({}); // Use server-side pagination if provided, otherwise use client-side const isServerSidePagination = !!pagination && !!onPaginationChange; const table = useReactTable({ data, columns, getCoreRowModel: getCoreRowModel(), getPaginationRowModel: isServerSidePagination ? undefined : getPaginationRowModel(), getSortedRowModel: getSortedRowModel(), getFilteredRowModel: getFilteredRowModel(), onSortingChange: setSorting, onColumnFiltersChange: setColumnFilters, onColumnVisibilityChange: setColumnVisibility, onRowSelectionChange: setRowSelection, state: { sorting, columnFilters, columnVisibility, rowSelection, }, manualPagination: isServerSidePagination, pageCount: pagination?.pages ?? -1, }); const handleSearch = (value: string) => { if (searchKey) { table.getColumn(searchKey)?.setFilterValue(value); } }; const handlePageChange = (newPage: number) => { if (isServerSidePagination && onPaginationChange) { onPaginationChange(newPage, pagination?.limit || 20); } else { table.setPageIndex(newPage - 1); } }; const handlePageSizeChange = (pageSize: number) => { if (isServerSidePagination && onPaginationChange) { onPaginationChange(1, pageSize); } else { table.setPageSize(pageSize); } }; const currentPage = isServerSidePagination ? pagination?.page || 1 : table.getState().pagination.pageIndex + 1; const totalPages = isServerSidePagination ? pagination?.pages || 1 : table.getPageCount(); const pageSize = isServerSidePagination ? pagination?.limit || 20 : table.getState().pagination.pageSize; const totalItems = isServerSidePagination ? pagination?.total || 0 : table.getFilteredRowModel()?.rows?.length || 0; return ( <Card> <CardContent className="p-6"> {/* Header with search, filters, and actions */} <div className="flex flex-col space-y-4 mb-6"> <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between space-y-4 sm:space-y-0"> <div className="flex flex-1 space-x-2"> {searchKey && ( <div className="relative flex-1 max-w-sm"> <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" /> <Input placeholder={searchPlaceholder} value={(table.getColumn(searchKey)?.getFilterValue() as string) ?? ''} onChange={(event) => handleSearch(event.target.value)} className="pl-8" /> </div> )} {filters} </div> <div className="flex items-center space-x-2"> {onRefresh && ( <Button variant="outline" size="sm" onClick={onRefresh} disabled={isLoading} > <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} /> </Button> )} <DropdownMenu> <DropdownMenuTrigger asChild> <Button variant="outline" size="sm"> Columns <ChevronDown className="ml-2 h-4 w-4" /> </Button> </DropdownMenuTrigger> <DropdownMenuContent align="end"> {table .getAllColumns() .filter((column) => column.getCanHide()) .map((column) => { return ( <DropdownMenuCheckboxItem key={column.id} className="capitalize" checked={column.getIsVisible()} onCheckedChange={(value) => column.toggleVisibility(!!value)} > {column.id} </DropdownMenuCheckboxItem> ); })} </DropdownMenuContent> </DropdownMenu> {actions} </div> </div> </div> {/* Table */} {isLoading ? ( <div className="flex items-center justify-center py-12"> <RefreshCw className="h-6 w-6 animate-spin text-gray-400" /> <span className="ml-2 text-gray-500">{loadingMessage}</span> </div> ) : ( <> <div className="rounded-md border"> <Table> <TableHeader> {table.getHeaderGroups().map((headerGroup) => ( <TableRow key={headerGroup.id}> {headerGroup.headers.map((header) => { return ( <TableHead key={header.id}> {header.isPlaceholder ? null : flexRender( header.column.columnDef.header, header.getContext() )} </TableHead> ); })} </TableRow> ))} </TableHeader> <TableBody> {table.getRowModel().rows?.length ? ( table.getRowModel().rows?.map((row) => ( <TableRow key={row.id} data-state={row.getIsSelected() && 'selected'} className={onRowClick ? 'cursor-pointer hover:bg-muted/50' : ''} onClick={onRowClick ? () => onRowClick(row.original) : undefined} > {row.getVisibleCells().map((cell) => ( <TableCell key={cell.id}> {flexRender(cell.column.columnDef.cell, cell.getContext())} </TableCell> ))} </TableRow> )) ) : ( <TableRow> <TableCell colSpan={columns.length} className="h-24 text-center"> {emptyMessage} </TableCell> </TableRow> )} </TableBody> </Table> </div> {/* Pagination */} <div className="flex items-center justify-between mt-4"> <div className="text-sm text-gray-500"> Showing {Math.min((currentPage - 1) * pageSize + 1, totalItems)} to{' '} {Math.min(currentPage * pageSize, totalItems)} of {totalItems} results </div> <div className="flex items-center space-x-2"> <select value={pageSize} onChange={(e) => handlePageSizeChange(Number(e.target.value))} className="px-2 py-1 text-sm border rounded" > {[10, 20, 30, 50, 100].map((size) => ( <option key={size} value={size}> {size} per page </option> ))} </select> <Button variant="outline" size="sm" onClick={() => handlePageChange(currentPage - 1)} disabled={currentPage <= 1} > Previous </Button> <div className="flex items-center space-x-1"> {Array.from({ length: Math.min(5, totalPages) }, (_, i) => { const pageNum = i + 1; return ( <Button key={pageNum} variant={currentPage === pageNum ? 'default' : 'outline'} size="sm" onClick={() => handlePageChange(pageNum)} > {pageNum} </Button> ); })} </div> <Button variant="outline" size="sm" onClick={() => handlePageChange(currentPage + 1)} disabled={currentPage >= totalPages} > Next </Button> </div> </div> </> )} </CardContent> </Card> ); }
```

# lib\db\seed\utils.ts

```ts
// lib/db/seed/utils.ts import { randomBytes } from 'crypto'; export function generateId(): string { return randomBytes(16).toString('hex'); } export function generateCustomerId(): string { const prefix = 'PF'; const randomPart = Math.random().toString(36).substring(2, 8).toUpperCase(); return `${prefix}${randomPart}`; } export function generateTrackingNumber(): string { const prefix = 'TRK'; const randomPart = Math.random().toString(36).substring(2, 12).toUpperCase(); return `${prefix}${randomPart}`; } export function generateInvoiceNumber(): string { const prefix = 'INV'; const timestamp = Date.now().toString().slice(-6); const randomPart = Math.random().toString(36).substring(2, 6).toUpperCase(); return `${prefix}-${timestamp}-${randomPart}`; } export function generateShipmentNumber(): string { const prefix = 'SHP'; const timestamp = Date.now().toString().slice(-6); const randomPart = Math.random().toString(36).substring(2, 6).toUpperCase(); return `${prefix}-${timestamp}-${randomPart}`; } export function generateRequestNumber(): string { const prefix = 'PS'; const timestamp = Date.now().toString().slice(-6); return `${prefix}-${timestamp}`; } export function randomChoice<T>(array: T[]): T { return array[Math.floor(Math.random() * array.length)]; } export function randomDate(start: Date, end: Date): Date { return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime())); } export function randomFutureDate(days: number = 30): Date { const now = new Date(); const future = new Date(now.getTime() + days * 24 * 60 * 60 * 1000); return randomDate(now, future); } export function randomPastDate(days: number = 30): Date { const now = new Date(); const past = new Date(now.getTime() - days * 24 * 60 * 60 * 1000); return randomDate(past, now); } export function randomDecimal(min: number, max: number, decimals: number = 2): string { const value = Math.random() * (max - min) + min; return value.toFixed(decimals); } export function randomInt(min: number, max: number): number { return Math.floor(Math.random() * (max - min + 1)) + min; } export function randomBoolean(probability: number = 0.5): boolean { return Math.random() < probability; } // Sample data arrays export const sampleNames = [ 'John Smith', 'Jane Doe', 'Michael Johnson', 'Sarah Wilson', 'David Brown', 'Emily Davis', 'James Miller', 'Emma Garcia', 'William Martinez', 'Olivia Rodriguez', 'Alexander Thompson', 'Isabella White', 'Benjamin Harris', 'Ava Clark', 'Lucas Lewis', 'Sophia Lee', 'Henry Walker', 'Charlotte Hall', 'Owen Allen', 'Amelia Young' ]; export const sampleCompanies = [ 'Tech Solutions Inc', 'Global Trading Co', 'Innovative Systems Ltd', 'Digital Commerce Group', 'International Logistics', 'Modern Electronics', 'Advanced Manufacturing', 'Creative Designs LLC', 'Strategic Consulting', 'Premium Services Corp', 'Dynamic Solutions', 'Future Technologies' ]; export const sampleAddresses = [ { address: '123 Main St', city: 'New York', state: 'NY', country: 'US', postal: '10001' }, { address: '456 Oak Ave', city: 'Los Angeles', state: 'CA', country: 'US', postal: '90210' }, { address: '789 Pine Rd', city: 'Chicago', state: 'IL', country: 'US', postal: '60601' }, { address: '321 Elm St', city: 'Houston', state: 'TX', country: 'US', postal: '77001' }, { address: '654 Maple Dr', city: 'Phoenix', state: 'AZ', country: 'US', postal: '85001' }, { address: '987 Cedar Ln', city: 'Philadelphia', state: 'PA', country: 'US', postal: '19101' }, { address: '147 Birch Ct', city: 'San Antonio', state: 'TX', country: 'US', postal: '78201' }, { address: '258 Spruce Way', city: 'San Diego', state: 'CA', country: 'US', postal: '92101' }, { address: '369 Ash Blvd', city: 'Dallas', state: 'TX', country: 'US', postal: '75201' }, { address: '741 Walnut St', city: 'San Jose', state: 'CA', country: 'US', postal: '95101' } ]; export const sampleCountries = [ { code: 'US', name: 'United States' }, { code: 'CA', name: 'Canada' }, { code: 'UK', name: 'United Kingdom' }, { code: 'AU', name: 'Australia' }, { code: 'DE', name: 'Germany' }, { code: 'FR', name: 'France' }, { code: 'JP', name: 'Japan' }, { code: 'CN', name: 'China' } ]; export const sampleProductDescriptions = [ 'Electronics - Smartphone', 'Clothing - T-Shirt', 'Books - Novel', 'Electronics - Headphones', 'Home & Garden - Kitchen Utensils', 'Toys - Action Figure', 'Sports - Running Shoes', 'Beauty - Skincare Set', 'Electronics - Tablet', 'Clothing - Jeans', 'Books - Technical Manual', 'Home & Garden - Decorative Vase', 'Electronics - Smartwatch', 'Clothing - Winter Jacket', 'Sports - Yoga Mat', 'Beauty - Makeup Kit' ]; export const packageStatuses = ['expected', 'received', 'processing', 'ready_to_ship', 'shipped', 'delivered'] as const; export const shipmentStatuses = ['quote_requested', 'quoted', 'paid', 'processing', 'dispatched', 'in_transit', 'delivered'] as const; export const customerStatuses = ['active', 'inactive', 'suspended'] as const; export const warehouseStatuses = ['active', 'inactive', 'maintenance'] as const; export const invoiceStatuses = ['pending', 'paid', 'overdue', 'cancelled'] as const; export function logSeedProgress(message: string) { console.log(`🌱 ${message}`); } export function logSeedError(message: string, error?: any) { console.error(`❌ ${message}`, error); } export function logSeedSuccess(message: string) { console.log(`✅ ${message}`); }
```

# lib\db\seed\seed-warehouses.ts

```ts
// lib/db/seed/seed-warehouses.ts import { db } from '../index'; import { warehouses, customerWarehouseAssignments, storagePricing, binLocations } from '@/features/warehouses/db/schema'; import { type Tenant } from '@/features/auth/db/schema'; import { type CustomerProfile } from '@/features/customers/db/schema'; import { logSeedProgress, logSeedSuccess, randomChoice, randomDecimal, randomInt, randomBoolean } from './utils'; export async function seedWarehouses(tenants: Tenant[], customerProfiles: CustomerProfile[]) { logSeedProgress('Seeding warehouses, storage pricing, and bin locations...'); const warehouseData = []; const storagePricingData = []; const binLocationData = []; const customerWarehouseAssignmentData = []; // Create warehouses for each tenant for (const tenant of tenants) { const tenantWarehouses = [ { tenantId: tenant.id, code: 'WH-NYC-01', name: 'New York Distribution Center', description: 'Main distribution center in New York', countryCode: 'US', addressLine1: '123 Warehouse Blvd', addressLine2: 'Suite 100', city: 'New York', stateProvince: 'NY', postalCode: '10001', phone: '+1-212-555-0100', email: 'nyc@' + tenant.domain, timezone: 'America/New_York', currencyCode: 'USD', taxTreatment: 'standard', storageFreeDays: 30, storageFeePerDay: randomDecimal(1, 3), maxPackageWeightKg: randomDecimal(25, 50), maxPackageValue: randomDecimal(5000, 15000), status: 'active', acceptsNewPackages: true, operatingHours: { monday: { open: '08:00', close: '18:00' }, tuesday: { open: '08:00', close: '18:00' }, wednesday: { open: '08:00', close: '18:00' }, thursday: { open: '08:00', close: '18:00' }, friday: { open: '08:00', close: '18:00' }, saturday: { open: '09:00', close: '15:00' }, sunday: { closed: true } } }, { tenantId: tenant.id, code: 'WH-LAX-01', name: 'Los Angeles Fulfillment Center', description: 'West coast fulfillment center', countryCode: 'US', addressLine1: '456 Pacific Ave', addressLine2: null, city: 'Los Angeles', stateProvince: 'CA', postalCode: '90210', phone: '+1-310-555-0200', email: 'lax@' + tenant.domain, timezone: 'America/Los_Angeles', currencyCode: 'USD', taxTreatment: 'standard', storageFreeDays: 21, storageFeePerDay: randomDecimal(1, 3), maxPackageWeightKg: randomDecimal(25, 50), maxPackageValue: randomDecimal(5000, 15000), status: 'active', acceptsNewPackages: true, operatingHours: { monday: { open: '08:00', close: '18:00' }, tuesday: { open: '08:00', close: '18:00' }, wednesday: { open: '08:00', close: '18:00' }, thursday: { open: '08:00', close: '18:00' }, friday: { open: '08:00', close: '18:00' }, saturday: { open: '09:00', close: '15:00' }, sunday: { closed: true } } } ]; warehouseData.push(...tenantWarehouses); } // Insert warehouses const insertedWarehouses = await db.insert(warehouses).values(warehouseData).returning(); // Create storage pricing for each warehouse for (const warehouse of insertedWarehouses) { const pricing = { tenantId: warehouse.tenantId, warehouseId: warehouse.id, freeDays: warehouse.storageFreeDays, dailyRateAfterFree: randomDecimal(1.50, 3.00), currency: warehouse.currencyCode, effectiveFrom: new Date('2024-01-01'), effectiveUntil: null, isActive: true, notes: `Standard storage pricing for ${warehouse.name}`, createdBy: null // Will be admin user ID in real scenario }; storagePricingData.push(pricing); } await db.insert(storagePricing).values(storagePricingData); // Create bin locations for each warehouse for (const warehouse of insertedWarehouses) { const zones = ['A', 'B', 'C', 'D']; const binTypes = [ { type: 'Standard', premium: '0.00', climate: false, secure: false }, { type: 'Climate Controlled', premium: '0.50', climate: true, secure: false }, { type: 'Secure', premium: '0.75', climate: false, secure: true }, { type: 'Premium', premium: '1.00', climate: true, secure: true } ]; for (const zone of zones) { for (let row = 1; row <= 10; row++) { const binType = randomChoice(binTypes); const bin = { tenantId: warehouse.tenantId, warehouseId: warehouse.id, binCode: `${zone}${row.toString().padStart(2, '0')}`, zoneName: `Zone ${zone}`, description: `${binType.type} storage bin in Zone ${zone}`, maxCapacity: randomInt(5, 15), currentOccupancy: randomInt(0, 5), maxWeightKg: randomDecimal(50, 200), dailyPremium: binType.premium, currency: warehouse.currencyCode, isClimateControlled: binType.climate, isSecured: binType.secure, isAccessible: true, isActive: true }; binLocationData.push(bin); } } } const insertedBinLocations = await db.insert(binLocations).values(binLocationData).returning(); // Create customer warehouse assignments for (const customerProfile of customerProfiles) { // Get warehouses for this tenant const tenantWarehouses = insertedWarehouses.filter(w => w.tenantId === customerProfile.tenantId); if (tenantWarehouses.length > 0) { // Assign customer to a random warehouse const warehouse = randomChoice(tenantWarehouses); const assignment = { customerProfileId: customerProfile.id, warehouseId: warehouse.id, suiteCode: `SUITE-${customerProfile.customerId}`, status: 'active', assignedAt: new Date(), assignedBy: null // Will be admin user ID in real scenario }; customerWarehouseAssignmentData.push(assignment); } } const insertedAssignments = await db.insert(customerWarehouseAssignments).values(customerWarehouseAssignmentData).returning(); logSeedSuccess(`Created ${insertedWarehouses.length} warehouses, ${storagePricingData.length} storage pricing records, ${insertedBinLocations.length} bin locations, and ${insertedAssignments.length} customer assignments`); return { warehouses: insertedWarehouses, binLocations: insertedBinLocations, assignments: insertedAssignments }; }
```

# lib\db\seed\seed-users.ts

```ts
// lib/db/seed/seed-users.ts import { db } from '../index'; import { users, roles, permissions, rolePermissions, userRoles, type Tenant } from '@/features/auth/db/schema'; import { logSeedProgress, logSeedSuccess, sampleNames, randomChoice } from './utils'; import bcrypt from 'bcryptjs'; export async function seedUsers(tenants: Tenant[]) { logSeedProgress('Seeding permissions, roles, and users...'); // Create permissions first const permissionData = [ { name: 'View Packages', slug: 'packages.view', category: 'packages', action: 'view', description: 'View package information' }, { name: 'Create Packages', slug: 'packages.create', category: 'packages', action: 'create', description: 'Create new packages' }, { name: 'Update Packages', slug: 'packages.update', category: 'packages', action: 'update', description: 'Update package information' }, { name: 'Delete Packages', slug: 'packages.delete', category: 'packages', action: 'delete', description: 'Delete packages' }, { name: 'View Customers', slug: 'customers.view', category: 'customers', action: 'view', description: 'View customer information' }, { name: 'Create Customers', slug: 'customers.create', category: 'customers', action: 'create', description: 'Create new customers' }, { name: 'Update Customers', slug: 'customers.update', category: 'customers', action: 'update', description: 'Update customer information' }, { name: 'Delete Customers', slug: 'customers.delete', category: 'customers', action: 'delete', description: 'Delete customers' }, { name: 'View Shipments', slug: 'shipments.view', category: 'shipments', action: 'view', description: 'View shipment information' }, { name: 'Create Shipments', slug: 'shipments.create', category: 'shipments', action: 'create', description: 'Create new shipments' }, { name: 'Update Shipments', slug: 'shipments.update', category: 'shipments', action: 'update', description: 'Update shipment information' }, { name: 'Delete Shipments', slug: 'shipments.delete', category: 'shipments', action: 'delete', description: 'Delete shipments' }, { name: 'View Warehouses', slug: 'warehouses.view', category: 'warehouses', action: 'view', description: 'View warehouse information' }, { name: 'Manage Warehouses', slug: 'warehouses.manage', category: 'warehouses', action: 'manage', description: 'Manage warehouse operations' }, { name: 'View Finance', slug: 'finance.view', category: 'finance', action: 'view', description: 'View financial information' }, { name: 'Manage Finance', slug: 'finance.manage', category: 'finance', action: 'manage', description: 'Manage financial operations' }, { name: 'View Reports', slug: 'reports.view', category: 'reports', action: 'view', description: 'View reports and analytics' }, { name: 'System Admin', slug: 'system.admin', category: 'system', action: 'admin', description: 'System administration access' }, ]; const insertedPermissions = await db.insert(permissions).values(permissionData).returning(); // Create roles for each tenant const roleData = []; const rolePermissionData = []; const userData = []; const userRoleData = []; for (const tenant of tenants) { // Define roles for this tenant const tenantRoles = [ { tenantId: tenant.id, name: 'Super Admin', slug: 'super_admin', description: 'Full system access', roleType: 'admin' as const, isSystemRole: true }, { tenantId: tenant.id, name: 'Admin', slug: 'admin', description: 'Administrative access', roleType: 'admin' as const, isSystemRole: false }, { tenantId: tenant.id, name: 'Staff', slug: 'staff', description: 'Staff member access', roleType: 'staff' as const, isSystemRole: false }, { tenantId: tenant.id, name: 'Customer', slug: 'customer', description: 'Customer access', roleType: 'customer' as const, isSystemRole: true } ]; roleData.push(...tenantRoles); // Create users for this tenant const hashedPassword = await bcrypt.hash('password123', 10); // Super Admin userData.push({ tenantId: tenant.id, email: `admin@${tenant.domain}`, passwordHash: hashedPassword, firstName: 'Super', lastName: 'Admin', userType: 'admin' as const, status: 'active' as const, emailVerifiedAt: new Date(), }); // Regular Admin userData.push({ tenantId: tenant.id, email: `manager@${tenant.domain}`, passwordHash: hashedPassword, firstName: 'Manager', lastName: 'User', userType: 'admin' as const, status: 'active' as const, emailVerifiedAt: new Date(), }); // Staff members for (let i = 0; i < 3; i++) { const name = randomChoice(sampleNames).split(' '); userData.push({ tenantId: tenant.id, email: `staff${i + 1}@${tenant.domain}`, passwordHash: hashedPassword, firstName: name[0], lastName: name[1], userType: 'staff' as const, status: 'active' as const, emailVerifiedAt: new Date(), }); } // Customers for (let i = 0; i < 10; i++) { const name = randomChoice(sampleNames).split(' '); userData.push({ tenantId: tenant.id, email: `customer${i + 1}@example.com`, passwordHash: hashedPassword, firstName: name[0], lastName: name[1], userType: 'customer' as const, status: 'active' as const, emailVerifiedAt: new Date(), }); } } // Insert roles const insertedRoles = await db.insert(roles).values(roleData).returning(); // Create role-permission mappings for (const role of insertedRoles) { let permissionsToAssign = []; if (role.slug === 'super_admin') { // Super admin gets all permissions permissionsToAssign = insertedPermissions.map(p => p.id); } else if (role.slug === 'admin') { // Admin gets most permissions except system admin permissionsToAssign = insertedPermissions .filter(p => p.slug !== 'system.admin') .map(p => p.id); } else if (role.slug === 'staff') { // Staff gets view and basic operations permissionsToAssign = insertedPermissions .filter(p => p.action === 'view' || p.action === 'create' || p.action === 'update' ) .map(p => p.id); } else if (role.slug === 'customer') { // Customers get limited view permissions permissionsToAssign = insertedPermissions .filter(p => p.category === 'packages' && p.action === 'view' || p.category === 'shipments' && p.action === 'view' ) .map(p => p.id); } for (const permissionId of permissionsToAssign) { rolePermissionData.push({ roleId: role.id, permissionId: permissionId }); } } await db.insert(rolePermissions).values(rolePermissionData); // Insert users const insertedUsers = await db.insert(users).values(userData).returning(); // Assign roles to users for (const user of insertedUsers) { const tenantRoles = insertedRoles.filter(r => r.tenantId === user.tenantId); let roleToAssign; if (user.email.includes('admin@')) { roleToAssign = tenantRoles.find(r => r.slug === 'super_admin'); } else if (user.email.includes('manager@')) { roleToAssign = tenantRoles.find(r => r.slug === 'admin'); } else if (user.email.includes('staff')) { roleToAssign = tenantRoles.find(r => r.slug === 'staff'); } else { roleToAssign = tenantRoles.find(r => r.slug === 'customer'); } if (roleToAssign) { userRoleData.push({ userId: user.id, roleId: roleToAssign.id, assignedBy: user.id // Self-assigned for seeding }); } } await db.insert(userRoles).values(userRoleData); logSeedSuccess(`Created ${insertedPermissions.length} permissions, ${insertedRoles.length} roles, and ${insertedUsers.length} users`); return { permissions: insertedPermissions, roles: insertedRoles, users: insertedUsers }; }
```

# lib\db\seed\seed-tenants.ts

```ts
// lib/db/seed/seed-tenants.ts import { db } from '../index'; import { tenants } from '@/features/auth/db/schema'; import { logSeedProgress, logSeedSuccess } from './utils'; export async function seedTenants() { logSeedProgress('Seeding tenants...'); const tenantData = [ { name: 'Package Forward Pro', slug: 'package-forward-pro', domain: 'packageforwardpro.com', companyName: 'Package Forward Pro Inc.', companyRegistration: 'REG-001-2024', taxNumber: 'TAX-PFP-001', planType: 'enterprise', billingEmail: 'billing@packageforwardpro.com', status: 'active' as const, maxUsers: 1000, maxPackagesMonthly: 50000, settings: { timezone: 'America/New_York', currency: 'USD', notifications: { email: true, sms: true, push: true }, features: { personalShopper: true, consolidation: true, insurance: true, storage: true } }, branding: { primaryColor: '#2563eb', logo: '/logos/package-forward-pro.png', favicon: '/favicons/package-forward-pro.ico' } }, { name: 'Global Ship Express', slug: 'global-ship-express', domain: 'globalshipexpress.com', companyName: 'Global Ship Express LLC', companyRegistration: 'REG-002-2024', taxNumber: 'TAX-GSE-002', planType: 'professional', billingEmail: 'billing@globalshipexpress.com', status: 'active' as const, maxUsers: 500, maxPackagesMonthly: 25000, settings: { timezone: 'America/Los_Angeles', currency: 'USD', notifications: { email: true, sms: false, push: true }, features: { personalShopper: false, consolidation: true, insurance: true, storage: false } }, branding: { primaryColor: '#059669', logo: '/logos/global-ship-express.png', favicon: '/favicons/global-ship-express.ico' } }, { name: 'QuickForward', slug: 'quickforward', domain: 'quickforward.net', companyName: 'QuickForward Services Corp', companyRegistration: 'REG-003-2024', taxNumber: 'TAX-QF-003', planType: 'standard', billingEmail: 'billing@quickforward.net', status: 'active' as const, maxUsers: 100, maxPackagesMonthly: 10000, settings: { timezone: 'America/Chicago', currency: 'USD', notifications: { email: true, sms: false, push: false }, features: { personalShopper: false, consolidation: false, insurance: false, storage: true } }, branding: { primaryColor: '#dc2626', logo: '/logos/quickforward.png', favicon: '/favicons/quickforward.ico' } } ]; const insertedTenants = await db.insert(tenants).values(tenantData).returning(); logSeedSuccess(`Created ${insertedTenants.length} tenants`); return insertedTenants; }
```

# lib\db\seed\seed-shipping.ts

```ts
// lib/db/seed/seed-shipping.ts import { db } from '../index'; import { zones, zoneCountries, shippingRates, shipments, shipmentPackages, shipmentTrackingEvents, shipmentStatusHistory } from '@/features/shipping/db/schema'; import { type Tenant } from '@/features/auth/db/schema'; import { type Warehouse } from '@/features/warehouses/db/schema'; import { type CustomerProfile } from '@/features/customers/db/schema'; import { type Package } from '@/features/packages/db/schema'; import { logSeedProgress, logSeedSuccess, generateShipmentNumber, randomChoice, randomDecimal, randomInt, randomBoolean, randomPastDate, randomFutureDate, shipmentStatuses } from './utils'; export async function seedShipping( tenants: Tenant[], warehouses: Warehouse[], customerProfiles: CustomerProfile[], packages: Package[] ) { logSeedProgress('Seeding zones, shipping rates, and shipments...'); const zoneData = []; const zoneCountryData = []; const shippingRateData = []; const shipmentData = []; const shipmentPackageData = []; const shipmentTrackingEventData = []; const shipmentStatusHistoryData = []; // Create shipping zones for each tenant for (const tenant of tenants) { const tenantZones = [ { tenantId: tenant.id, name: 'Domestic USA', description: 'United States domestic shipping', isActive: true }, { tenantId: tenant.id, name: 'Canada', description: 'Canadian shipping zone', isActive: true }, { tenantId: tenant.id, name: 'Europe', description: 'European Union countries', isActive: true }, { tenantId: tenant.id, name: 'Asia Pacific', description: 'Asia Pacific region', isActive: true }, { tenantId: tenant.id, name: 'Rest of World', description: 'All other countries', isActive: true } ]; zoneData.push(...tenantZones); } // Insert zones const insertedZones = await db.insert(zones).values(zoneData).returning(); // Create zone country mappings const zoneCountryMappings = [ { zoneName: 'Domestic USA', countries: ['US'] }, { zoneName: 'Canada', countries: ['CA'] }, { zoneName: 'Europe', countries: ['UK', 'DE', 'FR', 'IT', 'ES', 'NL', 'BE', 'AT', 'SE', 'DK'] }, { zoneName: 'Asia Pacific', countries: ['JP', 'CN', 'KR', 'AU', 'SG', 'HK', 'TW', 'TH', 'MY'] }, { zoneName: 'Rest of World', countries: ['BR', 'MX', 'IN', 'ZA', 'AE', 'RU'] } ]; for (const zone of insertedZones) { const mapping = zoneCountryMappings.find(m => m.zoneName === zone.name); if (mapping) { for (const countryCode of mapping.countries) { zoneCountryData.push({ zoneId: zone.id, countryCode: countryCode }); } } } await db.insert(zoneCountries).values(zoneCountryData); // Create shipping rates for each warehouse and zone combination const serviceTypes = ['standard', 'express', 'economy'] as const; for (const warehouse of warehouses) { const warehouseZones = insertedZones.filter(z => z.tenantId === warehouse.tenantId); for (const zone of warehouseZones) { for (const serviceType of serviceTypes) { let baseRate, perKgRate, minCharge; // Set different rates based on zone and service type switch (zone.name) { case 'Domestic USA': baseRate = serviceType === 'economy' ? '8.99' : serviceType === 'standard' ? '12.99' : '19.99'; perKgRate = serviceType === 'economy' ? '2.50' : serviceType === 'standard' ? '3.50' : '5.00'; minCharge = serviceType === 'economy' ? '8.99' : serviceType === 'standard' ? '12.99' : '19.99'; break; case 'Canada': baseRate = serviceType === 'economy' ? '15.99' : serviceType === 'standard' ? '22.99' : '35.99'; perKgRate = serviceType === 'economy' ? '4.00' : serviceType === 'standard' ? '6.00' : '8.50'; minCharge = serviceType === 'economy' ? '15.99' : serviceType === 'standard' ? '22.99' : '35.99'; break; case 'Europe': baseRate = serviceType === 'economy' ? '25.99' : serviceType === 'standard' ? '39.99' : '65.99'; perKgRate = serviceType === 'economy' ? '6.50' : serviceType === 'standard' ? '9.50' : '14.00'; minCharge = serviceType === 'economy' ? '25.99' : serviceType === 'standard' ? '39.99' : '65.99'; break; case 'Asia Pacific': baseRate = serviceType === 'economy' ? '29.99' : serviceType === 'standard' ? '45.99' : '75.99'; perKgRate = serviceType === 'economy' ? '7.50' : serviceType === 'standard' ? '11.00' : '16.50'; minCharge = serviceType === 'economy' ? '29.99' : serviceType === 'standard' ? '45.99' : '75.99'; break; default: // Rest of World baseRate = serviceType === 'economy' ? '35.99' : serviceType === 'standard' ? '55.99' : '89.99'; perKgRate = serviceType === 'economy' ? '9.00' : serviceType === 'standard' ? '13.50' : '20.00'; minCharge = serviceType === 'economy' ? '35.99' : serviceType === 'standard' ? '55.99' : '89.99'; } const rate = { tenantId: warehouse.tenantId, warehouseId: warehouse.id, zoneId: zone.id, serviceType: serviceType, baseRate: baseRate, perKgRate: perKgRate, minCharge: minCharge, maxWeightKg: randomDecimal(20, 30, 1), currencyCode: 'USD', isActive: true, effectiveFrom: new Date('2024-01-01'), effectiveUntil: null }; shippingRateData.push(rate); } } } await db.insert(shippingRates).values(shippingRateData); // Create shipments for (const warehouse of warehouses) { const warehouseCustomers = customerProfiles.filter(cp => cp.tenantId === warehouse.tenantId); const warehousePackages = packages.filter(p => p.warehouseId === warehouse.id); const warehouseZones = insertedZones.filter(z => z.tenantId === warehouse.tenantId); // Create 10-15 shipments per warehouse const shipmentCount = randomInt(10, 15); for (let i = 0; i < shipmentCount; i++) { const customer = randomChoice(warehouseCustomers); const zone = randomChoice(warehouseZones); const status = randomChoice(shipmentStatuses); const shipment = { tenantId: warehouse.tenantId, customerProfileId: customer.id, warehouseId: warehouse.id, shipmentNumber: generateShipmentNumber(), shippingAddressId: null, // Will be linked via entity addresses billingAddressId: null, companyId: null, zoneId: zone.id, carrierCode: randomChoice(['FEDEX', 'UPS', 'DHL', 'USPS']), serviceType: randomChoice(['standard', 'express', 'economy']), trackingNumber: randomBoolean(0.7) ? `TRK${Math.random().toString(36).substring(2, 15).toUpperCase()}` : null, carrierReference: randomBoolean(0.5) ? `REF${Math.random().toString(36).substring(2, 10).toUpperCase()}` : null, totalWeightKg: randomDecimal(0.5, 10.0, 2), totalDeclaredValue: randomDecimal(50, 1000), declaredValueCurrency: 'USD', shippingCost: randomDecimal(15, 150), insuranceCost: randomBoolean(0.3) ? randomDecimal(5, 25) : '0.00', handlingFee: randomDecimal(2, 8), storageFee: randomBoolean(0.4) ? randomDecimal(5, 30) : '0.00', totalCost: randomDecimal(25, 200), costCurrency: 'USD',
```

# lib\db\seed\seed-settings.ts

```ts

```

# lib\db\seed\seed-packages.ts

```ts
// lib/db/seed/seed-packages.ts import { db } from '../index'; import { packages, packageStatusHistory, incomingShipments, incomingShipmentItems } from '@/features/packages/db/schema'; import { packageBinAssignments } from '@/features/warehouses/db/schema'; import { type CustomerProfile } from '@/features/customers/db/schema'; import { type Warehouse, type BinLocation } from '@/features/warehouses/db/schema'; import { logSeedProgress, logSeedSuccess, generateTrackingNumber, randomChoice, randomDecimal, randomInt, randomBoolean, randomPastDate, randomFutureDate, sampleProductDescriptions, packageStatuses } from './utils'; export async function seedPackages( customerProfiles: CustomerProfile[], warehouses: Warehouse[], binLocations: BinLocation[] ) { logSeedProgress('Seeding incoming shipments, packages, and package history...'); const incomingShipmentData = []; const incomingShipmentItemData = []; const packageData = []; const packageStatusHistoryData = []; const packageBinAssignmentData = []; // Create incoming shipments for each warehouse for (const warehouse of warehouses) { for (let i = 0; i < 5; i++) { const shipment = { tenantId: warehouse.tenantId, warehouseId: warehouse.id, batchReference: `BATCH-${warehouse.code}-${Date.now()}-${i}`, courierId: null, // Will be set when courier seeding is done courierName: randomChoice(['FedEx', 'UPS', 'DHL', 'USPS']), trackingNumber: generateTrackingNumber(), arrivalDate: randomPastDate(30), expectedArrivalDate: randomPastDate(35), actualArrivalDate: randomPastDate(25), status: randomChoice(['pending', 'scanning', 'scanned', 'assigned', 'received']), receivedBy: null, // Will be staff user ID receivedAt: randomBoolean(0.8) ? randomPastDate(20) : null, processedBy: null, // Will be staff user ID processedAt: randomBoolean(0.7) ? randomPastDate(15) : null, notes: randomBoolean(0.3) ? 'Routine incoming shipment processing' : null, totalItems: randomInt(5, 20), processedItems: randomInt(0, 20) }; incomingShipmentData.push(shipment); } } // Insert incoming shipments const insertedIncomingShipments = await db.insert(incomingShipments).values(incomingShipmentData).returning(); // Create incoming shipment items for (const incomingShipment of insertedIncomingShipments) { const itemCount = randomInt(5, 15); for (let i = 0; i < itemCount; i++) { const item = { tenantId: incomingShipment.tenantId, warehouseId: incomingShipment.warehouseId, incomingShipmentId: incomingShipment.id, trackingNumber: generateTrackingNumber(), courierName: incomingShipment.courierName, courierTrackingUrl: `https://track.example.com/${generateTrackingNumber()}`, scannedBy: null, // Will be staff user ID scannedAt: randomBoolean(0.8) ? randomPastDate(20) : null, assignedCustomerProfileId: randomChoice(customerProfiles.filter(cp => cp.tenantId === incomingShipment.tenantId)).id, assignedBy: null, // Will be staff user ID assignedAt: randomBoolean(0.7) ? randomPastDate(15) : null, assignmentStatus: randomChoice(['unassigned', 'assigned', 'received']), weightKg: randomDecimal(0.1, 5.0, 3), lengthCm: randomDecimal(10, 50), widthCm: randomDecimal(10, 50), heightCm: randomDecimal(5, 30), description: randomChoice(sampleProductDescriptions), estimatedValue: randomDecimal(10, 500), estimatedValueCurrency: 'USD', notes: randomBoolean(0.2) ? 'Handle with care' : null, specialInstructions: randomBoolean(0.1) ? 'Fragile item - special handling required' : null, isFragile: randomBoolean(0.2), isHighValue: randomBoolean(0.1), requiresInspection: randomBoolean(0.1) }; incomingShipmentItemData.push(item); } } // Insert incoming shipment items const insertedIncomingShipmentItems = await db.insert(incomingShipmentItems).values(incomingShipmentItemData).returning(); // Create packages from incoming shipment items for (const item of insertedIncomingShipmentItems) { // Get customer profiles for this tenant const tenantCustomers = customerProfiles.filter(cp => cp.tenantId === item.tenantId); const customer = randomChoice(tenantCustomers); const packageRecord = { tenantId: item.tenantId, customerProfileId: customer.id, warehouseId: item.warehouseId, incomingShipmentItemId: item.id, internalId: `PKG-${Date.now()}-${randomInt(1000, 9999)}`, suiteCodeCaptured: `SUITE-${customer.customerId}`, trackingNumberInbound: item.trackingNumber, senderName: randomChoice(['Amazon', 'eBay Seller', 'Best Buy', 'Target', 'Walmart', 'Private Seller']), senderCompany: randomBoolean(0.7) ? randomChoice(['Amazon.com', 'eBay Inc', 'Best Buy Co', 'Target Corp']) : null, senderTrackingUrl: item.courierTrackingUrl, description: item.description, estimatedValue: item.estimatedValue, estimatedValueCurrency: item.estimatedValueCurrency, weightActualKg: item.weightKg, lengthCm: item.lengthCm, widthCm: item.widthCm, heightCm: item.heightCm, volumetricWeightKg: randomDecimal(0.1, 2.0, 3), chargeableWeightKg: randomDecimal(0.1, 5.0, 3), status: randomChoice(packageStatuses), expectedArrivalDate: randomFutureDate(7), receivedAt: randomBoolean(0.8) ? randomPastDate(10) : null, readyToShipAt: randomBoolean(0.5) ? randomPastDate(5) : null, storageExpiresAt: randomFutureDate(30), warehouseNotes: randomBoolean(0.3) ? 'Standard processing completed' : null, customerNotes: randomBoolean(0.2) ? 'Please handle with care' : null, specialInstructions: item.specialInstructions, isFragile: item.isFragile, isHighValue: item.isHighValue, requiresAdultSignature: randomBoolean(0.1), isRestricted: randomBoolean(0.05), processedBy: null, // Will be staff user ID processedAt: randomBoolean(0.7) ? randomPastDate(10) : null, customsDeclaration: randomBoolean(0.6) ? 'Personal use items, no commercial value' : null, customsValue: randomDecimal(10, 500), customsValueCurrency: 'USD', countryOfOrigin: randomChoice(['US', 'CN', 'DE', 'JP', 'UK']), hsCode: randomBoolean(0.4) ? `${randomInt(1000, 9999)}.${randomInt(10, 99)}.${randomInt(10, 99)}` : null }; packageData.push(packageRecord); } // Insert packages const insertedPackages = await db.insert(packages).values(packageData).returning(); // Create package status history for (const packageRecord of insertedPackages) { // Create initial status entry const initialStatus = { packageId: packageRecord.id, status: 'expected', previousStatus: null, notes: 'Package created from incoming shipment', changedBy: null, // Will be system or staff user ID changeReason: 'initial_creation', locationId: null, metadata: JSON.stringify({ source: 'incoming_shipment' }) }; packageStatusHistoryData.push(initialStatus); // Add additional status changes for some packages if (packageRecord.status !== 'expected') { const statuses = ['expected', 'received', 'processing', 'ready_to_ship']; const currentStatusIndex = statuses.indexOf(packageRecord.status); for (let i = 1; i <= currentStatusIndex; i++) { const statusChange = { packageId: packageRecord.id, status: statuses[i], previousStatus: statuses[i - 1], notes: `Package status updated to ${statuses[i]}`, changedBy: null, // Will be staff user ID changeReason: 'workflow_progression', locationId: null, metadata: JSON.stringify({ automated: false }) }; packageStatusHistoryData.push(statusChange); } } } // Insert package status history await db.insert(packageStatusHistory).values(packageStatusHistoryData); // Create bin assignments for received packages const receivedPackages = insertedPackages.filter(p => ['received', 'processing', 'ready_to_ship'].includes(p.status) ); for (const packageRecord of receivedPackages) { // Get bin locations for this warehouse const warehouseBins = binLocations.filter(bin => bin.warehouseId === packageRecord.warehouseId && bin.isActive ); if (warehouseBins.length > 0) { const selectedBin = randomChoice(warehouseBins); const binAssignment = { packageId: packageRecord.id, binId: selectedBin.id, assignedAt: randomPastDate(10), assignedBy: null, // Will be staff user ID removedAt: null, removedBy: null, assignmentReason: 'initial_placement', removalReason: null, notes: `Package assigned to ${selectedBin.binCode}` }; packageBinAssignmentData.push(binAssignment); } } // Insert bin assignments const insertedBinAssignments = await db.insert(packageBinAssignments).values(packageBinAssignmentData).returning(); logSeedSuccess(`Created ${insertedIncomingShipments.length} incoming shipments, ${insertedIncomingShipmentItems.length} incoming items, ${insertedPackages.length} packages, ${packageStatusHistoryData.length} status history records, and ${insertedBinAssignments.length} bin assignments`); return { incomingShipments: insertedIncomingShipments, incomingShipmentItems: insertedIncomingShipmentItems, packages: insertedPackages, binAssignments: insertedBinAssignments }; }
```

# lib\db\seed\seed-finance.ts

```ts
// lib/db/seed/seed-finance.ts import { db } from '../index'; import { invoices, invoiceLines, personalShopperRequests, personalShopperRequestItems, personalShopperRequestStatusHistory } from '@/features/finance/db/schema'; import { type CustomerProfile } from '@/features/customers/db/schema'; import { type Shipment } from '@/features/shipping/db/schema'; import { logSeedProgress, logSeedSuccess, generateInvoiceNumber, generateRequestNumber, randomChoice, randomDecimal, randomInt, randomBoolean, randomPastDate, randomFutureDate, invoiceStatuses } from './utils'; export async function seedFinance(customerProfiles: CustomerProfile[], shipments: Shipment[]) { logSeedProgress('Seeding invoices and personal shopper requests...'); const invoiceData = []; const invoiceLineData = []; const personalShopperRequestData = []; const personalShopperRequestItemData = []; const personalShopperRequestStatusHistoryData = []; // Create invoices for shipments for (const shipment of shipments) { // Create shipping invoice const shippingInvoice = { tenantId: shipment.tenantId, customerProfileId: shipment.customerProfileId, invoiceNumber: generateInvoiceNumber(), invoiceType: 'shipping', shipmentId: shipment.id, personalShopperRequestId: null, subtotal: shipment.shippingCost || randomDecimal(20, 100), taxAmount: randomDecimal(0, 15), discountAmount: randomBoolean(0.2) ? randomDecimal(5, 20) : '0.00', totalAmount: randomDecimal(25, 150), currencyCode: 'USD', paymentStatus: randomChoice(invoiceStatuses), paidAmount: randomBoolean(0.7) ? randomDecimal(25, 150) : '0.00', paymentMethod: randomBoolean(0.7) ? randomChoice(['credit_card', 'paypal', 'bank_transfer', 'stripe']) : null, paymentReference: randomBoolean(0.7) ? `PAY_${Math.random().toString(36).substring(2, 15).toUpperCase()}` : null, paidAt: randomBoolean(0.7) ? randomPastDate(15) : null, issuedAt: randomPastDate(20), dueDate: randomFutureDate(30), notes: randomBoolean(0.3) ? 'Standard shipping charges' : null, paymentTerms: 'Payment due within 30 days' }; invoiceData.push(shippingInvoice); // Add storage invoice for some customers if (randomBoolean(0.4)) { const storageInvoice = { tenantId: shipment.tenantId, customerProfileId: shipment.customerProfileId, invoiceNumber: generateInvoiceNumber(), invoiceType: 'storage', shipmentId: null, personalShopperRequestId: null, subtotal: randomDecimal(10, 50), taxAmount: randomDecimal(0, 5), discountAmount: '0.00', totalAmount: randomDecimal(10, 55), currencyCode: 'USD', paymentStatus: randomChoice(invoiceStatuses), paidAmount: randomBoolean(0.8) ? randomDecimal(10, 55) : '0.00', paymentMethod: randomBoolean(0.8) ? randomChoice(['credit_card', 'paypal', 'auto_pay']) : null, paymentReference: randomBoolean(0.8) ? `PAY_${Math.random().toString(36).substring(2, 15).toUpperCase()}` : null, paidAt: randomBoolean(0.8) ? randomPastDate(10) : null, issuedAt: randomPastDate(15), dueDate: randomFutureDate(30), notes: 'Monthly storage fees', paymentTerms: 'Payment due within 30 days' }; invoiceData.push(storageInvoice); } } // Insert invoices const insertedInvoices = await db.insert(invoices).values(invoiceData).returning(); // Create invoice lines for each invoice for (const invoice of insertedInvoices) { if (invoice.invoiceType === 'shipping') { const lines = [ { invoiceId: invoice.id, description: 'Shipping Fee - Standard Delivery', quantity: '1.000', unitPrice: randomDecimal(15, 75), lineTotal: randomDecimal(15, 75), taxRate: '0.0875', // 8.75% tax taxAmount: randomDecimal(1, 7), referenceType: 'shipment', referenceId: invoice.shipmentId, sortOrder: 1 } ]; if (randomBoolean(0.3)) { lines.push({ invoiceId: invoice.id, description: 'Insurance Fee', quantity: '1.000', unitPrice: randomDecimal(5, 15), lineTotal: randomDecimal(5, 15), taxRate: '0.0875', taxAmount: randomDecimal(0.5, 1.5), referenceType: 'insurance', referenceId: null, sortOrder: 2 }); } if (randomBoolean(0.4)) { lines.push({ invoiceId: invoice.id, description: 'Handling Fee', quantity: '1.000', unitPrice: randomDecimal(3, 8), lineTotal: randomDecimal(3, 8), taxRate: '0.0875', taxAmount: randomDecimal(0.3, 0.8), referenceType: 'handling', referenceId: null, sortOrder: 3 }); } invoiceLineData.push(...lines); } else if (invoice.invoiceType === 'storage') { const storageDays = randomInt(1, 30); const lines = [ { invoiceId: invoice.id, description: `Storage Fee - ${storageDays} days`, quantity: storageDays.toString(), unitPrice: randomDecimal(1, 3), lineTotal: randomDecimal(10, 50), taxRate: '0.0875', taxAmount: randomDecimal(1, 5), referenceType: 'storage', referenceId: null, sortOrder: 1 } ]; invoiceLineData.push(...lines); } } await db.insert(invoiceLines).values(invoiceLineData); // Create personal shopper requests for (const customer of customerProfiles) { // 20% of customers have personal shopper requests if (randomBoolean(0.2)) { const requestCount = randomInt(1, 3); for (let i = 0; i < requestCount; i++) { const status = randomChoice(['draft', 'submitted', 'quoted', 'approved', 'purchasing', 'purchased', 'received', 'completed']); const request = { tenantId: customer.tenantId, customerProfileId: customer.id, requestNumber: generateRequestNumber(), status: status, shippingOption: randomChoice(['First Class', 'Priority', 'Express', 'FREE Super Saver']), shippingPreference: randomChoice(['send_together', 'send_as_available', 'send_by_category', 'fastest_delivery']), allowAlternateRetailers: randomBoolean(0.8), estimatedCost: randomDecimal(50, 500), actualCost: ['purchased', 'received', 'completed'].includes(status) ? randomDecimal(45, 520) : '0.00', serviceFee: randomDecimal(5, 25), totalAmount: randomDecimal(55, 545), currencyCode: 'USD', quotedAt: ['quoted', 'approved', 'purchasing', 'purchased', 'received', 'completed'].includes(status) ? randomPastDate(20) : null, quotedBy: null, // Will be staff user ID approvedAt: ['approved', 'purchasing', 'purchased', 'received', 'completed'].includes(status) ? randomPastDate(15) : null, purchasedAt: ['purchased', 'received', 'completed'].includes(status) ? randomPastDate(10) : null, purchasedBy: null, // Will be staff user ID specialInstructions: randomBoolean(0.4) ? 'Please ensure items are authentic and in good condition' : null, internalNotes: randomBoolean(0.2) ? 'VIP customer - prioritize this request' : null }; personalShopperRequestData.push(request); } } } // Insert personal shopper requests const insertedPersonalShopperRequests = await db.insert(personalShopperRequests).values(personalShopperRequestData).returning(); // Create personal shopper request items const sampleItems = [ { name: 'iPhone 15 Pro', url: 'https://apple.com/iphone-15-pro', price: '999.00' }, { name: 'Nike Air Jordan 1', url: 'https://nike.com/air-jordan-1', price: '170.00' }, { name: 'MacBook Pro 14"', url: 'https://apple.com/macbook-pro-14', price: '1999.00' }, { name: 'Sony WH-1000XM5', url: 'https://sony.com/headphones', price: '399.00' }, { name: 'Patagonia Jacket', url: 'https://patagonia.com/jacket', price: '199.00' }, { name: 'Vitamix Blender', url: 'https://vitamix.com/blender', price: '449.00' }, { name: 'iPad Pro 12.9"', url: 'https://apple.com/ipad-pro', price: '1099.00' }, { name: 'Levi\'s 501 Jeans', url: 'https://levis.com/501-jeans', price: '79.00' } ]; for (const request of insertedPersonalShopperRequests) { const itemCount = randomInt(1, 5); for (let i = 0; i < itemCount; i++) { const sampleItem = randomChoice(sampleItems); const item = { personalShopperRequestId: request.id, name: sampleItem.name, url: sampleItem.url, description: `${sampleItem.name} - Premium quality item`, size: randomBoolean(0.6) ? randomChoice(['S', 'M', 'L', 'XL', '8', '9', '10', '11']) : null, color: randomBoolean(0.7) ? randomChoice(['Black', 'White', 'Blue', 'Red', 'Navy', 'Gray']) : null, variant: randomBoolean(0.3) ? randomChoice(['128GB', '256GB', '512GB', 'Standard', 'Pro']) : null, quantity: randomInt(1, 3).toString(), maxBudgetPerItem: randomDecimal(50, 1200), actualPrice: ['purchased', 'received', 'completed'].includes(request.status) ? sampleItem.price : null, totalItemCost: ['purchased', 'received', 'completed'].includes(request.status) ? (parseFloat(sampleItem.price) * randomInt(1, 3)).toFixed(2) : null, additionalInstructions: randomBoolean(0.3) ? 'Please verify authenticity before purchase' : null, retailerName: ['purchased', 'received', 'completed'].includes(request.status) ? randomChoice(['Amazon', 'Best Buy', 'Target', 'Apple Store', 'Nike.com']) : null, retailerOrderNumber: ['purchased', 'received', 'completed'].includes(request.status) ? `ORD-${Math.random().toString(36).substring(2, 15).toUpperCase()}` : null, purchasedAt: ['purchased', 'received', 'completed'].includes(request.status) ? randomPastDate(10) : null, retailerTrackingNumber: ['received', 'completed'].includes(request.status) ? `TRK${Math.random().toString(36).substring(2, 12).toUpperCase()}` : null, packageId: null, // Will be linked when package is received status: randomChoice(['pending', 'purchased', 'received', 'cancelled']), sortOrder: i.toString() }; personalShopperRequestItemData.push(item); } } await db.insert(personalShopperRequestItems).values(personalShopperRequestItemData); // Create personal shopper request status history for (const request of insertedPersonalShopperRequests) { // Initial status const initialStatus = { personalShopperRequestId: request.id, status: 'draft', notes: 'Personal shopper request created', changedBy: null, // Will be customer user ID changeReason: 'initial_creation' }; personalShopperRequestStatusHistoryData.push(initialStatus); // Add status progression const statusProgression = ['draft', 'submitted', 'quoted', 'approved', 'purchasing', 'purchased', 'received', 'completed']; const currentStatusIndex = statusProgression.indexOf(request.status); for (let i = 1; i <= currentStatusIndex; i++) { const statusChange = { personalShopperRequestId: request.id, status: statusProgression[i], notes: `Status updated to ${statusProgression[i]}`, changedBy: null, // Will be staff user ID changeReason: 'workflow_progression' }; personalShopperRequestStatusHistoryData.push(statusChange); } } await db.insert(personalShopperRequestStatusHistory).values(personalShopperRequestStatusHistoryData); // Create invoices for completed personal shopper requests const completedRequests = insertedPersonalShopperRequests.filter(r => ['completed', 'purchased'].includes(r.status) ); for (const request of completedRequests) { const personalShopperInvoice = { tenantId: request.tenantId, customerProfileId: request.customerProfileId, invoiceNumber: generateInvoiceNumber(), invoiceType: 'personal_shopper', shipmentId: null, personalShopperRequestId: request.id, subtotal: request.actualCost, taxAmount: randomDecimal(0, 20), discountAmount: '0.00', totalAmount: request.totalAmount, currencyCode: request.currencyCode, paymentStatus: randomChoice(['paid', 'pending', 'partially_paid']), paidAmount: randomBoolean(0.8) ? request.totalAmount : randomDecimal(0, parseFloat(request.totalAmount)), paymentMethod: randomChoice(['credit_card', 'paypal', 'bank_transfer']), paymentReference: `PS_PAY_${Math.random().toString(36).substring(2, 15).toUpperCase()}`, paidAt: randomBoolean(0.8) ? randomPastDate(5) : null, issuedAt: randomPastDate(10), dueDate: randomFutureDate(30), notes: 'Personal shopping service charges', paymentTerms: 'Payment due within 30 days' }; const [insertedPSInvoice] = await db.insert(invoices).values([personalShopperInvoice]).returning(); // Add invoice lines for personal shopper invoice const psInvoiceLines = [ { invoiceId: insertedPSInvoice.id, description: 'Personal Shopping Service Fee', quantity: '1.000', unitPrice: request.serviceFee, lineTotal: request.serviceFee, taxRate: '0.0875', taxAmount: (parseFloat(request.serviceFee) * 0.0875).toFixed(2), referenceType: 'personal_shopper', referenceId: request.id, sortOrder: 1 }, { invoiceId: insertedPSInvoice.id, description: 'Items Purchased', quantity: '1.000', unitPrice: request.actualCost, lineTotal: request.actualCost, taxRate: '0.0000', // No tax on item cost taxAmount: '0.00', referenceType: 'personal_shopper_items', referenceId: request.id, sortOrder: 2 } ]; await db.insert(invoiceLines).values(psInvoiceLines); } logSeedSuccess(`Created ${insertedInvoices.length} invoices, ${invoiceLineData.length} invoice lines, ${insertedPersonalShopperRequests.length} personal shopper requests, ${personalShopperRequestItemData.length} request items, and ${personalShopperRequestStatusHistoryData.length} status history records`); return { invoices: insertedInvoices, personalShopperRequests: insertedPersonalShopperRequests }; }
```

# lib\db\seed\seed-customers.ts

```ts
// lib/db/seed/seed-customers.ts import { db } from '../index'; import { customerProfiles, companies } from '@/features/customers/db/schema'; import { type User } from '@/features/auth/db/schema'; import { logSeedProgress, logSeedSuccess, generateCustomerId, randomChoice, randomDecimal, randomInt, randomBoolean, randomPastDate, sampleCompanies } from './utils'; export async function seedCustomers(users: User[]) { logSeedProgress('Seeding customer profiles and companies...'); // Get only customer users const customerUsers = users.filter(user => user.userType === 'customer'); const customerProfileData = []; const companyData = []; for (const user of customerUsers) { const profile = { userId: user.id, tenantId: user.tenantId, customerId: generateCustomerId(), // Personal details dateOfBirth: randomPastDate(365 * 40), // Random age between 18-58 nationality: randomChoice(['US', 'CA', 'UK', 'AU', 'DE', 'FR']), idNumber: `ID${Math.random().toString().slice(2, 11)}`, // KYC/Compliance kycStatus: randomChoice(['not_required', 'pending', 'approved']), kycDocuments: [], kycNotes: randomBoolean(0.3) ? 'Standard verification completed' : null, kycVerifiedAt: randomBoolean(0.7) ? randomPastDate(30) : null, // Risk assessment riskLevel: randomChoice(['low', 'medium', 'high']), riskNotes: randomBoolean(0.2) ? 'Regular customer, low risk profile' : null, lastRiskAssessment: randomPastDate(90), // Customer lifetime value tracking totalSpent: randomDecimal(0, 5000), totalPackages: randomInt(0, 50), totalShipments: randomInt(0, 20), averagePackageValue: randomDecimal(50, 500), // Subscription & Billing stripeCustomerId: `cus_${Math.random().toString(36).substring(2, 15)}`, stripeSubscriptionId: randomBoolean(0.6) ? `sub_${Math.random().toString(36).substring(2, 15)}` : null, stripeProductId: randomBoolean(0.6) ? `prod_${Math.random().toString(36).substring(2, 15)}` : null, planName: randomChoice(['basic', 'premium', 'enterprise']), planFeatures: { maxPackagesPerMonth: randomChoice([10, 25, 100]), freeStorageDays: randomChoice([7, 14, 30]), personalShopper: randomBoolean(0.4), consolidation: randomBoolean(0.7) }, subscriptionStatus: randomChoice(['active', 'inactive', 'trial']), subscriptionStartedAt: randomBoolean(0.8) ? randomPastDate(365) : null, subscriptionEndsAt: randomBoolean(0.8) ? new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) : null, // Referral system referralCode: `REF${Math.random().toString(36).substring(2, 8).toUpperCase()}`, referralReward: randomDecimal(0, 100), totalReferrals: randomInt(0, 5), // Preferences preferredCurrency: randomChoice(['USD', 'EUR', 'GBP', 'CAD']), communicationPreferences: { email: randomBoolean(0.9), sms: randomBoolean(0.6), push: randomBoolean(0.7), newsletter: randomBoolean(0.4) }, shippingPreferences: { defaultServiceType: randomChoice(['standard', 'express', 'economy']), consolidation: randomBoolean(0.6), insurance: randomBoolean(0.3) }, // Customer service customerServiceNotes: randomBoolean(0.2) ? 'VIP customer, prioritize requests' : null, isVip: randomBoolean(0.1), vipSince: randomBoolean(0.1) ? randomPastDate(365) : null, // Account status accountStatus: randomChoice(['active', 'suspended', 'closed']), suspensionReason: null, suspendedAt: null, suspendedBy: null, // Marketing marketingOptIn: randomBoolean(0.7), smsOptIn: randomBoolean(0.4), emailOptIn: randomBoolean(0.8), }; customerProfileData.push(profile); // Create companies for some business customers if (randomBoolean(0.3)) { // 30% of customers have companies const company = { tenantId: user.tenantId, ownerId: '', // Will be set after customer profiles are inserted // Company details name: randomChoice(sampleCompanies), legalName: null, registrationNumber: `REG${Math.random().toString().slice(2, 11)}`, taxNumber: `TAX${Math.random().toString().slice(2, 11)}`, taxNumberType: randomChoice(['EIN', 'VAT', 'GST']), vatNumber: randomBoolean(0.5) ? `VAT${Math.random().toString().slice(2, 11)}` : null, // Business information companyType: randomChoice(['LLC', 'Corp', 'Ltd', 'Partnership']), industry: randomChoice(['Technology', 'Retail', 'Manufacturing', 'Services', 'Healthcare']), businessDescription: 'Online retail business specializing in imported goods', yearEstablished: randomInt(1990, 2020), numberOfEmployees: randomChoice(['1-10', '11-50', '51-200', '201-500']), annualRevenue: randomChoice(['<$100K', '$100K-$1M', '$1M-$10M', '>$10M']), // Contact details website: `www.${randomChoice(sampleCompanies).toLowerCase().replace(/\s+/g, '')}.com`, primaryContactName: `${user.firstName} ${user.lastName}`, primaryContactTitle: randomChoice(['CEO', 'Owner', 'Manager', 'Director']), primaryContactEmail: user.email, primaryContactPhone: `+1${Math.random().toString().slice(2, 12)}`, // Legal and compliance verificationStatus: randomChoice(['unverified', 'pending', 'verified']), verificationDocuments: [], verifiedAt: randomBoolean(0.5) ? randomPastDate(60) : null, verifiedBy: null, verificationNotes: null, // Business settings showInAddress: randomBoolean(0.8), useForCustoms: randomBoolean(0.7), customsExporterNumber: randomBoolean(0.4) ? `EXP${Math.random().toString().slice(2, 11)}` : null, // Financial creditLimit: randomDecimal(1000, 50000), creditTerms: randomChoice(['net_15', 'net_30', 'net_60']), paymentTerms: randomChoice(['net_30', 'net_15', 'immediate']), // Account management accountManagerId: null, // Could be assigned later isActive: randomBoolean(0.95), }; companyData.push(company); } } // Insert customer profiles const insertedProfiles = await db.insert(customerProfiles).values(customerProfileData).returning(); // Update company data with customer profile IDs and insert if (companyData.length > 0) { const updatedCompanyData = companyData.map((company, index) => ({ ...company, ownerId: insertedProfiles[index].id // Match by index for now })); const insertedCompanies = await db.insert(companies).values(updatedCompanyData).returning(); logSeedSuccess(`Created ${insertedProfiles.length} customer profiles and ${insertedCompanies.length} companies`); return { customerProfiles: insertedProfiles, companies: insertedCompanies }; } logSeedSuccess(`Created ${insertedProfiles.length} customer profiles`); return insertedProfiles; }
```

# lib\db\seed\seed-audit.ts

```ts
// lib/db/seed/seed-audit.ts import { db } from '../index'; import { activityLogs, notifications, notificationTemplates, complianceEvents } from '@/features/audit/db/schema'; import { type User } from '@/features/auth/db/schema'; import { type CustomerProfile } from '@/features/customers/db/schema'; import { type Package } from '@/features/packages/db/schema'; import { type Shipment } from '@/features/shipping/db/schema'; import { logSeedProgress, logSeedSuccess, randomChoice, randomBoolean, randomPastDate, randomFutureDate } from './utils'; export async function seedAudit( users: User[], customerProfiles: CustomerProfile[], packages: Package[], shipments: Shipment[] ) { logSeedProgress('Seeding activity logs, notifications, and compliance events...'); const activityLogData = []; const notificationData = []; const notificationTemplateData = []; const complianceEventData = []; // Create notification templates for each tenant const tenantIds = [...new Set(users.map(u => u.tenantId))]; for (const tenantId of tenantIds) { const templates = [ { tenantId, name: 'Package Received', code: 'package_received', notificationType: 'package_received', title: 'Package Received - {{trackingNumber}}', messageTemplate: 'Your package {{trackingNumber}} has been received at our {{warehouseName}} facility and is being processed.', emailSubjectTemplate: 'Package Received - {{trackingNumber}}', emailBodyTemplate: ` <h2>Package Received</h2> <p>Dear {{customerName}},</p> <p>Your package with tracking number <strong>{{trackingNumber}}</strong> has been received at our {{warehouseName}} facility.</p> <p><strong>Package Details:</strong></p> <ul> <li>Tracking Number: {{trackingNumber}}</li> <li>Description: {{description}}</li> <li>Weight: {{weight}}kg</li> <li>Estimated Value: ${{estimatedValue}}</li> </ul> <p>Your package is now being processed and will be ready for shipping soon.</p> <p>Best regards,<br>{{companyName}}</p> `, smsTemplate: 'Package {{trackingNumber}} received at {{warehouseName}}. Processing now.', pushTemplate: 'Package {{trackingNumber}} received and processing', availableVariables: ['trackingNumber', 'customerName', 'warehouseName', 'description', 'weight', 'estimatedValue', 'companyName'], isActive: true, isDefault: true, language: 'en' }, { tenantId, name: 'Shipment Dispatched', code: 'shipment_dispatched', notificationType: 'package_shipped', title: 'Shipment Dispatched - {{shipmentNumber}}', messageTemplate: 'Your shipment {{shipmentNumber}} has been dispatched via {{carrierName}} with tracking number {{trackingNumber}}.', emailSubjectTemplate: 'Your Shipment is On Its Way - {{shipmentNumber}}', emailBodyTemplate: ` <h2>Shipment Dispatched</h2> <p>Dear {{customerName}},</p> <p>Great news! Your shipment <strong>{{shipmentNumber}}</strong> has been dispatched and is on its way to you.</p> <p><strong>Shipping Details:</strong></p> <ul> <li>Shipment Number: {{shipmentNumber}}</li> <li>Carrier: {{carrierName}}</li> <li>Tracking Number: {{trackingNumber}}</li> <li>Service Type: {{serviceType}}</li> <li>Estimated Delivery: {{estimatedDelivery}}</li> </ul> <p>You can track your shipment using the tracking number provided.</p> <p>Best regards,<br>{{companyName}}</p> `, smsTemplate: 'Shipment {{shipmentNumber}} dispatched via {{carrierName}}. Track: {{trackingNumber}}', pushTemplate: 'Shipment {{shipmentNumber}} is on its way!', availableVariables: ['shipmentNumber', 'customerName', 'carrierName', 'trackingNumber', 'serviceType', 'estimatedDelivery', 'companyName'], isActive: true, isDefault: true, language: 'en' }, { tenantId, name: 'Storage Reminder', code: 'storage_reminder', notificationType: 'storage_reminder', title: 'Storage Reminder - {{daysRemaining}} Days Left', messageTemplate: 'Your package {{trackingNumber}} has {{daysRemaining}} days of free storage remaining. Please arrange shipping soon.', emailSubjectTemplate: 'Storage Reminder - {{daysRemaining}} Days of Free Storage Left', emailBodyTemplate: ` <h2>Storage Reminder</h2> <p>Dear {{customerName}},</p> <p>This is a friendly reminder that your package with tracking number <strong>{{trackingNumber}}</strong> has {{daysRemaining}} days of free storage remaining.</p> <p><strong>Package Details:</strong></p> <ul> <li>Tracking Number: {{trackingNumber}}</li> <li>Days Remaining: {{daysRemaining}}</li> <li>Storage Expires: {{storageExpiresDate}}</li> <li>Daily Fee After Expiry: ${{dailyStorageFee}}</li> </ul> <p>Please log in to your account to arrange shipping for this package.</p> <p>Best regards,<br>{{companyName}}</p> `, smsTemplate: 'Package {{trackingNumber}} - {{daysRemaining}} days free storage left', pushTemplate: '{{daysRemaining}} days of free storage left for package {{trackingNumber}}', availableVariables: ['trackingNumber', 'customerName', 'daysRemaining', 'storageExpiresDate', 'dailyStorageFee', 'companyName'], isActive: true, isDefault: true, language: 'en' }, { tenantId, name: 'Payment Due', code: 'payment_due', notificationType: 'payment_due', title: 'Payment Due - Invoice {{invoiceNumber}}', messageTemplate: 'Invoice {{invoiceNumber}} for ${{amount}} is due on {{dueDate}}. Please make payment to avoid service interruption.', emailSubjectTemplate: 'Payment Due - Invoice {{invoiceNumber}}', emailBodyTemplate: ` <h2>Payment Due</h2> <p>Dear {{customerName}},</p> <p>This is a reminder that invoice <strong>{{invoiceNumber}}</strong> is due for payment.</p> <p><strong>Invoice Details:</strong></p> <ul> <li>Invoice Number: {{invoiceNumber}}</li> <li>Amount Due: ${{amount}}</li> <li>Due Date: {{dueDate}}</li> <li>Services: {{services}}</li> </ul> <p>Please log in to your account to make payment or contact us if you have any questions.</p> <p>Best regards,<br>{{companyName}}</p> `, smsTemplate: 'Invoice {{invoiceNumber}} for ${{amount}} due {{dueDate}}', pushTemplate: 'Payment due: Invoice {{invoiceNumber}} - ${{amount}}', availableVariables: ['invoiceNumber', 'customerName', 'amount', 'dueDate', 'services', 'companyName'], isActive: true, isDefault: true, language: 'en' } ]; notificationTemplateData.push(...templates); } await db.insert(notificationTemplates).values(notificationTemplateData); // Create activity logs for various user actions const activityTypes = [ { action: 'login', resourceType: 'user', description: 'User logged in' }, { action: 'logout', resourceType: 'user', description: 'User logged out' }, { action: 'view', resourceType: 'package', description: 'Viewed package details' }, { action: 'create', resourceType: 'package', description: 'Created new package' }, { action: 'update', resourceType: 'package', description: 'Updated package information' }, { action: 'process', resourceType: 'package', description: 'Processed package' }, { action: 'ship', resourceType: 'shipment', description: 'Created new shipment' }, { action: 'view', resourceType: 'shipment', description: 'Viewed shipment details' }, { action: 'update', resourceType: 'customer', description: 'Updated customer profile' }, { action: 'payment_received', resourceType: 'invoice', description: 'Payment received for invoice' } ]; for (const user of users) { // Create 5-15 activity logs per user const logCount = Math.floor(Math.random() * 10) + 5; for (let i = 0; i < logCount; i++) { const activity = randomChoice(activityTypes); const customer = customerProfiles.find(cp => cp.tenantId === user.tenantId); let resourceId = null; if (activity.resourceType === 'package' && packages.length > 0) { resourceId = randomChoice(packages.filter(p => p.tenantId === user.tenantId))?.id; } else if (activity.resourceType === 'shipment' && shipments.length > 0) { resourceId = randomChoice(shipments.filter(s => s.tenantId === user.tenantId))?.id; } const log = { tenantId: user.tenantId, userId: user.id, customerProfileId: user.userType === 'customer' ? customer?.id : null, action: activity.action, resourceType: activity.resourceType, resourceId: resourceId, description: activity.description, metadata: { userAgent: randomChoice([ 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36' ]), action: activity.action, timestamp: randomPastDate(60).toISOString() }, ipAddress: `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`, userAgent: randomChoice([ 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36' ]), previousValues: activity.action === 'update' ? { status: 'old_value' } : null, newValues: activity.action === 'update' ? { status: 'new_value' } : null, sessionId: `sess_${Math.random().toString(36).substring(2, 15)}`, requestId: `req_${Math.random().toString(36).substring(2, 15)}`, severity: randomChoice(['debug', 'info', 'warn']), tags: [activity.resourceType, activity.action] }; activityLogData.push(log); } } await db.insert(activityLogs).values(activityLogData); // Create notifications for customers const notificationTypes = ['package_received', 'package_shipped', 'storage_reminder', 'payment_due', 'system_announcement']; for (const customer of customerProfiles) { // Create 3-8 notifications per customer const notificationCount = Math.floor(Math.random() * 5) + 3; for (let i = 0; i < notificationCount; i++) { const notificationType = randomChoice(notificationTypes); const relatedPackage = packages.find(p => p.customerProfileId === customer.id); const relatedShipment = shipments.find(s => s.customerProfileId === customer.id); const notification = { tenantId: customer.tenantId, userId: null, customerProfileId: customer.id, title: `${notificationType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())} Notification`, message: `This is a ${notificationType} notification for customer ${customer.customerId}`, notificationType: notificationType, status: randomChoice(['pending', 'sent', 'delivered', 'unread']), priority: randomChoice(['low', 'normal', 'high']), referenceType: relatedPackage ? 'package' : relatedShipment ? 'shipment' : null, referenceId: relatedPackage?.id || relatedShipment?.id || null, channels: ['in_app', 'email'], sentViaEmail: randomBoolean(0.8), sentViaSms: randomBoolean(0.3), sentViaPush: randomBoolean(0.6), sentViaInApp: true, emailAddress: customer.user?.email, emailSubject: `Package Forward Notification - ${notificationType}`, phoneNumber: customer.user?.phone, pushDeviceTokens: [], readAt: randomBoolean(0.6) ? randomPastDate(10) : null, clickedAt: randomBoolean(0.3) ? randomPastDate(5) : null, dismissedAt: randomBoolean(0.2) ? randomPastDate(3) : null, emailDeliveredAt: randomBoolean(0.8) ? randomPastDate(8) : null, retryCount: '0', maxRetries: '3', metadata: { templateUsed: notificationType, variables: { customerName: `${customer.user?.firstName} ${customer.user?.lastName}`, customerId: customer.customerId } }, expiresAt: randomFutureDate(30), groupId: null }; notificationData.push(notification); } } await db.insert(notifications).values(notificationData); // Create compliance events const complianceEventTypes = [ { type: 'data_access', category: 'privacy', regulation: 'GDPR' }, { type: 'data_export', category: 'privacy', regulation: 'GDPR' }, { type: 'data_deletion', category: 'privacy', regulation: 'GDPR' }, { type: 'payment_processing', category: 'financial', regulation: 'PCI_DSS' }, { type: 'identity_verification', category: 'kyc', regulation: 'AML' }, { type: 'customs_declaration', category: 'trade', regulation: 'CBP' } ]; for (const customer of customerProfiles) { // Create 1-3 compliance events per customer const eventCount = Math.floor(Math.random() * 2) + 1; for (let i = 0; i < eventCount; i++) { const eventType = randomChoice(complianceEventTypes); const complianceEvent = { tenantId: customer.tenantId, eventType: eventType.type, eventCategory: eventType.category, userId: null, customerProfileId: customer.id, resourceType: 'customer_profile', resourceId: customer.id, regulationType: eventType.regulation, complianceStatus: randomChoice(['compliant', 'non_compliant', 'pending']), eventData: { action: eventType.type, timestamp: randomPastDate(90).toISOString(), details: `${eventType.type} event for customer ${customer.customerId}` }, evidence: { documentation: `Evidence for ${eventType.type}`, approvals: ['system_approved'], timestamps: [randomPastDate(90).toISOString()] }, riskLevel: randomChoice(['low', 'medium', 'high']), resolvedAt: randomBoolean(0.7) ? randomPastDate(30) : null, resolvedBy: null, // Will be staff user ID resolutionNotes: randomBoolean(0.7) ? `${eventType.type} compliance verified and resolved` : null, retentionPeriod: '7_years' }; complianceEventData.push(complianceEvent); } } await db.insert(complianceEvents).values(complianceEventData); logSeedSuccess(`Created ${activityLogData.length} activity logs, ${notificationTemplateData.length} notification templates, ${notificationData.length} notifications, and ${complianceEventData.length} compliance events`); return { activityLogs: activityLogData.length, notificationTemplates: notificationTemplateData.length, notifications: notificationData.length, complianceEvents: complianceEventData.length }; }
```

# lib\db\seed\index.ts

```ts
import { seedCustomers } from './seed-customers'; import { seedPackages } from './seed-packages'; async function main() { console.log('🌱 Starting database seeding...'); try { console.log('🧹 Clearing existing data...'); // Seed customers first const seededCustomers = await seedCustomers(); // Then seed packages with customer references const seededPackages = await seedPackages(seededCustomers); console.log('🎉 Database seeding completed successfully!'); console.log('\n📊 Seeded data summary:'); console.log(`- Customers: ${seededCustomers.length}`); console.log(`- Packages: ${seededPackages.length}`); // Display seeded data for verification console.log('\n👥 Customers:'); seededCustomers.forEach((customer, index) => { console.log(` ${index + 1}. ${customer.name} (${customer.email}) - ${customer.status}`); }); console.log('\n📦 Packages:'); seededPackages.forEach((pkg, index) => { const customer = seededCustomers.find(c => c.id === pkg.customerId); console.log(` ${index + 1}. ${pkg.trackingNumber} - ${customer?.name} - ${pkg.status}`); }); return { customers: seededCustomers, packages: seededPackages }; } catch (error) { console.error('❌ Error seeding database:', error); throw error; } } // Run the seeder if this file is executed directly if (require.main === module) { main() .then(() => { console.log('✅ Seeding process completed'); process.exit(0); }) .catch((error) => { console.error('❌ Seeding process failed:', error); process.exit(1); }); } export { main as seedDatabase };
```

# lib\db\schema\relations.ts

```ts
// lib/db/schema/relations.ts import { relations } from 'drizzle-orm'; // Import all tables from feature schemas import { tenants, users, roles, permissions, rolePermissions, userRoles } from '@/features/auth/db/schema'; import { customerProfiles, companies } from '@/features/customers/db/schema'; import { warehouses, customerWarehouseAssignments, storagePricing, binLocations, packageBinAssignments, storageCharges } from '@/features/warehouses/db/schema'; import { packages, packageStatusHistory, incomingShipments, incomingShipmentItems } from '@/features/packages/db/schema'; import { zones, zoneCountries, shippingRates, shipments, shipmentPackages, shipmentTrackingEvents, shipmentStatusHistory } from '@/features/shipping/db/schema'; import { invoices, invoiceLines, personalShopperRequests, personalShopperRequestItems, personalShopperRequestStatusHistory } from '@/features/finance/db/schema'; import { countries, currencies, couriers, courierServices, tenantCurrencies, tenantCouriers } from '@/features/settings/db/schema'; import { documents, entityDocuments, addresses, entityAddresses } from '@/features/settings/db/schema'; import { activityLogs, notifications, notificationTemplates, complianceEvents } from '@/features/audit/db/schema'; // ============================================================================= // TENANT RELATIONS // ============================================================================= export const tenantsRelations = relations(tenants, ({ many }) => ({ users: many(users), roles: many(roles), customerProfiles: many(customerProfiles), warehouses: many(warehouses), zones: many(zones), shippingRates: many(shippingRates), shipments: many(shipments), packages: many(packages), invoices: many(invoices), personalShopperRequests: many(personalShopperRequests), storagePricing: many(storagePricing), binLocations: many(binLocations), storageCharges: many(storageCharges), incomingShipments: many(incomingShipments), incomingShipmentItems: many(incomingShipmentItems), tenantCurrencies: many(tenantCurrencies), tenantCouriers: many(tenantCouriers), documents: many(documents), addresses: many(addresses), activityLogs: many(activityLogs), notifications: many(notifications), notificationTemplates: many(notificationTemplates), complianceEvents: many(complianceEvents), companies: many(companies), })); // ============================================================================= // AUTH RELATIONS // ============================================================================= export const usersRelations = relations(users, ({ one, many }) => ({ tenant: one(tenants, { fields: [users.tenantId], references: [tenants.id], }), customerProfile: one(customerProfiles, { fields: [users.id], references: [customerProfiles.userId], }), userRoles: many(userRoles, { relationName: 'userRoleAssignments' }), roleAssignments: many(userRoles, { relationName: 'roleAssignments' }), kycVerifications: many(customerProfiles, { relationName: 'kycVerifications' }), warehouseAssignments: many(customerWarehouseAssignments, { relationName: 'warehouseAssignments' }), processedPackages: many(packages, { relationName: 'processedPackages' }), createdShipments: many(shipments, { relationName: 'createdShipments' }), processedShipments: many(shipments, { relationName: 'processedShipments' }), quotedPersonalShopperRequests: many(personalShopperRequests, { relationName: 'quotedRequests' }), purchasedPersonalShopperRequests: many(personalShopperRequests, { relationName: 'purchasedRequests' }), receivedIncomingShipments: many(incomingShipments, { relationName: 'receivedShipments' }), processedIncomingShipments: many(incomingShipments, { relationName: 'processedShipments' }), scannedItems: many(incomingShipmentItems, { relationName: 'scannedItems' }), assignedItems: many(incomingShipmentItems, { relationName: 'assignedItems' }), notifications: many(notifications), activityLogs: many(activityLogs), uploadedDocuments: many(documents, { relationName: 'uploadedDocuments' }), attachedDocuments: many(entityDocuments, { relationName: 'attachedDocuments' }), createdAddresses: many(addresses, { relationName: 'createdAddresses' }), assignedAddresses: many(entityAddresses, { relationName: 'assignedAddresses' }), companyVerifications: many(companies, { relationName: 'companyVerifications' }), suspendedCustomers: many(customerProfiles, { relationName: 'suspendedCustomers' }), accountManagers: many(companies, { relationName: 'accountManagers' }), statusChanges: many(packageStatusHistory, { relationName: 'statusChanges' }), shipmentStatusChanges: many(shipmentStatusHistory, { relationName: 'shipmentStatusChanges' }), personalShopperStatusChanges: many(personalShopperRequestStatusHistory, { relationName: 'personalShopperStatusChanges' }), })); export const rolesRelations = relations(roles, ({ one, many }) => ({ tenant: one(tenants, { fields: [roles.tenantId], references: [tenants.id], }), rolePermissions: many(rolePermissions), userRoles: many(userRoles), })); export const permissionsRelations = relations(permissions, ({ many }) => ({ rolePermissions: many(rolePermissions), })); export const rolePermissionsRelations = relations(rolePermissions, ({ one }) => ({ role: one(roles, { fields: [rolePermissions.roleId], references: [roles.id], }), permission: one(permissions, { fields: [rolePermissions.permissionId], references: [permissions.id], }), })); export const userRolesRelations = relations(userRoles, ({ one }) => ({ user: one(users, { fields: [userRoles.userId], references: [users.id], relationName: 'userRoleAssignments' }), role: one(roles, { fields: [userRoles.roleId], references: [roles.id], }), assignedByUser: one(users, { fields: [userRoles.assignedBy], references: [users.id], relationName: 'roleAssignments' }), })); // ============================================================================= // CUSTOMER RELATIONS // ============================================================================= export const customerProfilesRelations = relations(customerProfiles, ({ one, many }) => ({ user: one(users, { fields: [customerProfiles.userId], references: [users.id], }), tenant: one(tenants, { fields: [customerProfiles.tenantId], references: [tenants.id], }), kycVerifier: one(users, { fields: [customerProfiles.kycVerifiedBy], references: [users.id], relationName: 'kycVerifications' }), suspendedBy: one(users, { fields: [customerProfiles.suspendedBy], references: [users.id], relationName: 'suspendedCustomers' }), referrer: one(customerProfiles, { fields: [customerProfiles.referredBy], references: [customerProfiles.id], relationName: 'referrals' }), referrals: many(customerProfiles, { relationName: 'referrals' }), companies: many(companies), warehouseAssignments: many(customerWarehouseAssignments), packages: many(packages), shipments: many(shipments), invoices: many(invoices), personalShopperRequests: many(personalShopperRequests), assignedIncomingItems: many(incomingShipmentItems), notifications: many(notifications), activityLogs: many(activityLogs), complianceEvents: many(complianceEvents), })); export const companiesRelations = relations(companies, ({ one, many }) => ({ tenant: one(tenants, { fields: [companies.tenantId], references: [tenants.id], }), owner: one(customerProfiles, { fields: [companies.ownerId], references: [customerProfiles.id], }), verifiedBy: one(users, { fields: [companies.verifiedBy], references: [users.id], relationName: 'companyVerifications' }), accountManager: one(users, { fields: [companies.accountManagerId], references: [users.id], relationName: 'accountManagers' }), shipments: many(shipments), })); // ============================================================================= // WAREHOUSE RELATIONS // ============================================================================= export const warehousesRelations = relations(warehouses, ({ one, many }) => ({ tenant: one(tenants, { fields: [warehouses.tenantId], references: [tenants.id], }), customerAssignments: many(customerWarehouseAssignments), packages: many(packages), shipments: many(shipments), incomingShipments: many(incomingShipments), incomingShipmentItems: many(incomingShipmentItems), storagePricing: many(storagePricing), binLocations: many(binLocations), shippingRates: many(shippingRates), })); export const customerWarehouseAssignmentsRelations = relations(customerWarehouseAssignments, ({ one }) => ({ customerProfile: one(customerProfiles, { fields: [customerWarehouseAssignments.customerProfileId], references: [customerProfiles.id], }), warehouse: one(warehouses, { fields: [customerWarehouseAssignments.warehouseId], references: [warehouses.id], }), assignedBy: one(users, { fields: [customerWarehouseAssignments.assignedBy], references: [users.id], relationName: 'warehouseAssignments' }), })); export const storagePricingRelations = relations(storagePricing, ({ one }) => ({ tenant: one(tenants, { fields: [storagePricing.tenantId], references: [tenants.id], }), warehouse: one(warehouses, { fields: [storagePricing.warehouseId], references: [warehouses.id], }), })); export const binLocationsRelations = relations(binLocations, ({ one, many }) => ({ tenant: one(tenants, { fields: [binLocations.tenantId], references: [tenants.id], }), warehouse: one(warehouses, { fields: [binLocations.warehouseId], references: [warehouses.id], }), packageAssignments: many(packageBinAssignments), storageCharges: many(storageCharges), })); export const packageBinAssignmentsRelations = relations(packageBinAssignments, ({ one }) => ({ package: one(packages, { fields: [packageBinAssignments.packageId], references: [packages.id], }), binLocation: one(binLocations, { fields: [packageBinAssignments.binId], references: [binLocations.id], }), })); export const storageChargesRelations = relations(storageCharges, ({ one }) => ({ package: one(packages, { fields: [storageCharges.packageId], references: [packages.id], }), tenant: one(tenants, { fields: [storageCharges.tenantId], references: [tenants.id], }), binLocation: one(binLocations, { fields: [storageCharges.binLocationId], references: [binLocations.id], }), })); // ============================================================================= // PACKAGE RELATIONS // ============================================================================= export const packagesRelations = relations(packages, ({ one, many }) => ({ tenant: one(tenants, { fields: [packages.tenantId], references: [tenants.id], }), customerProfile: one(customerProfiles, { fields: [packages.customerProfileId], references: [customerProfiles.id], }), warehouse: one(warehouses, { fields: [packages.warehouseId], references: [warehouses.id], }), incomingShipmentItem: one(incomingShipmentItems, { fields: [packages.incomingShipmentItemId], references: [incomingShipmentItems.id], }), processedBy: one(users, { fields: [packages.processedBy], references: [users.id], relationName: 'processedPackages' }), statusHistory: many(packageStatusHistory), shipmentPackages: many(shipmentPackages), binAssignments: many(packageBinAssignments), storageCharges: many(storageCharges), personalShopperItems: many(personalShopperRequestItems), })); export const packageStatusHistoryRelations = relations(packageStatusHistory, ({ one }) => ({ package: one(packages, { fields: [packageStatusHistory.packageId], references: [packages.id], }), changedBy: one(users, { fields: [packageStatusHistory.changedBy], references: [users.id], relationName: 'statusChanges' }), })); export const incomingShipmentsRelations = relations(incomingShipments, ({ one, many }) => ({ tenant: one(tenants, { fields: [incomingShipments.tenantId], references: [tenants.id], }), warehouse: one(warehouses, { fields: [incomingShipments.warehouseId], references: [warehouses.id], }), courier: one(couriers, { fields: [incomingShipments.courierId], references: [couriers.id], }), receivedBy: one(users, { fields: [incomingShipments.receivedBy], references: [users.id], relationName: 'receivedShipments' }), processedBy: one(users, { fields: [incomingShipments.processedBy], references: [users.id], relationName: 'processedShipments' }), items: many(incomingShipmentItems), })); export const incomingShipmentItemsRelations = relations(incomingShipmentItems, ({ one, many }) => ({ tenant: one(tenants, { fields: [incomingShipmentItems.tenantId], references: [tenants.id], }), warehouse: one(warehouses, { fields: [incomingShipmentItems.warehouseId], references: [warehouses.id], }), incomingShipment: one(incomingShipments, { fields: [incomingShipmentItems.incomingShipmentId], references: [incomingShipments.id], }), scannedBy: one(users, { fields: [incomingShipmentItems.scannedBy], references: [users.id], relationName: 'scannedItems' }), assignedCustomer: one(customerProfiles, { fields: [incomingShipmentItems.assignedCustomerProfileId], references: [customerProfiles.id], }), assignedBy: one(users, { fields: [incomingShipmentItems.assignedBy], references: [users.id], relationName: 'assignedItems' }), packages: many(packages), })); // ============================================================================= // SHIPPING RELATIONS // ============================================================================= export const zonesRelations = relations(zones, ({ one, many }) => ({ tenant: one(tenants, { fields: [zones.tenantId], references: [tenants.id], }), countries: many(zoneCountries), shippingRates: many(shippingRates), shipments: many(shipments), })); export const zoneCountriesRelations = relations(zoneCountries, ({ one }) => ({ zone: one(zones, { fields: [zoneCountries.zoneId], references: [zones.id], }), country: one(countries, { fields: [zoneCountries.countryCode], references: [countries.code], }), })); export const shippingRatesRelations = relations(shippingRates, ({ one }) => ({ tenant: one(tenants, { fields: [shippingRates.tenantId], references: [tenants.id], }), warehouse: one(warehouses, { fields: [shippingRates.warehouseId], references: [warehouses.id], }), zone: one(zones, { fields: [shippingRates.zoneId], references: [zones.id], }), })); export const shipmentsRelations = relations(shipments, ({ one, many }) => ({ tenant: one(tenants, { fields: [shipments.tenantId], references: [tenants.id], }), customerProfile: one(customerProfiles, { fields: [shipments.customerProfileId], references: [customerProfiles.id], }), warehouse: one(warehouses, { fields: [shipments.warehouseId], references: [warehouses.id], }), company: one(companies, { fields: [shipments.companyId], references: [companies.id], }), zone: one(zones, { fields: [shipments.zoneId], references: [zones.id], }), createdBy: one(users, { fields: [shipments.createdBy], references: [users.id], relationName: 'createdShipments' }), processedBy: one(users, { fields: [shipments.processedBy], references: [users.id], relationName: 'processedShipments' }), packages: many(shipmentPackages), trackingEvents: many(shipmentTrackingEvents), statusHistory: many(shipmentStatusHistory), invoices: many(invoices), })); export const shipmentPackagesRelations = relations(shipmentPackages, ({ one }) => ({ shipment: one(shipments, { fields: [shipmentPackages.shipmentId], references: [shipments.id], }), package: one(packages, { fields: [shipmentPackages.packageId], references: [packages.id], }), })); export const shipmentTrackingEventsRelations = relations(shipmentTrackingEvents, ({ one }) => ({ shipment: one(shipments, { fields: [shipmentTrackingEvents.shipmentId], references: [shipments.id], }), })); export const shipmentStatusHistoryRelations = relations(shipmentStatusHistory, ({ one }) => ({ shipment: one(shipments, { fields: [shipmentStatusHistory.shipmentId], references: [shipments.id], }), changedBy: one(users, { fields: [shipmentStatusHistory.changedBy], references: [users.id], relationName: 'shipmentStatusChanges' }), })); // ============================================================================= // FINANCE RELATIONS // ============================================================================= export const invoicesRelations = relations(invoices, ({ one, many }) => ({ tenant: one(tenants, { fields: [invoices.tenantId], references: [tenants.id], }), customerProfile: one(customerProfiles, { fields: [invoices.customerProfileId], references: [customerProfiles.id], }), shipment: one(shipments, { fields: [invoices.shipmentId], references: [shipments.id], }), personalShopperRequest: one(personalShopperRequests, { fields: [invoices.personalShopperRequestId], references: [personalShopperRequests.id], }), lines: many(invoiceLines), })); export const invoiceLinesRelations = relations(invoiceLines, ({ one }) => ({ invoice: one(invoices, { fields: [invoiceLines.invoiceId], references: [invoices.id], }), })); export const personalShopperRequestsRelations = relations(personalShopperRequests, ({ one, many }) => ({ tenant: one(tenants, { fields: [personalShopperRequests.tenantId], references: [tenants.id], }), customerProfile: one(customerProfiles, { fields: [personalShopperRequests.customerProfileId], references: [customerProfiles.id], }), quotedBy: one(users, { fields: [personalShopperRequests.quotedBy], references: [users.id], relationName: 'quotedRequests' }), purchasedBy: one(users, { fields: [personalShopperRequests.purchasedBy], references: [users.id], relationName: 'purchasedRequests' }), items: many(personalShopperRequestItems), statusHistory: many(personalShopperRequestStatusHistory), invoices: many(invoices), })); export const personalShopperRequestItemsRelations = relations(personalShopperRequestItems, ({ one }) => ({ personalShopperRequest: one(personalShopperRequests, { fields: [personalShopperRequestItems.personalShopperRequestId], references: [personalShopperRequests.id], }), package: one(packages, { fields: [personalShopperRequestItems.packageId], references: [packages.id], }), })); export const personalShopperRequestStatusHistoryRelations = relations(personalShopperRequestStatusHistory, ({ one }) => ({ personalShopperRequest: one(personalShopperRequests, { fields: [personalShopperRequestStatusHistory.personalShopperRequestId], references: [personalShopperRequests.id], }), changedBy: one(users, { fields: [personalShopperRequestStatusHistory.changedBy], references: [users.id], relationName: 'personalShopperStatusChanges' }), })); // ============================================================================= // SETTINGS RELATIONS // ============================================================================= export const countriesRelations = relations(countries, ({ many }) => ({ zoneCountries: many(zoneCountries), })); export const currenciesRelations = relations(currencies, ({ many }) => ({ tenantCurrencies: many(tenantCurrencies), })); export const couriersRelations = relations(couriers, ({ many }) => ({ services: many(courierServices), tenantCouriers: many(tenantCouriers), incomingShipments: many(incomingShipments), })); export const courierServicesRelations = relations(courierServices, ({ one }) => ({ courier: one(couriers, { fields: [courierServices.courierId], references: [couriers.id], }), })); export const tenantCurrenciesRelations = relations(tenantCurrencies, ({ one }) => ({ tenant: one(tenants, { fields: [tenantCurrencies.tenantId], references: [tenants.id], }), currency: one(currencies, { fields: [tenantCurrencies.currencyId], references: [currencies.id], }), })); export const tenantCouriersRelations = relations(tenantCouriers, ({ one }) => ({ tenant: one(tenants, { fields: [tenantCouriers.tenantId], references: [tenants.id], }), courier: one(couriers, { fields: [tenantCouriers.courierId], references: [couriers.id], }), })); export const documentsRelations = relations(documents, ({ one, many }) => ({ tenant: one(tenants, { fields: [documents.tenantId], references: [tenants.id], }), uploadedBy: one(users, { fields: [documents.uploadedBy], references: [users.id], relationName: 'uploadedDocuments' }), entityDocuments: many(entityDocuments), })); export const entityDocumentsRelations = relations(entityDocuments, ({ one }) => ({ document: one(documents, { fields: [entityDocuments.documentId], references: [documents.id], }), attachedBy: one(users, { fields: [entityDocuments.attachedBy], references: [users.id], relationName: 'attachedDocuments' }), })); export const addressesRelations = relations(addresses, ({ one, many }) => ({ tenant: one(tenants, { fields: [addresses.tenantId], references: [tenants.id], }), createdBy: one(users, { fields: [addresses.createdBy], references: [users.id], relationName: 'createdAddresses' }), entityAddresses: many(entityAddresses), })); export const entityAddressesRelations = relations(entityAddresses, ({ one }) => ({ address: one(addresses, { fields: [entityAddresses.addressId], references: [addresses.id], }), assignedBy: one(users, { fields: [entityAddresses.assignedBy], references: [users.id], relationName: 'assignedAddresses' }), })); // ============================================================================= // AUDIT RELATIONS // ============================================================================= export const activityLogsRelations = relations(activityLogs, ({ one }) => ({ tenant: one(tenants, { fields: [activityLogs.tenantId], references: [tenants.id], }), user: one(users, { fields: [activityLogs.userId], references: [users.id], }), customerProfile: one(customerProfiles, { fields: [activityLogs.customerProfileId], references: [customerProfiles.id], }), })); export const notificationsRelations = relations(notifications, ({ one }) => ({ tenant: one(tenants, { fields: [notifications.tenantId], references: [tenants.id], }), user: one(users, { fields: [notifications.userId], references: [users.id], }), customerProfile: one(customerProfiles, { fields: [notifications.customerProfileId], references: [customerProfiles.id], }), })); export const notificationTemplatesRelations = relations(notificationTemplates, ({ one }) => ({ tenant: one(tenants, { fields: [notificationTemplates.tenantId], references: [tenants.id], }), })); export const complianceEventsRelations = relations(complianceEvents, ({ one }) => ({ tenant: one(tenants, { fields: [complianceEvents.tenantId], references: [tenants.id], }), user: one(users, { fields: [complianceEvents.userId], references: [users.id], }), customerProfile: one(customerProfiles, { fields: [complianceEvents.customerProfileId], references: [customerProfiles.id], }), }));
```

# lib\db\schema\index.ts

```ts
// lib/db/schema/index.ts // Main schema exports for Drizzle ORM // ============================================================================= // FEATURE SCHEMAS // ============================================================================= // Auth & Core export * from '@/features/auth/db/schema'; // Customers export * from '@/features/customers/db/schema'; // Warehouse Operations export * from '@/features/warehouses/db/schema'; // Package Management export * from '@/features/packages/db/schema'; // Shipping & Logistics export * from '@/features/shipping/db/schema'; // Finance & Services export * from '@/features/finance/db/schema'; // Settings & Configuration export * from '@/features/settings/db/schema'; // Audit & Communications export * from '@/features/audit/db/schema'; // ============================================================================= // RELATIONS // ============================================================================= export * from './relations'; // ============================================================================= // UTILS & HELPERS // ============================================================================= // Re-export commonly used Drizzle utilities for convenience export { sql, eq, and, or, not, desc, asc, count, sum, max, min, avg } from 'drizzle-orm'; export type { InferSelectModel, InferInsertModel } from 'drizzle-orm'; // Helper type for pagination export interface PaginationMeta { page: number; limit: number; total: number; pages: number; } // Standard API response types export interface ApiResponse<T = any> { success: boolean; data: T; message?: string; } export interface PaginatedResponse<T> extends ApiResponse<T[]> { pagination: PaginationMeta; } // Error response type export interface ApiError { success: false; message: string; errors?: any[]; code?: string; }
```

# lib\db\migrations\0000_free_kulan_gath.sql

```sql
CREATE TABLE "customers" ( "id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL, "name" varchar(100) NOT NULL, "email" varchar(255) NOT NULL, "phone" varchar(20), "address" varchar(255), "city" varchar(100), "state" varchar(100), "country" varchar(100), "postal_code" varchar(20), "status" text DEFAULT 'pending' NOT NULL, "notes" text, "created_at" timestamp DEFAULT now() NOT NULL, "updated_at" timestamp DEFAULT now() NOT NULL, CONSTRAINT "customers_email_unique" UNIQUE("email") ); --> statement-breakpoint CREATE TABLE "package_photos" ( "id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL, "package_id" uuid NOT NULL, "url" varchar(255) NOT NULL, "caption" varchar(255), "created_at" timestamp DEFAULT now() NOT NULL ); --> statement-breakpoint CREATE TABLE "packages" ( "id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL, "tracking_number" varchar(50) NOT NULL, "customer_id" uuid NOT NULL, "status" text DEFAULT 'pending' NOT NULL, "weight" varchar(20), "dimensions" varchar(50), "origin" varchar(100), "destination" varchar(100) NOT NULL, "estimated_delivery" timestamp, "created_at" timestamp DEFAULT now() NOT NULL, "updated_at" timestamp DEFAULT now() NOT NULL, CONSTRAINT "packages_tracking_number_unique" UNIQUE("tracking_number") ); --> statement-breakpoint ALTER TABLE "package_photos" ADD CONSTRAINT "package_photos_package_id_packages_id_fk" FOREIGN KEY ("package_id") REFERENCES "public"."packages"("id") ON DELETE cascade ON UPDATE no action;
```

# features\packages\types\package.types.ts

```ts
export interface Package { id: string; trackingNumber: string; customerId: string; customerName?: string; // Computed field from join status: PackageStatus; weight: string | null; dimensions: string | null; origin: string | null; destination: string; estimatedDelivery: string | null; createdAt: string; updatedAt: string; photos?: PackagePhoto[]; // Optional relation } export interface PackageFilters { status?: string; customerId?: string; search?: string; origin?: string; destination?: string; fromDate?: string; toDate?: string; page?: number; limit?: number; } export interface CreatePackageData { trackingNumber: string; customerId: string; status?: PackageStatus; weight?: string | null; dimensions?: string | null; origin?: string | null; destination: string; estimatedDelivery?: string | null; } export interface UpdatePackageData { trackingNumber?: string; customerId?: string; status?: PackageStatus; weight?: string | null; dimensions?: string | null; origin?: string | null; destination?: string; estimatedDelivery?: string | null; } export interface PackagePhoto { id: string; packageId: string; url: string; caption: string | null; createdAt: string; } export type PackageStatus = 'pending' | 'processing' | 'shipped' | 'delivered' | 'returned';
```

# features\packages\services\package-api.ts

```ts
import { apiClient, ApiResponse, PaginatedResponse } from '@/shared/services/api/client'; import { Package, PackageFilters, CreatePackageData, UpdatePackageData } from '../types/package.types'; export const packageApi = { // Queries getPackages: async (filters: PackageFilters = {}): Promise<PaginatedResponse<Package>> => { return apiClient.get('/packages', { params: filters }); }, getPackage: async (id: string): Promise<ApiResponse<Package>> => { return apiClient.get(`/packages/${id}`); }, searchPackages: async (query: string): Promise<ApiResponse<Package[]>> => { return apiClient.get('/packages/search', { params: { q: query } }); }, // Mutations createPackage: async (data: CreatePackageData): Promise<ApiResponse<Package>> => { return apiClient.post('/packages', data); }, updatePackage: async (id: string, data: UpdatePackageData): Promise<ApiResponse<Package>> => { return apiClient.patch(`/packages/${id}`, data); }, deletePackage: async (id: string): Promise<ApiResponse<void>> => { return apiClient.delete(`/packages/${id}`); }, updateStatus: async (id: string, status: string): Promise<ApiResponse<Package>> => { return apiClient.patch(`/packages/${id}/status`, { status }); }, uploadPhoto: async (id: string, file: File): Promise<ApiResponse<string>> => { const formData = new FormData(); formData.append('photo', file); return apiClient.post(`/packages/${id}/photos`, formData, { headers: { 'Content-Type': 'multipart/form-data' } }); }, bulkUpdateStatus: async (ids: string[], status: string): Promise<ApiResponse<Package[]>> => { return apiClient.patch('/packages/bulk-status', { ids, status }); }, };
```

# features\packages\components\package-table.tsx

```tsx
'use client'; import { useMemo } from 'react'; import { ColumnDef } from '@tanstack/react-table'; import { DataTable } from '@/shared/components/data-table/data-table'; import { Package, PackageFilters } from '../types/package.types'; import { usePackages, useBulkUpdatePackageStatus } from '../hooks/use-packages-query'; import { useGlobalStore } from '@/shared/stores/global-store'; import { PackageStatusBadge } from './package-status-badge'; import { Button } from '@/components/ui/button'; import { MoreHorizontal } from 'lucide-react'; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, } from '@/components/ui/dropdown-menu'; interface PackageTableProps { filters?: PackageFilters; variant?: 'admin' | 'customer'; onPackageClick?: (packageItem: Package) => void; } export function PackageTable({ filters = {}, variant = 'customer', onPackageClick, }: PackageTableProps) { // Data fetching const { data: response, isLoading, error, refetch } = usePackages(filters); const packages = response?.data || []; const pagination = response?.pagination; // Global state const selections = useGlobalStore(state => state.selections.packages || new Set<string>()); const setSelection = useGlobalStore(state => state.setSelection); const clearSelection = useGlobalStore(state => state.clearSelection); // Mutations const bulkUpdateStatus = useBulkUpdatePackageStatus(); // Table configuration const columns = useMemo<ColumnDef<Package>[]>(() => [ ...(variant === 'admin' ? [{ id: 'select', header: ({ table }: { table: any }) => ( <input type="checkbox" checked={table.getIsAllPageRowsSelected()} onChange={(e) => { const allIds = new Set(packages.map((pkg: Package) => pkg.id)); setSelection('packages', e.target.checked ? allIds : new Set()); }} /> ), cell: ({ row }: { row: any }) => ( <input type="checkbox" checked={selections.has(row.original.id)} onChange={(e) => { const newSelection = new Set(selections); if (e.target.checked) { newSelection.add(row.original.id); } else { newSelection.delete(row.original.id); } setSelection('packages', newSelection); }} /> ), }] : []), { accessorKey: 'trackingNumber', header: 'Tracking Number', cell: ({ row }: { row: any }) => ( <span className="font-medium">{row.original.trackingNumber}</span> ), }, { accessorKey: 'customerName', header: 'Customer', cell: ({ row }: { row: any }) => ( <span>{row.original.customerName}</span> ), }, { accessorKey: 'status', header: 'Status', cell: ({ row }: { row: any }) => ( <PackageStatusBadge status={row.original.status} /> ), }, { accessorKey: 'receivedAt', header: 'Received', cell: ({ row }: { row: any }) => { if (!row.original.receivedAt) return '-'; return new Date(row.original.receivedAt).toLocaleDateString(); }, }, { accessorKey: 'weight', header: 'Weight', cell: ({ row }: { row: any }) => { if (!row.original.weight) return '-'; return `${row.original.weight}kg`; }, }, ...(variant === 'admin' ? [{ id: 'actions', header: 'Actions', cell: ({ row }: { row: any }) => ( <DropdownMenu> <DropdownMenuTrigger asChild> <Button variant="ghost" className="h-8 w-8 p-0"> <MoreHorizontal className="h-4 w-4" /> </Button> </DropdownMenuTrigger> <DropdownMenuContent align="end"> <DropdownMenuItem onClick={() => onPackageClick?.(row.original)}> View Details </DropdownMenuItem> <DropdownMenuItem>Edit Package</DropdownMenuItem> <DropdownMenuItem>Update Status</DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> ), }] : []), ], [variant, packages, selections, setSelection, onPackageClick]); // Bulk actions const handleBulkStatusUpdate = (status: string) => { const selectedIds = Array.from(selections); if (selectedIds.length === 0) return; bulkUpdateStatus.mutate({ ids: selectedIds, status }); }; const bulkActions = variant === 'admin' && selections.size > 0 ? ( <div className="flex gap-2"> <Button variant="outline" size="sm" onClick={() => handleBulkStatusUpdate('processing')} disabled={bulkUpdateStatus.isPending} > Mark as Processing ({selections.size}) </Button> <Button variant="outline" size="sm" onClick={() => handleBulkStatusUpdate('ready_to_ship')} disabled={bulkUpdateStatus.isPending} > Mark Ready to Ship ({selections.size}) </Button> <Button variant="ghost" size="sm" onClick={() => clearSelection('packages')} > Clear Selection </Button> </div> ) : null; if (error) { return ( <div className="text-center py-8"> <p className="text-red-600">Failed to load packages</p> <Button onClick={() => refetch()} className="mt-2"> Retry </Button> </div> ); } return ( <DataTable data={packages} columns={columns} isLoading={isLoading} searchKey="trackingNumber" searchPlaceholder="Search by tracking number..." onRefresh={refetch} actions={bulkActions} onRowClick={onPackageClick} /> ); }
```

# features\packages\components\package-status-badge.tsx

```tsx
import { Badge } from '@/components/ui/badge'; interface PackageStatusBadgeProps { status: string; } export function PackageStatusBadge({ status }: PackageStatusBadgeProps) { const getStatusConfig = (status: string) => { switch (status) { case 'received': return { variant: 'secondary' as const, label: 'Received' }; case 'processing': return { variant: 'default' as const, label: 'Processing' }; case 'ready_to_ship': return { variant: 'outline' as const, label: 'Ready to Ship' }; case 'shipped': return { variant: 'default' as const, label: 'Shipped' }; case 'delivered': return { variant: 'default' as const, label: 'Delivered' }; default: return { variant: 'secondary' as const, label: status }; } }; const { variant, label } = getStatusConfig(status); return ( <Badge variant={variant}> {label} </Badge> ); }
```

# features\customers\types\customer.types.ts

```ts
export interface Customer { id: string; name: string; email: string; phone: string | null; address: string | null; city: string | null; state: string | null; country: string | null; postalCode: string | null; status: 'active' | 'inactive' | 'pending' | 'blocked'; notes: string | null; packageCount?: number; // Computed field createdAt: string; updatedAt: string; } export interface CustomerFilters { status?: string; search?: string; country?: string; dateFrom?: string; dateTo?: string; page?: number; limit?: number; } export interface CreateCustomerData { name: string; email: string; phone?: string | null; address?: string | null; city?: string | null; state?: string | null; country?: string | null; postalCode?: string | null; status?: 'active' | 'inactive' | 'pending' | 'blocked'; notes?: string | null; } export interface UpdateCustomerData { name?: string; email?: string; phone?: string | null; address?: string | null; city?: string | null; state?: string | null; country?: string | null; postalCode?: string | null; status?: 'active' | 'inactive' | 'pending' | 'blocked'; notes?: string | null; }
```

# features\customers\services\customer-api.ts

```ts
import { apiClient, ApiResponse, PaginatedResponse } from '@/shared/services/api/client'; import { Customer, CustomerFilters, CreateCustomerData, UpdateCustomerData } from '../types/customer.types'; export const customerApi = { // Queries getCustomers: async (filters: CustomerFilters = {}): Promise<PaginatedResponse<Customer>> => { return apiClient.get('/customers', { params: filters }); }, getCustomer: async (id: string): Promise<ApiResponse<Customer>> => { return apiClient.get(`/customers/${id}`); }, searchCustomers: async (query: string): Promise<ApiResponse<Customer[]>> => { return apiClient.get('/customers/search', { params: { q: query } }); }, // Mutations createCustomer: async (data: CreateCustomerData): Promise<ApiResponse<Customer>> => { return apiClient.post('/customers', data); }, updateCustomer: async (id: string, data: UpdateCustomerData): Promise<ApiResponse<Customer>> => { return apiClient.patch(`/customers/${id}`, data); }, deleteCustomer: async (id: string): Promise<ApiResponse<void>> => { return apiClient.delete(`/customers/${id}`); }, updateStatus: async (id: string, status: string): Promise<ApiResponse<Customer>> => { return apiClient.patch(`/customers/${id}/status`, { status }); }, };
```

# features\customers\hooks\use-customers-query.ts

```ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'; import { queryKeys } from '@/shared/lib/query-keys'; import { customerApi } from '../services/customer-api'; import { CustomerFilters, CreateCustomerData, UpdateCustomerData } from '../types/customer.types'; import { useGlobalStore } from '@/shared/stores/global-store'; // Queries export const useCustomers = (filters: CustomerFilters = {}) => { return useQuery({ queryKey: queryKeys.customers.list(filters), queryFn: () => customerApi.getCustomers(filters), select: (data) => data, // Return full response with data and pagination }); }; export const useCustomer = (id: string) => { return useQuery({ queryKey: queryKeys.customers.detail(id), queryFn: () => customerApi.getCustomer(id), select: (data) => data.data, enabled: !!id, }); }; export const useCustomerSearch = (query: string) => { return useQuery({ queryKey: queryKeys.customers.search(query), queryFn: () => customerApi.searchCustomers(query), select: (data) => data.data, enabled: query.length >= 2, staleTime: 30 * 1000, // 30 seconds }); }; // Mutations export const useCreateCustomer = () => { const queryClient = useQueryClient(); const addNotification = useGlobalStore(state => state.addNotification); return useMutation({ mutationFn: customerApi.createCustomer, onSuccess: (response) => { // Invalidate and refetch customers list queryClient.invalidateQueries({ queryKey: queryKeys.customers.lists() }); addNotification({ type: 'success', message: 'Customer created successfully', }); }, onError: (error: any) => { addNotification({ type: 'error', message: error.response?.data?.message || 'Failed to create customer', }); }, }); }; export const useUpdateCustomer = () => { const queryClient = useQueryClient(); const addNotification = useGlobalStore(state => state.addNotification); return useMutation({ mutationFn: ({ id, data }: { id: string; data: UpdateCustomerData }) => customerApi.updateCustomer(id, data), // Optimistic update onMutate: async ({ id, data }) => { await queryClient.cancelQueries({ queryKey: queryKeys.customers.detail(id) }); const previousCustomer = queryClient.getQueryData(queryKeys.customers.detail(id)); queryClient.setQueryData(queryKeys.customers.detail(id), (old: any) => ({ ...old, data: { ...old?.data, ...data } })); return { previousCustomer }; }, onError: (err, variables, context) => { if (context?.previousCustomer) { queryClient.setQueryData( queryKeys.customers.detail(variables.id), context.previousCustomer ); } addNotification({ type: 'error', message: 'Failed to update customer', }); }, onSuccess: (response, { id }) => { queryClient.invalidateQueries({ queryKey: queryKeys.customers.lists() }); addNotification({ type: 'success', message: 'Customer updated successfully', }); }, }); }; export const useUpdateCustomerStatus = () => { const queryClient = useQueryClient(); const addNotification = useGlobalStore(state => state.addNotification); return useMutation({ mutationFn: ({ id, status }: { id: string; status: string }) => customerApi.updateStatus(id, status), onMutate: async ({ id, status }) => { await queryClient.cancelQueries({ queryKey: queryKeys.customers.detail(id) }); const previousCustomer = queryClient.getQueryData(queryKeys.customers.detail(id)); queryClient.setQueryData(queryKeys.customers.detail(id), (old: any) => ({ ...old, data: { ...old?.data, status } })); return { previousCustomer }; }, onError: (err, variables, context) => { if (context?.previousCustomer) { queryClient.setQueryData( queryKeys.customers.detail(variables.id), context.previousCustomer ); } }, onSettled: (data, error, variables) => { queryClient.invalidateQueries({ queryKey: queryKeys.customers.detail(variables.id) }); queryClient.invalidateQueries({ queryKey: queryKeys.customers.lists() }); }, }); };
```

# features\packages\hooks\use-packages-query.ts

```ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'; import { queryKeys } from '@/shared/lib/query-keys'; import { packageApi } from '../services/package-api'; import { PackageFilters, UpdatePackageData } from '../types/package.types'; import { useGlobalStore } from '@/shared/stores/global-store'; // Queries export const usePackages = (filters: PackageFilters = {}) => { return useQuery({ queryKey: queryKeys.packages.list(filters), queryFn: () => packageApi.getPackages(filters), select: (data) => data, // Return full response with data and pagination }); }; export const usePackage = (id: string) => { return useQuery({ queryKey: queryKeys.packages.detail(id), queryFn: () => packageApi.getPackage(id), select: (data) => data.data, enabled: !!id, }); }; export const usePackageSearch = (query: string) => { return useQuery({ queryKey: [...queryKeys.packages.all, 'search', query], queryFn: () => packageApi.searchPackages(query), select: (data) => data.data, enabled: query.length >= 2, staleTime: 30 * 1000, // 30 seconds }); }; // Mutations export const useCreatePackage = () => { const queryClient = useQueryClient(); const addNotification = useGlobalStore(state => state.addNotification); return useMutation({ mutationFn: packageApi.createPackage, onSuccess: (response) => { // Invalidate and refetch packages list queryClient.invalidateQueries({ queryKey: queryKeys.packages.lists() }); addNotification({ type: 'success', message: 'Package created successfully', }); }, onError: (error: any) => { addNotification({ type: 'error', message: error.response?.data?.message || 'Failed to create package', }); }, }); }; export const useUpdatePackage = () => { const queryClient = useQueryClient(); const addNotification = useGlobalStore(state => state.addNotification); return useMutation({ mutationFn: ({ id, data }: { id: string; data: UpdatePackageData }) => packageApi.updatePackage(id, data), // Optimistic update onMutate: async ({ id, data }) => { await queryClient.cancelQueries({ queryKey: queryKeys.packages.detail(id) }); const previousPackage = queryClient.getQueryData(queryKeys.packages.detail(id)); queryClient.setQueryData(queryKeys.packages.detail(id), (old: any) => ({ ...old, data: { ...old?.data, ...data } })); return { previousPackage }; }, onError: (err, variables, context) => { if (context?.previousPackage) { queryClient.setQueryData( queryKeys.packages.detail(variables.id), context.previousPackage ); } addNotification({ type: 'error', message: 'Failed to update package', }); }, onSuccess: (response, { id }) => { queryClient.invalidateQueries({ queryKey: queryKeys.packages.lists() }); addNotification({ type: 'success', message: 'Package updated successfully', }); }, }); }; export const useUpdatePackageStatus = () => { const queryClient = useQueryClient(); const addNotification = useGlobalStore(state => state.addNotification); return useMutation({ mutationFn: ({ id, status }: { id: string; status: string }) => packageApi.updateStatus(id, status), onMutate: async ({ id, status }) => { await queryClient.cancelQueries({ queryKey: queryKeys.packages.detail(id) }); const previousPackage = queryClient.getQueryData(queryKeys.packages.detail(id)); queryClient.setQueryData(queryKeys.packages.detail(id), (old: any) => ({ ...old, data: { ...old?.data, status } })); return { previousPackage }; }, onError: (err, variables, context) => { if (context?.previousPackage) { queryClient.setQueryData( queryKeys.packages.detail(variables.id), context.previousPackage ); } }, onSettled: (data, error, variables) => { queryClient.invalidateQueries({ queryKey: queryKeys.packages.detail(variables.id) }); queryClient.invalidateQueries({ queryKey: queryKeys.packages.lists() }); }, }); }; export const useBulkUpdatePackageStatus = () => { const queryClient = useQueryClient(); const addNotification = useGlobalStore(state => state.addNotification); const clearSelection = useGlobalStore(state => state.clearSelection); return useMutation({ mutationFn: ({ ids, status }: { ids: string[]; status: string }) => packageApi.bulkUpdateStatus(ids, status), onSuccess: (response, { ids }) => { queryClient.invalidateQueries({ queryKey: queryKeys.packages.lists() }); // Clear selection after successful bulk update clearSelection('packages'); addNotification({ type: 'success', message: `Updated ${ids.length} packages successfully`, }); }, onError: () => { addNotification({ type: 'error', message: 'Failed to update packages', }); }, }); };
```

# features\customers\components\customer-table.tsx

```tsx
'use client'; import { useMemo } from 'react'; import { ColumnDef } from '@tanstack/react-table'; import { DataTable } from '@/shared/components/data-table/data-table'; import { Customer, CustomerFilters } from '../types/customer.types'; import { useCustomers } from '../hooks/use-customers-query'; import { CustomerStatusBadge } from './customer-status-badge'; import { Button } from '@/components/ui/button'; import { MoreHorizontal } from 'lucide-react'; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, } from '@/components/ui/dropdown-menu'; interface CustomerTableProps { filters?: CustomerFilters; onCustomerClick?: (customer: Customer) => void; } export function CustomerTable({ filters = {}, onCustomerClick, }: CustomerTableProps) { // Data fetching const { data: response, isLoading, error, refetch } = useCustomers(filters); const customers = response?.data || []; // Table configuration const columns = useMemo<ColumnDef<Customer>[]>(() => [ { accessorKey: 'name', header: 'Name', cell: ({ row }) => ( <div> <span className="font-medium"> {row.original.name} </span> <div className="text-sm text-muted-foreground"> {row.original.email} </div> </div> ), }, { accessorKey: 'address', header: 'Location', cell: ({ row }) => ( <div> <span>{row.original.city}, {row.original.state}</span> <div className="text-sm text-muted-foreground"> {row.original.country} </div> </div> ), }, { accessorKey: 'status', header: 'Status', cell: ({ row }) => ( <CustomerStatusBadge status={row.original.status} /> ), }, { accessorKey: 'packageCount', header: 'Packages', cell: ({ row }) => ( <span className="font-medium">{row.original.packageCount}</span> ), }, // Removed totalSpent column as it's not in our schema { accessorKey: 'createdAt', header: 'Joined', cell: ({ row }) => { return new Date(row.original.createdAt).toLocaleDateString(); }, }, { id: 'actions', header: 'Actions', cell: ({ row }) => ( <DropdownMenu> <DropdownMenuTrigger asChild> <Button variant="ghost" className="h-8 w-8 p-0"> <MoreHorizontal className="h-4 w-4" /> </Button> </DropdownMenuTrigger> <DropdownMenuContent align="end"> <DropdownMenuItem onClick={() => onCustomerClick?.(row.original)}> View Details </DropdownMenuItem> <DropdownMenuItem>Edit Customer</DropdownMenuItem> <DropdownMenuItem>View Packages</DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> ), }, ], [onCustomerClick]); if (error) { return ( <div className="text-center py-8"> <p className="text-red-600">Failed to load customers</p> <Button onClick={() => refetch()} className="mt-2"> Retry </Button> </div> ); } return ( <DataTable data={customers} columns={columns} isLoading={isLoading} searchKey="name" searchPlaceholder="Search customers..." onRefresh={refetch} onRowClick={onCustomerClick} /> ); }
```

# features\customers\components\customer-status-badge.tsx

```tsx
import { Badge } from '@/components/ui/badge'; interface CustomerStatusBadgeProps { status: string; } export function CustomerStatusBadge({ status }: CustomerStatusBadgeProps) { const getStatusConfig = (status: string) => { switch (status) { case 'active': return { variant: 'default' as const, label: 'Active' }; case 'inactive': return { variant: 'secondary' as const, label: 'Inactive' }; case 'suspended': return { variant: 'destructive' as const, label: 'Suspended' }; default: return { variant: 'secondary' as const, label: status }; } }; const { variant, label } = getStatusConfig(status); return ( <Badge variant={variant}> {label} </Badge> ); }
```

# app\api\packages\route.ts

```ts
// app/api/packages/route.ts import { NextRequest, NextResponse } from 'next/server'; import { getPackages, createPackage } from '@/features/packages/db/queries'; export async function GET(request: NextRequest) { try { const { searchParams } = new URL(request.url); const page = parseInt(searchParams.get('page') || '1'); const limit = parseInt(searchParams.get('limit') || '10'); const status = searchParams.get('status'); const search = searchParams.get('search'); const customerId = searchParams.get('customerId'); // Use the getPackages query function const result = await getPackages({ page, limit, status: status ? status as any : undefined, search: search || undefined, customerId: customerId || undefined }); return NextResponse.json(result); } catch (error) { console.error('Error fetching packages:', error); return NextResponse.json( { success: false, message: 'Failed to fetch packages' }, { status: 500 } ); } } export async function POST(request: NextRequest) { try { const body = await request.json(); const { trackingNumber, customerId, status, weight, dimensions, origin, destination, estimatedDelivery } = body; // Validate required fields if (!trackingNumber || !customerId) { return NextResponse.json( { error: 'Tracking number and customer ID are required' }, { status: 400 } ); } // Use the createPackage query function const newPackage = await createPackage({ trackingNumber, customerId, status, weight, dimensions, origin, destination, estimatedDelivery }); return NextResponse.json({ data: newPackage }); } catch (error) { console.error('Error creating package:', error); return NextResponse.json( { success: false, message: 'Failed to create package' }, { status: 500 } ); } }
```

# app\api\customers\route.ts

```ts
// app/api/customers/route.ts import { NextRequest, NextResponse } from 'next/server'; import { getCustomers, createCustomer, searchCustomers } from '@/features/customers/db/queries'; export async function GET(request: NextRequest) { try { const { searchParams } = new URL(request.url); const page = parseInt(searchParams.get('page') || '1'); const limit = parseInt(searchParams.get('limit') || '10'); const status = searchParams.get('status'); const search = searchParams.get('search'); const country = searchParams.get('country'); // Use the getCustomers query function const result = await getCustomers({ page, limit, status: status ? status as any : undefined, search: search || undefined, country: country || undefined }); return NextResponse.json(result); } catch (error) { console.error('Error fetching customers:', error); return NextResponse.json( { error: 'Failed to fetch customers' }, { status: 500 } ); } } export async function POST(request: NextRequest) { try { const body = await request.json(); const { name, email, phone, address, city, state, country, postalCode, status, notes } = body; // Validate required fields if (!name || !email) { return NextResponse.json( { error: 'Name and email are required' }, { status: 400 } ); } // Use the createCustomer query function const newCustomer = await createCustomer({ name, email, phone, address, city, state, country, postalCode, status: status || 'pending', notes }); return NextResponse.json({ data: newCustomer }); } catch (error) { console.error('Error creating customer:', error); return NextResponse.json( { error: 'Failed to create customer' }, { status: 500 } ); } }
```

# lib\db\migrations\meta\_journal.json

```json
{ "version": "7", "dialect": "postgresql", "entries": [ { "idx": 0, "version": "7", "when": 1753778586360, "tag": "0000_free_kulan_gath", "breakpoints": true } ] }
```

# lib\db\migrations\meta\0000_snapshot.json

```json
{ "id": "1d858732-07ae-4eea-ba40-d2f25b4ce64e", "prevId": "00000000-0000-0000-0000-000000000000", "version": "7", "dialect": "postgresql", "tables": { "public.customers": { "name": "customers", "schema": "", "columns": { "id": { "name": "id", "type": "uuid", "primaryKey": true, "notNull": true, "default": "gen_random_uuid()" }, "name": { "name": "name", "type": "varchar(100)", "primaryKey": false, "notNull": true }, "email": { "name": "email", "type": "varchar(255)", "primaryKey": false, "notNull": true }, "phone": { "name": "phone", "type": "varchar(20)", "primaryKey": false, "notNull": false }, "address": { "name": "address", "type": "varchar(255)", "primaryKey": false, "notNull": false }, "city": { "name": "city", "type": "varchar(100)", "primaryKey": false, "notNull": false }, "state": { "name": "state", "type": "varchar(100)", "primaryKey": false, "notNull": false }, "country": { "name": "country", "type": "varchar(100)", "primaryKey": false, "notNull": false }, "postal_code": { "name": "postal_code", "type": "varchar(20)", "primaryKey": false, "notNull": false }, "status": { "name": "status", "type": "text", "primaryKey": false, "notNull": true, "default": "'pending'" }, "notes": { "name": "notes", "type": "text", "primaryKey": false, "notNull": false }, "created_at": { "name": "created_at", "type": "timestamp", "primaryKey": false, "notNull": true, "default": "now()" }, "updated_at": { "name": "updated_at", "type": "timestamp", "primaryKey": false, "notNull": true, "default": "now()" } }, "indexes": {}, "foreignKeys": {}, "compositePrimaryKeys": {}, "uniqueConstraints": { "customers_email_unique": { "name": "customers_email_unique", "nullsNotDistinct": false, "columns": [ "email" ] } }, "policies": {}, "checkConstraints": {}, "isRLSEnabled": false }, "public.package_photos": { "name": "package_photos", "schema": "", "columns": { "id": { "name": "id", "type": "uuid", "primaryKey": true, "notNull": true, "default": "gen_random_uuid()" }, "package_id": { "name": "package_id", "type": "uuid", "primaryKey": false, "notNull": true }, "url": { "name": "url", "type": "varchar(255)", "primaryKey": false, "notNull": true }, "caption": { "name": "caption", "type": "varchar(255)", "primaryKey": false, "notNull": false }, "created_at": { "name": "created_at", "type": "timestamp", "primaryKey": false, "notNull": true, "default": "now()" } }, "indexes": {}, "foreignKeys": { "package_photos_package_id_packages_id_fk": { "name": "package_photos_package_id_packages_id_fk", "tableFrom": "package_photos", "tableTo": "packages", "columnsFrom": [ "package_id" ], "columnsTo": [ "id" ], "onDelete": "cascade", "onUpdate": "no action" } }, "compositePrimaryKeys": {}, "uniqueConstraints": {}, "policies": {}, "checkConstraints": {}, "isRLSEnabled": false }, "public.packages": { "name": "packages", "schema": "", "columns": { "id": { "name": "id", "type": "uuid", "primaryKey": true, "notNull": true, "default": "gen_random_uuid()" }, "tracking_number": { "name": "tracking_number", "type": "varchar(50)", "primaryKey": false, "notNull": true }, "customer_id": { "name": "customer_id", "type": "uuid", "primaryKey": false, "notNull": true }, "status": { "name": "status", "type": "text", "primaryKey": false, "notNull": true, "default": "'pending'" }, "weight": { "name": "weight", "type": "varchar(20)", "primaryKey": false, "notNull": false }, "dimensions": { "name": "dimensions", "type": "varchar(50)", "primaryKey": false, "notNull": false }, "origin": { "name": "origin", "type": "varchar(100)", "primaryKey": false, "notNull": false }, "destination": { "name": "destination", "type": "varchar(100)", "primaryKey": false, "notNull": true }, "estimated_delivery": { "name": "estimated_delivery", "type": "timestamp", "primaryKey": false, "notNull": false }, "created_at": { "name": "created_at", "type": "timestamp", "primaryKey": false, "notNull": true, "default": "now()" }, "updated_at": { "name": "updated_at", "type": "timestamp", "primaryKey": false, "notNull": true, "default": "now()" } }, "indexes": {}, "foreignKeys": {}, "compositePrimaryKeys": {}, "uniqueConstraints": { "packages_tracking_number_unique": { "name": "packages_tracking_number_unique", "nullsNotDistinct": false, "columns": [ "tracking_number" ] } }, "policies": {}, "checkConstraints": {}, "isRLSEnabled": false } }, "enums": {}, "schemas": {}, "sequences": {}, "roles": {}, "policies": {}, "views": {}, "_meta": { "columns": {}, "schemas": {}, "tables": {} } }
```

# features\warehouses\db\schema\index.ts

```ts
// features/warehouse/db/schema/index.ts // Warehouse, Storage Management, and Bin Location schemas import { pgTable, uuid, varchar, text, timestamp, decimal, integer, jsonb, boolean, date } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; // ============================================================================= // ENUMS // ============================================================================= export const warehouseStatusEnum = ['active', 'inactive', 'maintenance'] as const; export const assignmentStatusEnum = ['active', 'suspended', 'expired'] as const; export const taxTreatmentEnum = ['standard', 'tax_free', 'bonded'] as const; export type WarehouseStatus = typeof warehouseStatusEnum[number]; export type AssignmentStatus = typeof assignmentStatusEnum[number]; export type TaxTreatment = typeof taxTreatmentEnum[number]; // ============================================================================= // WAREHOUSE MANAGEMENT // ============================================================================= export const warehouses = pgTable('warehouses', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // Basic info code: varchar('code', { length: 20 }).unique().notNull(), name: varchar('name', { length: 255 }).notNull(), description: text('description'), // Location countryCode: varchar('country_code', { length: 2 }).notNull(), addressLine1: varchar('address_line1', { length: 255 }).notNull(), addressLine2: varchar('address_line2', { length: 255 }), city: varchar('city', { length: 100 }).notNull(), stateProvince: varchar('state_province', { length: 100 }), postalCode: varchar('postal_code', { length: 50 }).notNull(), phone: varchar('phone', { length: 50 }), email: varchar('email', { length: 255 }), // Operational details timezone: varchar('timezone', { length: 100 }).default('UTC'), currencyCode: varchar('currency_code', { length: 3 }).notNull(), // Business settings taxTreatment: varchar('tax_treatment', { length: 20 }).default('standard'), storageFreeDays: integer('storage_free_days').default(30), storageFeePerDay: decimal('storage_fee_per_day', { precision: 8, scale: 2 }).default('1.00'), // Capacity and limits maxPackageWeightKg: decimal('max_package_weight_kg', { precision: 8, scale: 2 }).default('30.00'), maxPackageValue: decimal('max_package_value', { precision: 12, scale: 2 }).default('10000.00'), // Status status: varchar('status', { length: 20 }).default('active'), acceptsNewPackages: boolean('accepts_new_packages').default(true), // Operating hours operatingHours: jsonb('operating_hours').default('{}'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const customerWarehouseAssignments = pgTable('customer_warehouse_assignments', { id: uuid('id').primaryKey().defaultRandom(), customerProfileId: uuid('customer_profile_id').notNull(), // References customer profile warehouseId: uuid('warehouse_id').references(() => warehouses.id, { onDelete: 'cascade' }).notNull(), suiteCode: varchar('suite_code', { length: 50 }).notNull(), status: varchar('status', { length: 20 }).default('active'), assignedAt: timestamp('assigned_at').notNull().defaultNow(), assignedBy: uuid('assigned_by'), // References users.id }); // ============================================================================= // STORAGE MANAGEMENT // ============================================================================= export const storagePricing = pgTable('storage_pricing', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), warehouseId: uuid('warehouse_id').references(() => warehouses.id, { onDelete: 'cascade' }), // Pricing details freeDays: integer('free_days').default(7).notNull(), dailyRateAfterFree: decimal('daily_rate_after_free', { precision: 8, scale: 2 }).default('2.00').notNull(), currency: varchar('currency', { length: 3 }).default('USD').notNull(), // Effective period effectiveFrom: date('effective_from').notNull(), effectiveUntil: date('effective_until'), // Status isActive: boolean('is_active').default(true).notNull(), // Metadata notes: text('notes'), createdBy: uuid('created_by'), // References users.id createdAt: timestamp('created_at').defaultNow().notNull(), updatedAt: timestamp('updated_at').defaultNow().notNull(), }); export const binLocations = pgTable('bin_locations', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), warehouseId: uuid('warehouse_id').references(() => warehouses.id, { onDelete: 'cascade' }).notNull(), // Location details binCode: varchar('bin_code', { length: 20 }).notNull(), zoneName: varchar('zone_name', { length: 50 }).notNull(), description: text('description'), // Capacity and constraints maxCapacity: integer('max_capacity').default(10), currentOccupancy: integer('current_occupancy').default(0), maxWeightKg: decimal('max_weight_kg', { precision: 8, scale: 3 }), // Pricing (premium locations may have daily surcharge) dailyPremium: decimal('daily_premium', { precision: 6, scale: 2 }).default('0.00'), currency: varchar('currency', { length: 3 }).default('USD'), // Location properties isClimateControlled: boolean('is_climate_controlled').default(false), isSecured: boolean('is_secured').default(false), isAccessible: boolean('is_accessible').default(true), // Status isActive: boolean('is_active').default(true).notNull(), createdAt: timestamp('created_at').defaultNow().notNull(), updatedAt: timestamp('updated_at').defaultNow().notNull(), }); export const packageBinAssignments = pgTable('package_bin_assignments', { id: uuid('id').primaryKey().defaultRandom(), packageId: uuid('package_id').notNull(), // References packages.id binId: uuid('bin_id').references(() => binLocations.id, { onDelete: 'cascade' }).notNull(), // Assignment details assignedAt: timestamp('assigned_at').defaultNow().notNull(), assignedBy: uuid('assigned_by'), // References users.id removedAt: timestamp('removed_at'), removedBy: uuid('removed_by'), // References users.id // Reason for assignment/removal assignmentReason: varchar('assignment_reason', { length: 100 }), removalReason: varchar('removal_reason', { length: 100 }), // Metadata notes: text('notes'), createdAt: timestamp('created_at').defaultNow().notNull(), }); export const storageCharges = pgTable('storage_charges', { id: uuid('id').primaryKey().defaultRandom(), packageId: uuid('package_id').notNull(), // References packages.id tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // Charge period chargeFromDate: date('charge_from_date').notNull(), chargeToDate: date('charge_to_date').notNull(), daysCharged: integer('days_charged').notNull(), // Fee breakdown baseStorageFee: decimal('base_storage_fee', { precision: 8, scale: 2 }).notNull(), binLocationFee: decimal('bin_location_fee', { precision: 8, scale: 2 }).default('0.00'), totalStorageFee: decimal('total_storage_fee', { precision: 8, scale: 2 }).notNull(), currency: varchar('currency', { length: 3 }).default('USD').notNull(), // Reference to bin location during this period binLocationId: uuid('bin_location_id').references(() => binLocations.id), // Billing status isInvoiced: boolean('is_invoiced').default(false), invoiceId: uuid('invoice_id'), // References financial_invoices.id // Calculation details dailyRate: decimal('daily_rate', { precision: 6, scale: 2 }).notNull(), freeDaysApplied: integer('free_days_applied').default(0), // Metadata calculatedAt: timestamp('calculated_at').defaultNow().notNull(), calculatedBy: uuid('calculated_by'), // References users.id notes: text('notes'), }); // ============================================================================= // TYPE EXPORTS // ============================================================================= // Warehouse types export type Warehouse = InferSelectModel<typeof warehouses>; export type NewWarehouse = InferInsertModel<typeof warehouses>; export type CustomerWarehouseAssignment = InferSelectModel<typeof customerWarehouseAssignments>; export type NewCustomerWarehouseAssignment = InferInsertModel<typeof customerWarehouseAssignments>; // Storage types export type StoragePricing = InferSelectModel<typeof storagePricing>; export type NewStoragePricing = InferInsertModel<typeof storagePricing>; export type BinLocation = InferSelectModel<typeof binLocations>; export type NewBinLocation = InferInsertModel<typeof binLocations>; export type PackageBinAssignment = InferSelectModel<typeof packageBinAssignments>; export type NewPackageBinAssignment = InferInsertModel<typeof packageBinAssignments>; export type StorageCharge = InferSelectModel<typeof storageCharges>; export type NewStorageCharge = InferInsertModel<typeof storageCharges>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface WarehouseFilters { status?: WarehouseStatus; countryCode?: string; acceptsNewPackages?: boolean; search?: string; page?: number; limit?: number; } export interface StoragePricingFilters { warehouseId?: string; isActive?: boolean; effectiveDate?: string; page?: number; limit?: number; } export interface BinLocationFilters { warehouseId?: string; zoneName?: string; isActive?: boolean; isAvailable?: boolean; search?: string; page?: number; limit?: number; } export interface StorageChargeFilters { packageId?: string; chargeFromDate?: string; chargeToDate?: string; isInvoiced?: boolean; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateWarehouseData { code: string; name: string; description?: string; countryCode: string; addressLine1: string; addressLine2?: string; city: string; stateProvince?: string; postalCode: string; phone?: string; email?: string; timezone?: string; currencyCode: string; taxTreatment?: TaxTreatment; storageFreeDays?: number; storageFeePerDay?: string; maxPackageWeightKg?: string; maxPackageValue?: string; operatingHours?: Record<string, any>; } export interface UpdateWarehouseData { name?: string; description?: string; addressLine1?: string; addressLine2?: string; city?: string; stateProvince?: string; postalCode?: string; phone?: string; email?: string; timezone?: string; status?: WarehouseStatus; acceptsNewPackages?: boolean; taxTreatment?: TaxTreatment; storageFreeDays?: number; storageFeePerDay?: string; maxPackageWeightKg?: string; maxPackageValue?: string; operatingHours?: Record<string, any>; } export interface CreateStoragePricingData { warehouseId?: string; freeDays: number; dailyRateAfterFree: string; currency?: string; effectiveFrom: string; effectiveUntil?: string; notes?: string; } export interface UpdateStoragePricingData { freeDays?: number; dailyRateAfterFree?: string; currency?: string; effectiveFrom?: string; effectiveUntil?: string; isActive?: boolean; notes?: string; } export interface CreateBinLocationData { warehouseId: string; binCode: string; zoneName: string; description?: string; maxCapacity?: number; maxWeightKg?: string; dailyPremium?: string; currency?: string; isClimateControlled?: boolean; isSecured?: boolean; isAccessible?: boolean; } export interface UpdateBinLocationData { binCode?: string; zoneName?: string; description?: string; maxCapacity?: number; maxWeightKg?: string; dailyPremium?: string; currency?: string; isClimateControlled?: boolean; isSecured?: boolean; isAccessible?: boolean; isActive?: boolean; } export interface CreatePackageBinAssignmentData { packageId: string; binId: string; assignmentReason?: string; notes?: string; } export interface CreateStorageChargeData { packageId: string; chargeFromDate: string; chargeToDate: string; daysCharged: number; baseStorageFee: string; binLocationFee?: string; totalStorageFee: string; currency?: string; binLocationId?: string; dailyRate: string; freeDaysApplied?: number; notes?: string; }
```

# features\warehouses\db\queries\index.ts

```ts
// features/warehouse/db/queries/index.ts // Export all warehouse-related query functions // Warehouse queries export { getWarehouses } from './warehouses/get-warehouses.query'; export { getWarehouseById } from './warehouses/get-warehouse-by-id.query'; export { createWarehouse } from './warehouses/create-warehouse.query'; export { updateWarehouse } from './warehouses/update-warehouse.query'; export { deleteWarehouse } from './warehouses/delete-warehouse.query'; // // Customer warehouse assignment queries // export { getCustomerWarehouseAssignments } from './assignments/get-customer-warehouse-assignments.query'; // export { getCustomerWarehouseAssignmentById } from './assignments/get-customer-warehouse-assignment-by-id.query'; // export { createCustomerWarehouseAssignment } from './assignments/create-customer-warehouse-assignment.query'; // export { updateCustomerWarehouseAssignment } from './assignments/update-customer-warehouse-assignment.query'; // export { deleteCustomerWarehouseAssignment } from './assignments/delete-customer-warehouse-assignment.query'; // // Storage pricing queries // export { getStoragePricing } from './storage/get-storage-pricing.query'; // export { getStoragePricingById } from './storage/get-storage-pricing-by-id.query'; // export { createStoragePricing } from './storage/create-storage-pricing.query'; // export { updateStoragePricing } from './storage/update-storage-pricing.query'; // export { deleteStoragePricing } from './storage/delete-storage-pricing.query'; // export { getActiveStoragePricing } from './storage/get-active-storage-pricing.query'; // // Bin location queries // export { getBinLocations } from './bins/get-bin-locations.query'; // export { getBinLocationById } from './bins/get-bin-location-by-id.query'; // export { createBinLocation } from './bins/create-bin-location.query'; // export { updateBinLocation } from './bins/update-bin-location.query'; // export { deleteBinLocation } from './bins/delete-bin-location.query'; // export { getAvailableBinLocations } from './bins/get-available-bin-locations.query'; // // Package bin assignment queries // export { getPackageBinAssignments } from './bins/get-package-bin-assignments.query'; // export { getPackageBinAssignmentById } from './bins/get-package-bin-assignment-by-id.query'; // export { createPackageBinAssignment } from './bins/create-package-bin-assignment.query'; // export { removePackageBinAssignment } from './bins/remove-package-bin-assignment.query'; // // Storage charge queries // export { getStorageCharges } from './storage/get-storage-charges.query'; // export { getStorageChargeById } from './storage/get-storage-charge-by-id.query'; // export { createStorageCharge } from './storage/create-storage-charge.query'; // export { calculateStorageCharges } from './storage/calculate-storage-charges.query'; // export { getUnbilledStorageCharges } from './storage/get-unbilled-storage-charges.query'; // // Utility queries // export { getWarehouseStatistics } from './utils/get-warehouse-statistics.query'; // export { getWarehouseCapacity } from './utils/get-warehouse-capacity.query';
```

# features\settings\db\schema\index.ts

```ts
// features/settings/db/schema/index.ts // Settings, Countries, Currencies, Couriers, System Configuration, Addresses, and Documents // Re-export all settings-related schemas export * from './documents.schema'; export * from './addresses.schema'; import { pgTable, uuid, varchar, text, timestamp, boolean, jsonb, integer, decimal } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; // ============================================================================= // GLOBAL REFERENCE DATA // ============================================================================= export const countries = pgTable('countries', { id: uuid('id').primaryKey().defaultRandom(), code: varchar('code', { length: 2 }).unique().notNull(), name: varchar('name', { length: 100 }).notNull(), // Region information region: varchar('region', { length: 100 }), subregion: varchar('subregion', { length: 100 }), // Status flags isActive: boolean('is_active').default(true), isShippingEnabled: boolean('is_shipping_enabled').default(true), // Shipping requirements requiresPostalCode: boolean('requires_postal_code').default(true), requiresStateProvince: boolean('requires_state_province').default(false), // Customs information euMember: boolean('eu_member').default(false), customsFormType: varchar('customs_form_type', { length: 50 }), // Metadata flagEmoji: varchar('flag_emoji', { length: 10 }), phonePrefix: varchar('phone_prefix', { length: 10 }), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const currencies = pgTable('currencies', { id: uuid('id').primaryKey().defaultRandom(), code: varchar('code', { length: 3 }).unique().notNull(), name: varchar('name', { length: 100 }).notNull(), symbol: varchar('symbol', { length: 10 }).notNull(), // Status flags isActive: boolean('is_active').default(true), // Display formatting decimalPlaces: integer('decimal_places').default(2), symbolPosition: varchar('symbol_position', { length: 10 }).default('before'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const couriers = pgTable('couriers', { id: uuid('id').primaryKey().defaultRandom(), code: varchar('code', { length: 50 }).unique().notNull(), name: varchar('name', { length: 255 }).notNull(), // Contact and tracking website: varchar('website', { length: 255 }), trackingUrlTemplate: varchar('tracking_url_template', { length: 500 }), // Status flags isActive: boolean('is_active').default(true), // Integration details apiCredentials: jsonb('api_credentials'), integrationSettings: jsonb('integration_settings').default('{}'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const courierServices = pgTable('courier_services', { id: uuid('id').primaryKey().defaultRandom(), courierId: uuid('courier_id').references(() => couriers.id, { onDelete: 'cascade' }).notNull(), code: varchar('code', { length: 50 }).notNull(), name: varchar('name', { length: 255 }).notNull(), description: text('description'), // Service characteristics isExpress: boolean('is_express').default(false), isInternational: boolean('is_international').default(false), estimatedDeliveryDays: integer('estimated_delivery_days'), // Status flags isActive: boolean('is_active').default(true), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // TENANT-SPECIFIC CONFIGURATIONS // ============================================================================= export const tenantCurrencies = pgTable('tenant_currencies', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), currencyId: uuid('currency_id').references(() => currencies.id, { onDelete: 'cascade' }).notNull(), // Configuration isDefault: boolean('is_default').default(false), exchangeRate: decimal('exchange_rate', { precision: 12, scale: 6 }).default('1.0'), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const tenantCouriers = pgTable('tenant_couriers', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), courierId: uuid('courier_id').references(() => couriers.id, { onDelete: 'cascade' }).notNull(), // Status and settings isActive: boolean('is_active').default(true), contractDetails: jsonb('contract_details'), apiCredentials: text('api_credentials'), // Encrypted createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // SYSTEM CONFIGURATION // ============================================================================= export const systemSettings = pgTable('system_settings', { id: uuid('id').primaryKey().defaultRandom(), // Setting identification key: varchar('key', { length: 255 }).unique().notNull(), value: text('value').notNull(), // Metadata description: text('description'), category: varchar('category', { length: 100 }).notNull(), // Access control isPublic: boolean('is_public').default(false), isEncrypted: boolean('is_encrypted').default(false), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const tenantSettings = pgTable('tenant_settings', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // Setting identification key: varchar('key', { length: 255 }).notNull(), value: text('value').notNull(), // Metadata description: text('description'), category: varchar('category', { length: 100 }).notNull(), // Override control overridesSystemDefault: boolean('overrides_system_default').default(false), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const featureFlags = pgTable('feature_flags', { id: uuid('id').primaryKey().defaultRandom(), // Flag identification name: varchar('name', { length: 255 }).unique().notNull(), description: text('description'), // Flag status isEnabled: boolean('is_enabled').default(false), // Targeting rules tenantRules: jsonb('tenant_rules').default('[]'), userRules: jsonb('user_rules').default('[]'), // Rollout configuration rolloutPercentage: integer('rollout_percentage').default(100), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // TYPE EXPORTS // ============================================================================= // Reference data types export type Country = InferSelectModel<typeof countries>; export type NewCountry = InferInsertModel<typeof countries>; export type Currency = InferSelectModel<typeof currencies>; export type NewCurrency = InferInsertModel<typeof currencies>; export type Courier = InferSelectModel<typeof couriers>; export type NewCourier = InferInsertModel<typeof couriers>; export type CourierService = InferSelectModel<typeof courierServices>; export type NewCourierService = InferInsertModel<typeof courierServices>; // Tenant configuration types export type TenantCurrency = InferSelectModel<typeof tenantCurrencies>; export type NewTenantCurrency = InferInsertModel<typeof tenantCurrencies>; export type TenantCourier = InferSelectModel<typeof tenantCouriers>; export type NewTenantCourier = InferInsertModel<typeof tenantCouriers>; // System configuration types export type SystemSetting = InferSelectModel<typeof systemSettings>; export type NewSystemSetting = InferInsertModel<typeof systemSettings>; export type TenantSetting = InferSelectModel<typeof tenantSettings>; export type NewTenantSetting = InferInsertModel<typeof tenantSettings>; export type FeatureFlag = InferSelectModel<typeof featureFlags>; export type NewFeatureFlag = InferInsertModel<typeof featureFlags>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface CountryFilters { isActive?: boolean; isShippingEnabled?: boolean; region?: string; search?: string; page?: number; limit?: number; } export interface CurrencyFilters { isActive?: boolean; search?: string; page?: number; limit?: number; } export interface CourierFilters { isActive?: boolean; search?: string; page?: number; limit?: number; } export interface SystemSettingFilters { category?: string; isPublic?: boolean; search?: string; page?: number; limit?: number; } export interface TenantSettingFilters { category?: string; overridesSystemDefault?: boolean; search?: string; page?: number; limit?: number; } export interface FeatureFlagFilters { isEnabled?: boolean; search?: string; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateCountryData { code: string; name: string; region?: string; subregion?: string; isActive?: boolean; isShippingEnabled?: boolean; requiresPostalCode?: boolean; requiresStateProvince?: boolean; euMember?: boolean; customsFormType?: string; flagEmoji?: string; phonePrefix?: string; } export interface UpdateCountryData { name?: string; region?: string; subregion?: string; isActive?: boolean; isShippingEnabled?: boolean; requiresPostalCode?: boolean; requiresStateProvince?: boolean; euMember?: boolean; customsFormType?: string; flagEmoji?: string; phonePrefix?: string; } export interface CreateCurrencyData { code: string; name: string; symbol: string; isActive?: boolean; decimalPlaces?: number; symbolPosition?: string; } export interface UpdateCurrencyData { name?: string; symbol?: string; isActive?: boolean; decimalPlaces?: number; symbolPosition?: string; } export interface CreateCourierData { code: string; name: string; website?: string; trackingUrlTemplate?: string; isActive?: boolean; apiCredentials?: Record<string, any>; integrationSettings?: Record<string, any>; } export interface UpdateCourierData { name?: string; website?: string; trackingUrlTemplate?: string; isActive?: boolean; apiCredentials?: Record<string, any>; integrationSettings?: Record<string, any>; } export interface CreateSystemSettingData { key: string; value: string; description?: string; category: string; isPublic?: boolean; isEncrypted?: boolean; } export interface UpdateSystemSettingData { value?: string; description?: string; category?: string; isPublic?: boolean; isEncrypted?: boolean; } export interface CreateTenantSettingData { key: string; value: string; description?: string; category: string; overridesSystemDefault?: boolean; } export interface UpdateTenantSettingData { value?: string; description?: string; category?: string; overridesSystemDefault?: boolean; } export interface CreateFeatureFlagData { name: string; description?: string; isEnabled?: boolean; tenantRules?: Record<string, any>[]; userRules?: Record<string, any>[]; rolloutPercentage?: number; } export interface UpdateFeatureFlagData { description?: string; isEnabled?: boolean; tenantRules?: Record<string, any>[]; userRules?: Record<string, any>[]; rolloutPercentage?: number; } export interface CreateTenantCurrencyData { currencyId: string; isDefault?: boolean; exchangeRate?: string; } export interface UpdateTenantCurrencyData { isDefault?: boolean; exchangeRate?: string; } export interface CreateTenantCourierData { courierId: string; isActive?: boolean; contractDetails?: Record<string, any>; apiCredentials?: string; } export interface UpdateTenantCourierData { isActive?: boolean; contractDetails?: Record<string, any>; apiCredentials?: string; }
```

# features\settings\db\schema\documents.schema.ts

```ts
// features/settings/db/schema/documents.schema.ts import { pgTable, uuid, varchar, text, timestamp, integer, boolean } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; // ============================================================================= // GLOBAL DOCUMENT STORAGE // ============================================================================= export const documents = pgTable('documents', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // File information originalFileName: varchar('original_file_name', { length: 255 }).notNull(), fileName: varchar('file_name', { length: 255 }).notNull(), fileSize: integer('file_size'), mimeType: varchar('mime_type', { length: 100 }), fileUrl: varchar('file_url', { length: 500 }).notNull(), // Storage information bucket: varchar('bucket', { length: 100 }).notNull(), filePath: varchar('file_path', { length: 500 }).notNull(), isPublic: boolean('is_public').default(false), // Metadata description: text('description'), tags: text('tags'), // JSON array of tags // Upload information uploadedBy: uuid('uploaded_by'), // References users.id uploadedAt: timestamp('uploaded_at').notNull().defaultNow(), // Processing status processingStatus: varchar('processing_status', { length: 50 }).default('pending'), processedAt: timestamp('processed_at'), // Security checksum: varchar('checksum', { length: 64 }), isEncrypted: boolean('is_encrypted').default(false), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // Document types enum export const documentTypeEnum = [ 'package_photo', 'invoice', 'receipt', 'customs_form', 'delivery_confirmation', 'damage_report', 'kyc_document', 'company_registration', 'tax_certificate', 'id_document', 'passport', 'utility_bill', 'bank_statement', 'business_license', 'incorporation_doc', 'commercial_invoice', 'packing_list', 'product_photo', 'other' ] as const; export type DocumentType = typeof documentTypeEnum[number]; // ============================================================================= // ENTITY DOCUMENT ASSOCIATIONS (Polymorphic) // ============================================================================= export const entityDocuments = pgTable('entity_documents', { id: uuid('id').primaryKey().defaultRandom(), documentId: uuid('document_id').references(() => documents.id, { onDelete: 'cascade' }).notNull(), // Polymorphic reference entityType: varchar('entity_type', { length: 50 }).notNull(), // 'package', 'customer_profile', 'company', 'shipment', etc. entityId: uuid('entity_id').notNull(), // Document metadata for this entity documentType: varchar('document_type', { length: 50 }).notNull(), // Uses values from documentTypeEnum isRequired: boolean('is_required').default(false), isPrimary: boolean('is_primary').default(false), displayOrder: integer('display_order').default(0), // Context when attached attachedBy: uuid('attached_by'), // References users.id attachedAt: timestamp('attached_at').notNull().defaultNow(), notes: text('notes'), createdAt: timestamp('created_at').notNull().defaultNow(), }); export type Document = InferSelectModel<typeof documents>; export type NewDocument = InferInsertModel<typeof documents>; export type EntityDocument = InferSelectModel<typeof entityDocuments>; export type NewEntityDocument = InferInsertModel<typeof entityDocuments>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface DocumentFilters { entityType?: string; entityId?: string; documentType?: DocumentType | DocumentType[]; uploadedBy?: string; processingStatus?: string; fromDate?: string; toDate?: string; search?: string; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateDocumentData { originalFileName: string; fileName: string; fileSize?: number; mimeType?: string; fileUrl: string; bucket: string; filePath: string; isPublic?: boolean; description?: string; tags?: string[]; uploadedBy?: string; checksum?: string; isEncrypted?: boolean; } export interface CreateEntityDocumentData { entityType: string; entityId: string; documentId: string; documentType: DocumentType; isRequired?: boolean; isPrimary?: boolean; displayOrder?: number; attachedBy?: string; notes?: string; }
```

# features\settings\db\schema\addresses.schema.ts

```ts
// features/settings/db/schema/addresses.schema.ts import { pgTable, uuid, varchar, text, timestamp, boolean } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; export const addressTypeEnum = ['shipping', 'billing', 'company', 'warehouse'] as const; export type AddressType = typeof addressTypeEnum[number]; // ============================================================================= // GLOBAL ADDRESS MANAGEMENT // ============================================================================= export const addresses = pgTable('addresses', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // Address details name: varchar('name', { length: 255 }).notNull(), companyName: varchar('company_name', { length: 255 }), addressLine1: varchar('address_line1', { length: 255 }).notNull(), addressLine2: varchar('address_line2', { length: 255 }), city: varchar('city', { length: 100 }).notNull(), stateProvince: varchar('state_province', { length: 100 }), postalCode: varchar('postal_code', { length: 50 }).notNull(), countryCode: varchar('country_code', { length: 2 }).notNull(), // Contact information phone: varchar('phone', { length: 50 }), email: varchar('email', { length: 255 }), // Additional details deliveryInstructions: text('delivery_instructions'), // Status and verification isVerified: boolean('is_verified').default(false), verificationMethod: varchar('verification_method', { length: 50 }), verifiedAt: timestamp('verified_at'), // Metadata createdBy: uuid('created_by'), // References users.id createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // ENTITY ADDRESS ASSOCIATIONS (Polymorphic) // ============================================================================= export const entityAddresses = pgTable('entity_addresses', { id: uuid('id').primaryKey().defaultRandom(), addressId: uuid('address_id').references(() => addresses.id, { onDelete: 'cascade' }).notNull(), // Polymorphic reference entityType: varchar('entity_type', { length: 50 }).notNull(), // 'customer_profile', 'company', 'shipment', etc. entityId: uuid('entity_id').notNull(), // Address type for this entity addressType: varchar('address_type', { length: 20 }).notNull(), // Preferences isDefault: boolean('is_default').default(false), isActive: boolean('is_active').default(true), // Context assignedBy: uuid('assigned_by'), // References users.id assignedAt: timestamp('assigned_at').notNull().defaultNow(), createdAt: timestamp('created_at').notNull().defaultNow(), }); export type Address = InferSelectModel<typeof addresses>; export type NewAddress = InferInsertModel<typeof addresses>; export type EntityAddress = InferSelectModel<typeof entityAddresses>; export type NewEntityAddress = InferInsertModel<typeof entityAddresses>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface AddressFilters { entityType?: string; entityId?: string; addressType?: AddressType | AddressType[]; countryCode?: string; isVerified?: boolean; search?: string; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateAddressData { name: string; companyName?: string; addressLine1: string; addressLine2?: string; city: string; stateProvince?: string; postalCode: string; countryCode: string; phone?: string; email?: string; deliveryInstructions?: string; isVerified?: boolean; verificationMethod?: string; createdBy?: string; } export interface UpdateAddressData { name?: string; companyName?: string; addressLine1?: string; addressLine2?: string; city?: string; stateProvince?: string; postalCode?: string; countryCode?: string; phone?: string; email?: string; deliveryInstructions?: string; isVerified?: boolean; verificationMethod?: string; } export interface CreateEntityAddressData { entityType: string; entityId: string; addressId: string; addressType: AddressType; isDefault?: boolean; isActive?: boolean; assignedBy?: string; }
```

# features\shipping\db\schema\index.ts

```ts
// features/shipping/db/schema/index.ts // Shipping Zones, Rates, Shipments, and Carrier Integration schemas import { AddressType, addressTypeEnum, EntityAddress, NewEntityAddress } from '@/features/settings/db/schema'; import { pgTable, uuid, varchar, text, timestamp, decimal, boolean, date, jsonb } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; import { warehouses } from '@/features/warehouses/db/schema'; // ============================================================================= // ENUMS // ============================================================================= export const serviceTypeEnum = ['standard', 'express', 'economy'] as const; export const shipmentStatusEnum = [ 'quote_requested', 'quoted', 'paid', 'processing', 'dispatched', 'in_transit', 'out_for_delivery', 'delivered', 'delivery_failed', 'returned', 'cancelled', 'refunded' ] as const; export type ServiceType = typeof serviceTypeEnum[number]; export type ShipmentStatus = typeof shipmentStatusEnum[number]; // ============================================================================= // SHIPPING ZONES & RATES // ============================================================================= export const zones = pgTable('zones', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), name: varchar('name', { length: 255 }).notNull(), description: text('description'), isActive: boolean('is_active').default(true), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const zoneCountries = pgTable('zone_countries', { id: uuid('id').primaryKey().defaultRandom(), zoneId: uuid('zone_id').references(() => zones.id, { onDelete: 'cascade' }).notNull(), countryCode: varchar('country_code', { length: 2 }).notNull(), createdAt: timestamp('created_at').notNull().defaultNow(), }); export const shippingRates = pgTable('shipping_rates', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), warehouseId: uuid('warehouse_id').references(() => warehouses.id, { onDelete: 'cascade' }).notNull(), zoneId: uuid('zone_id').references(() => zones.id, { onDelete: 'cascade' }).notNull(), serviceType: varchar('service_type', { length: 20 }).notNull(), baseRate: decimal('base_rate', { precision: 10, scale: 2 }).notNull(), perKgRate: decimal('per_kg_rate', { precision: 10, scale: 2 }).notNull(), minCharge: decimal('min_charge', { precision: 10, scale: 2 }).notNull(), maxWeightKg: decimal('max_weight_kg', { precision: 8, scale: 3 }), currencyCode: varchar('currency_code', { length: 3 }).notNull().default('USD'), isActive: boolean('is_active').default(true), effectiveFrom: date('effective_from').notNull(), effectiveUntil: date('effective_until'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // SHIPMENT MANAGEMENT // ============================================================================= export const shipments = pgTable('shipments', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), customerProfileId: uuid('customer_profile_id').notNull(), // References customer_profiles.id warehouseId: uuid('warehouse_id').references(() => warehouses.id, { onDelete: 'cascade' }).notNull(), // Shipment identification shipmentNumber: varchar('shipment_number', { length: 50 }).unique().notNull(), // Destination - using polymorphic address associations // Note: Addresses are now referenced via entityAddresses table in settings feature shippingAddressId: uuid('shipping_address_id'), // Will be linked through entityAddresses billingAddressId: uuid('billing_address_id'), // Will be linked through entityAddresses companyId: uuid('company_id'), // References companies.id // Zone information for rate calculation zoneId: uuid('zone_id').references(() => zones.id), // Carrier information carrierCode: varchar('carrier_code', { length: 50 }), serviceType: varchar('service_type', { length: 100 }), trackingNumber: varchar('tracking_number', { length: 255 }), carrierReference: varchar('carrier_reference', { length: 255 }), // Shipment details totalWeightKg: decimal('total_weight_kg', { precision: 8, scale: 3 }), totalDeclaredValue: decimal('total_declared_value', { precision: 12, scale: 2 }), declaredValueCurrency: varchar('declared_value_currency', { length: 3 }).default('USD'), // Shipping costs shippingCost: decimal('shipping_cost', { precision: 10, scale: 2 }), insuranceCost: decimal('insurance_cost', { precision: 10, scale: 2 }).default('0.00'), handlingFee: decimal('handling_fee', { precision: 10, scale: 2 }).default('0.00'), storageFee: decimal('storage_fee', { precision: 10, scale: 2 }).default('0.00'), totalCost: decimal('total_cost', { precision: 10, scale: 2 }), costCurrency: varchar('cost_currency', { length: 3 }), // Rate calculation details baseShippingRate: decimal('base_shipping_rate', { precision: 10, scale: 2 }), weightShippingRate: decimal('weight_shipping_rate', { precision: 10, scale: 2 }), rateCalculationDetails: jsonb('rate_calculation_details'), // Status tracking status: varchar('status', { length: 30 }).default('quote_requested'), // Important dates quoteExpiresAt: timestamp('quote_expires_at'), paidAt: timestamp('paid_at'), dispatchedAt: timestamp('dispatched_at'), estimatedDeliveryDate: date('estimated_delivery_date'), deliveredAt: timestamp('delivered_at'), // Customs and compliance customsDeclaration: jsonb('customs_declaration').default('{}'), commercialInvoiceUrl: varchar('commercial_invoice_url', { length: 500 }), customsStatus: varchar('customs_status', { length: 30 }).default('pending'), // Special handling requiresSignature: boolean('requires_signature').default(false), deliveryInstructions: text('delivery_instructions'), // Processing createdBy: uuid('created_by'), // References users.id processedBy: uuid('processed_by'), // References users.id createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const shipmentPackages = pgTable('shipment_packages', { id: uuid('id').primaryKey().defaultRandom(), shipmentId: uuid('shipment_id').references(() => shipments.id, { onDelete: 'cascade' }).notNull(), packageId: uuid('package_id').notNull(), // References packages.id declaredValue: decimal('declared_value', { precision: 12, scale: 2 }), declaredDescription: text('declared_description'), createdAt: timestamp('created_at').notNull().defaultNow(), }); export const shipmentTrackingEvents = pgTable('shipment_tracking_events', { id: uuid('id').primaryKey().defaultRandom(), shipmentId: uuid('shipment_id').references(() => shipments.id, { onDelete: 'cascade' }).notNull(), eventCode: varchar('event_code', { length: 50 }).notNull(), eventDescription: text('event_description').notNull(), location: varchar('location', { length: 255 }), eventTimestamp: timestamp('event_timestamp').notNull(), source: varchar('source', { length: 50 }).default('manual'), rawData: jsonb('raw_data'), createdAt: timestamp('created_at').notNull().defaultNow(), }); export const shipmentStatusHistory = pgTable('shipment_status_history', { id: uuid('id').primaryKey().defaultRandom(), shipmentId: uuid('shipment_id').references(() => shipments.id, { onDelete: 'cascade' }).notNull(), status: varchar('status', { length: 30 }).notNull(), previousStatus: varchar('previous_status', { length: 30 }), notes: text('notes'), changedBy: uuid('changed_by'), // References users.id changedAt: timestamp('changed_at').notNull().defaultNow(), // Additional context trackingNumber: varchar('tracking_number', { length: 255 }), carrierName: varchar('carrier_name', { length: 255 }), createdAt: timestamp('created_at').notNull().defaultNow(), }); // ============================================================================= // TYPE EXPORTS // ============================================================================= // Zone types export type Zone = InferSelectModel<typeof zones>; export type NewZone = InferInsertModel<typeof zones>; export type ZoneCountry = InferSelectModel<typeof zoneCountries>; export type NewZoneCountry = InferInsertModel<typeof zoneCountries>; // Rate types export type ShippingRate = InferSelectModel<typeof shippingRates>; export type NewShippingRate = InferInsertModel<typeof shippingRates>; // Shipment types export type Shipment = InferSelectModel<typeof shipments>; export type NewShipment = InferInsertModel<typeof shipments>; export type ShipmentPackage = InferSelectModel<typeof shipmentPackages>; export type NewShipmentPackage = InferInsertModel<typeof shipmentPackages>; export type ShipmentTrackingEvent = InferSelectModel<typeof shipmentTrackingEvents>; export type NewShipmentTrackingEvent = InferInsertModel<typeof shipmentTrackingEvents>; export type ShipmentStatusHistory = InferSelectModel<typeof shipmentStatusHistory>; export type NewShipmentStatusHistory = InferInsertModel<typeof shipmentStatusHistory>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface ZoneFilters { isActive?: boolean; search?: string; page?: number; limit?: number; } export interface ShippingRateFilters { warehouseId?: string; zoneId?: string; serviceType?: ServiceType; isActive?: boolean; effectiveDate?: string; page?: number; limit?: number; } export interface ShipmentFilters { status?: ShipmentStatus | ShipmentStatus[]; customerProfileId?: string; warehouseId?: string; zoneId?: string; carrierCode?: string; search?: string; fromDate?: string; toDate?: string; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateZoneData { name: string; description?: string; isActive?: boolean; countryIds?: string[]; } export interface UpdateZoneData { name?: string; description?: string; isActive?: boolean; countryIds?: string[]; } export interface CreateShippingRateData { warehouseId: string; zoneId: string; serviceType: ServiceType; baseRate: string; perKgRate: string; minCharge: string; maxWeightKg?: string; currencyCode?: string; effectiveFrom: string; effectiveUntil?: string; } export interface UpdateShippingRateData { serviceType?: ServiceType; baseRate?: string; perKgRate?: string; minCharge?: string; maxWeightKg?: string; currencyCode?: string; isActive?: boolean; effectiveFrom?: string; effectiveUntil?: string; } export interface CreateShipmentData { customerProfileId: string; warehouseId: string; shipmentNumber: string; shippingAddressId?: string; billingAddressId?: string; companyId?: string; zoneId?: string; carrierCode?: string; serviceType?: string; totalWeightKg?: string; totalDeclaredValue?: string; declaredValueCurrency?: string; requiresSignature?: boolean; deliveryInstructions?: string; packageIds: string[]; } export interface UpdateShipmentData { shippingAddressId?: string; billingAddressId?: string; companyId?: string; zoneId?: string; carrierCode?: string; serviceType?: string; trackingNumber?: string; carrierReference?: string; totalWeightKg?: string; totalDeclaredValue?: string; declaredValueCurrency?: string; shippingCost?: string; insuranceCost?: string; handlingFee?: string; storageFee?: string; totalCost?: string; costCurrency?: string; status?: ShipmentStatus; quoteExpiresAt?: string; estimatedDeliveryDate?: string; customsDeclaration?: Record<string, any>; commercialInvoiceUrl?: string; customsStatus?: string; requiresSignature?: boolean; deliveryInstructions?: string; } export interface CreateShipmentTrackingEventData { shipmentId: string; eventCode: string; eventDescription: string; location?: string; eventTimestamp: string; source?: string; rawData?: Record<string, any>; }
```

# features\packages\db\schema\index.ts

```ts
// features/packages/db/schema/index.ts // Enhanced Package Management schemas (Packages, Incoming Shipments) // Documents moved to settings feature for polymorphic access import { pgTable, uuid, varchar, text, timestamp, decimal, integer, boolean, date } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; import { warehouses } from '@/features/warehouses/db/schema'; import { documentTypeEnum as settingsDocumentTypeEnum, DocumentType as SettingsDocumentType, EntityDocument, NewEntityDocument } from '@/features/settings/db/schema'; // ============================================================================= // ENUMS // ============================================================================= export const packageStatusEnum = [ 'expected', 'received', 'processing', 'ready_to_ship', 'shipped', 'delivered', 'returned', 'disposed', 'missing', 'damaged', 'held' ] as const; export const incomingShipmentStatusEnum = [ 'pending', 'scanning', 'scanned', 'assigned', 'received', 'expected' ] as const; export const itemAssignmentStatusEnum = [ 'unassigned', 'assigned', 'received' ] as const; export type PackageStatus = typeof packageStatusEnum[number]; export type IncomingShipmentStatus = typeof incomingShipmentStatusEnum[number]; export type ItemAssignmentStatus = typeof itemAssignmentStatusEnum[number]; // ============================================================================= // INCOMING SHIPMENT PROCESSING // ============================================================================= export const incomingShipments = pgTable('incoming_shipments', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), warehouseId: uuid('warehouse_id').references(() => warehouses.id, { onDelete: 'cascade' }).notNull(), // Shipment identification batchReference: varchar('batch_reference', { length: 100 }).notNull(), // Courier info courierId: uuid('courier_id'), // References couriers.id courierName: varchar('courier_name', { length: 255 }), trackingNumber: varchar('tracking_number', { length: 255 }), // Dates arrivalDate: date('arrival_date'), expectedArrivalDate: date('expected_arrival_date'), actualArrivalDate: date('actual_arrival_date'), // Status and processing status: varchar('status', { length: 20 }).default('pending'), receivedBy: uuid('received_by'), // References users.id receivedAt: timestamp('received_at'), processedBy: uuid('processed_by'), // References users.id processedAt: timestamp('processed_at'), // Metadata notes: text('notes'), totalItems: integer('total_items').default(0), processedItems: integer('processed_items').default(0), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const incomingShipmentItems = pgTable('incoming_shipment_items', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), warehouseId: uuid('warehouse_id').references(() => warehouses.id, { onDelete: 'cascade' }).notNull(), incomingShipmentId: uuid('incoming_shipment_id').references(() => incomingShipments.id, { onDelete: 'cascade' }).notNull(), // Tracking and courier info trackingNumber: varchar('tracking_number', { length: 255 }), courierName: varchar('courier_name', { length: 255 }), courierTrackingUrl: varchar('courier_tracking_url', { length: 500 }), // Scanning info scannedBy: uuid('scanned_by'), // References users.id scannedAt: timestamp('scanned_at'), // Assignment info assignedCustomerProfileId: uuid('assigned_customer_profile_id'), // References customer_profiles.id assignedBy: uuid('assigned_by'), // References users.id assignedAt: timestamp('assigned_at'), assignmentStatus: varchar('assignment_status', { length: 20 }).default('pending'), // Physical properties weightKg: decimal('weight_kg', { precision: 8, scale: 3 }), lengthCm: decimal('length_cm', { precision: 8, scale: 2 }), widthCm: decimal('width_cm', { precision: 8, scale: 2 }), heightCm: decimal('height_cm', { precision: 8, scale: 2 }), // Package info description: text('description'), estimatedValue: decimal('estimated_value', { precision: 12, scale: 2 }), estimatedValueCurrency: varchar('estimated_value_currency', { length: 3 }).default('USD'), // Processing notes notes: text('notes'), specialInstructions: text('special_instructions'), // Status flags isFragile: boolean('is_fragile').default(false), isHighValue: boolean('is_high_value').default(false), requiresInspection: boolean('requires_inspection').default(false), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // ENHANCED PACKAGE MANAGEMENT // ============================================================================= export const packages = pgTable('packages', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), customerProfileId: uuid('customer_profile_id').notNull(), // References customer_profiles.id warehouseId: uuid('warehouse_id').references(() => warehouses.id, { onDelete: 'cascade' }).notNull(), // Link to incoming shipment item incomingShipmentItemId: uuid('incoming_shipment_item_id').references(() => incomingShipmentItems.id), // Package identification internalId: varchar('internal_id', { length: 50 }).unique().notNull(), suiteCodeCaptured: varchar('suite_code_captured', { length: 50 }), // Inbound tracking trackingNumberInbound: varchar('tracking_number_inbound', { length: 255 }), senderName: varchar('sender_name', { length: 255 }), senderCompany: varchar('sender_company', { length: 255 }), senderTrackingUrl: varchar('sender_tracking_url', { length: 500 }), // Package details description: text('description'), estimatedValue: decimal('estimated_value', { precision: 12, scale: 2 }).default('0'), estimatedValueCurrency: varchar('estimated_value_currency', { length: 3 }).default('USD'), // Physical properties weightActualKg: decimal('weight_actual_kg', { precision: 8, scale: 3 }), lengthCm: decimal('length_cm', { precision: 8, scale: 2 }), widthCm: decimal('width_cm', { precision: 8, scale: 2 }), heightCm: decimal('height_cm', { precision: 8, scale: 2 }), volumetricWeightKg: decimal('volumetric_weight_kg', { precision: 8, scale: 3 }), chargeableWeightKg: decimal('chargeable_weight_kg', { precision: 8, scale: 3 }), // Status and dates status: varchar('status', { length: 20 }).default('expected'), expectedArrivalDate: date('expected_arrival_date'), receivedAt: timestamp('received_at'), readyToShipAt: timestamp('ready_to_ship_at'), storageExpiresAt: timestamp('storage_expires_at'), // Notes and instructions warehouseNotes: text('warehouse_notes'), customerNotes: text('customer_notes'), specialInstructions: text('special_instructions'), // Package characteristics isFragile: boolean('is_fragile').default(false), isHighValue: boolean('is_high_value').default(false), requiresAdultSignature: boolean('requires_adult_signature').default(false), isRestricted: boolean('is_restricted').default(false), // Processing info processedBy: uuid('processed_by'), // References users.id processedAt: timestamp('processed_at'), // Customs information customsDeclaration: text('customs_declaration'), customsValue: decimal('customs_value', { precision: 12, scale: 2 }), customsValueCurrency: varchar('customs_value_currency', { length: 3 }), countryOfOrigin: varchar('country_of_origin', { length: 2 }), hsCode: varchar('hs_code', { length: 20 }), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const packageStatusHistory = pgTable('package_status_history', { id: uuid('id').primaryKey().defaultRandom(), packageId: uuid('package_id').references(() => packages.id, { onDelete: 'cascade' }).notNull(), status: varchar('status', { length: 20 }).notNull(), previousStatus: varchar('previous_status', { length: 20 }), notes: text('notes'), changedBy: uuid('changed_by'), // References users.id changeReason: varchar('change_reason', { length: 255 }), // Additional context locationId: uuid('location_id'), // References bin_locations.id if applicable metadata: text('metadata'), // JSON string for additional data createdAt: timestamp('created_at').notNull().defaultNow(), }); // ============================================================================= // TYPE EXPORTS // ============================================================================= // Incoming shipment types export type IncomingShipment = InferSelectModel<typeof incomingShipments>; export type NewIncomingShipment = InferInsertModel<typeof incomingShipments>; export type IncomingShipmentItem = InferSelectModel<typeof incomingShipmentItems>; export type NewIncomingShipmentItem = InferInsertModel<typeof incomingShipmentItems>; // Package types export type Package = InferSelectModel<typeof packages>; export type NewPackage = InferInsertModel<typeof packages>; export type PackageStatusHistory = InferSelectModel<typeof packageStatusHistory>; export type NewPackageStatusHistory = InferInsertModel<typeof packageStatusHistory>; // Legacy type aliases for backward compatibility export type PackageDocument = EntityDocument; export type NewPackageDocument = NewEntityDocument; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface IncomingShipmentFilters { status?: IncomingShipmentStatus | IncomingShipmentStatus[]; warehouseId?: string; courierId?: string; courierName?: string; batchReference?: string; fromDate?: string; toDate?: string; search?: string; page?: number; limit?: number; } export interface IncomingShipmentItemFilters { incomingShipmentId?: string; assignmentStatus?: ItemAssignmentStatus | ItemAssignmentStatus[]; assignedCustomerProfileId?: string; scannedBy?: string; isFragile?: boolean; isHighValue?: boolean; requiresInspection?: boolean; search?: string; page?: number; limit?: number; } export interface PackageFilters { status?: PackageStatus | PackageStatus[]; customerProfileId?: string; warehouseId?: string; incomingShipmentItemId?: string; search?: string; trackingNumberInbound?: string; internalId?: string; senderName?: string; isFragile?: boolean; isHighValue?: boolean; isRestricted?: boolean; fromDate?: string; toDate?: string; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateIncomingShipmentData { warehouseId: string; batchReference: string; courierId?: string; courierName?: string; trackingNumber?: string; arrivalDate?: string; expectedArrivalDate?: string; notes?: string; } export interface UpdateIncomingShipmentData { batchReference?: string; courierId?: string; courierName?: string; trackingNumber?: string; arrivalDate?: string; expectedArrivalDate?: string; actualArrivalDate?: string; status?: IncomingShipmentStatus; receivedBy?: string; receivedAt?: string; processedBy?: string; processedAt?: string; notes?: string; } export interface CreateIncomingShipmentItemData { incomingShipmentId: string; trackingNumber?: string; courierName?: string; courierTrackingUrl?: string; assignedCustomerProfileId?: string; weightKg?: string; lengthCm?: string; widthCm?: string; heightCm?: string; description?: string; estimatedValue?: string; estimatedValueCurrency?: string; notes?: string; specialInstructions?: string; isFragile?: boolean; isHighValue?: boolean; requiresInspection?: boolean; } export interface CreatePackageData { customerProfileId: string; warehouseId: string; internalId: string; incomingShipmentItemId?: string; suiteCodeCaptured?: string; trackingNumberInbound?: string; senderName?: string; senderCompany?: string; senderTrackingUrl?: string; description?: string; estimatedValue?: string; estimatedValueCurrency?: string; weightActualKg?: string; lengthCm?: string; widthCm?: string; heightCm?: string; status?: PackageStatus; expectedArrivalDate?: string; warehouseNotes?: string; customerNotes?: string; specialInstructions?: string; isFragile?: boolean; isHighValue?: boolean; requiresAdultSignature?: boolean; isRestricted?: boolean; customsDeclaration?: string; customsValue?: string; customsValueCurrency?: string; countryOfOrigin?: string; hsCode?: string; } export interface UpdatePackageData { suiteCodeCaptured?: string; trackingNumberInbound?: string; senderName?: string; senderCompany?: string; senderTrackingUrl?: string; description?: string; estimatedValue?: string; estimatedValueCurrency?: string; weightActualKg?: string; lengthCm?: string; widthCm?: string; heightCm?: string; volumetricWeightKg?: string; chargeableWeightKg?: string; status?: PackageStatus; expectedArrivalDate?: string; receivedAt?: string; readyToShipAt?: string; storageExpiresAt?: string; warehouseNotes?: string; customerNotes?: string; specialInstructions?: string; isFragile?: boolean; isHighValue?: boolean; requiresAdultSignature?: boolean; isRestricted?: boolean; processedBy?: string; processedAt?: string; customsDeclaration?: string; customsValue?: string; customsValueCurrency?: string; countryOfOrigin?: string; hsCode?: string; }
```

# features\tenancy\db\schema\tenancy.schema.ts

```ts

```

# features\packages\db\queries\update-packages-status.query.ts

```ts
// features/packages/db/queries/update-packages-status.query.ts import { db } from '@/lib/db'; import { packages } from '@/features/packages/db/schema/package.schema'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { inArray, eq } from 'drizzle-orm'; import type { PackageStatus } from '../../types/package.types'; import { transformPackageWithCustomerName } from './transform-package.query'; /** * Update status of multiple packages at once */ export async function updatePackagesStatus(ids: string[], status: PackageStatus) { // Check if all packages exist const existingPackages = await db .select({ id: packages.id }) .from(packages) .where(inArray(packages.id, ids)); if (existingPackages.length !== ids.length) { return { success: false, message: 'One or more packages not found', status: 404 }; } // Update package statuses const updatedPackages = await db .update(packages) .set({ status: status, updatedAt: new Date(), }) .where(inArray(packages.id, ids)) .returning(); // Get updated packages with customer information const packagesWithCustomers = await db .select({ package: packages, customerName: customers.name, }) .from(packages) .leftJoin(customers, eq(packages.customerId, customers.id)) .where(inArray(packages.id, ids)); // Transform data to match frontend expectations const transformedPackages = packagesWithCustomers.map((result) => transformPackageWithCustomerName(result.package, result.customerName || 'Unknown Customer') ); return { success: true, data: transformedPackages, message: `Successfully updated ${updatedPackages.length} packages to ${status}`, }; }
```

# features\packages\db\queries\update-package.query.ts

```ts
// features/packages/db/queries/update-package.query.ts import { db } from '@/lib/db'; import { packages } from '@/features/packages/db/schema/package.schema'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { eq } from 'drizzle-orm'; import type { Package, UpdatePackageData } from '../../types/package.types'; import { transformPackageWithCustomerName } from './transform-package.query'; /** * Update an existing package */ export async function updatePackage(id: string, data: UpdatePackageData): Promise<Package | null> { // Check if package exists const existingPackage = await db .select() .from(packages) .where(eq(packages.id, id)) .limit(1); if (existingPackage.length === 0) { return null; } // Prepare update data const updateData: any = { updatedAt: new Date(), }; if (data.status !== undefined) { updateData.status = data.status; } if (data.weight !== undefined) { updateData.weight = data.weight || null; } if (data.dimensions !== undefined) { if (data.dimensions !== null && typeof data.dimensions === 'object') { // Handle object format { length: number, width: number, height: number } const dims = data.dimensions as { length: number; width: number; height: number }; updateData.dimensions = `${dims.length}x${dims.width}x${dims.height}cm`; } else { // Handle string or null case updateData.dimensions = data.dimensions; } } // Update package const [updatedPackage] = await db .update(packages) .set(updateData) .where(eq(packages.id, id)) .returning(); // Get customer name for response const customerResult = await db .select({ name: customers.name }) .from(customers) .where(eq(customers.id, updatedPackage.customerId)) .limit(1); const customerName = customerResult.length > 0 ? customerResult[0].name : 'Unknown Customer'; return transformPackageWithCustomerName(updatedPackage, customerName); }
```

# features\packages\db\queries\transform-package.query.ts

```ts
// features/packages/db/queries/transform-package.query.ts import type { Package } from '../../types/package.types'; import type { Package as DbPackage } from '../schema/package.schema'; /** * Transform a database package record into the expected API format * with customer name included */ export function transformPackageWithCustomerName( packageData: DbPackage, customerName: string ): Package { return { id: packageData.id, trackingNumber: packageData.trackingNumber, customerId: packageData.customerId, customerName, status: packageData.status, weight: packageData.weight, dimensions: packageData.dimensions, origin: packageData.origin, destination: packageData.destination, estimatedDelivery: packageData.estimatedDelivery?.toISOString() || null, createdAt: packageData.createdAt.toISOString(), updatedAt: packageData.updatedAt.toISOString(), }; } /** * Transform a database package record into the expected API format */ export function transformPackage(packageData: DbPackage): Package { return { id: packageData.id, trackingNumber: packageData.trackingNumber, customerId: packageData.customerId, status: packageData.status, weight: packageData.weight, dimensions: packageData.dimensions, origin: packageData.origin, destination: packageData.destination, estimatedDelivery: packageData.estimatedDelivery?.toISOString() || null, createdAt: packageData.createdAt.toISOString(), updatedAt: packageData.updatedAt.toISOString(), }; }
```

# features\packages\db\queries\search-packages.query.ts

```ts
// features/packages/db/queries/search-packages.query.ts import { db } from '@/lib/db'; import { packages } from '@/features/packages/db/schema/package.schema'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { eq, desc, sql } from 'drizzle-orm'; import type { Package } from '../../types/package.types'; import { transformPackage } from './transform-package.query'; /** * Search packages */ export async function searchPackages(query: string): Promise<Package[]> { const searchResults = await db .select({ id: packages.id, trackingNumber: packages.trackingNumber, customerId: packages.customerId, customerName: customers.name, status: packages.status, weight: packages.weight, dimensions: packages.dimensions, origin: packages.origin, destination: packages.destination, estimatedDelivery: packages.estimatedDelivery, createdAt: packages.createdAt, updatedAt: packages.updatedAt, }) .from(packages) .leftJoin(customers, eq(packages.customerId, customers.id)) .where( sql`(${packages.trackingNumber} ILIKE ${`%${query}%`} OR ${customers.name} ILIKE ${`%${query}%`})` ) .orderBy(desc(packages.createdAt)) .limit(20); return searchResults.map(transformPackage); }
```

# features\packages\db\queries\index.ts

```ts
// features/packages/db/queries/index.ts export { getPackages } from './get-packages.query'; export { getPackageById } from './get-package-by-id.query'; export { createPackage } from './create-package.query'; export { updatePackage } from './update-package.query'; export { deletePackage } from './delete-package.query'; export { bulkUpdateStatus } from './bulk-update-status.query'; export { searchPackages } from './search-packages.query'; export { transformPackage, transformPackageWithCustomerName } from './transform-package.query';
```

# features\packages\db\queries\get-packages.query.ts

```ts
// features/packages/db/queries/get-packages.query.ts import { db } from '@/lib/db'; import { packages } from '@/features/packages/db/schema/package.schema'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { eq, and, desc, sql } from 'drizzle-orm'; import type { PackageFilters } from '../../types/package.types'; import { transformPackage } from './transform-package.query'; export async function getPackages(filters: PackageFilters = {}) { const { page = 1, limit = 10, status, search, customerId } = filters; const conditions = []; if (status && status !== 'all') { conditions.push(eq(packages.status, status as any)); } if (customerId) { conditions.push(eq(packages.customerId, customerId)); } if (search) { conditions.push( sql`(${packages.trackingNumber} ILIKE ${`%${search}%`} OR ${customers.name} ILIKE ${`%${search}%`})` ); } // Create base query without where clause const baseQuery = db .select({ id: packages.id, trackingNumber: packages.trackingNumber, customerId: packages.customerId, customerName: customers.name, status: packages.status, weight: packages.weight, dimensions: packages.dimensions, origin: packages.origin, destination: packages.destination, estimatedDelivery: packages.estimatedDelivery, createdAt: packages.createdAt, updatedAt: packages.updatedAt, }) .from(packages) .leftJoin(customers, eq(packages.customerId, customers.id)); // Apply conditions to the base query const finalQuery = conditions.length > 0 ? baseQuery.where(and(...conditions)) : baseQuery; // Add ordering to the final query const orderedQuery = finalQuery.orderBy(desc(packages.createdAt)); const allPackages = await orderedQuery; // Pagination logic remains the same const total = allPackages.length; const pages = Math.ceil(total / limit); const startIndex = (page - 1) * limit; const endIndex = startIndex + limit; const paginatedPackages = allPackages.slice(startIndex, endIndex); const transformedPackages = paginatedPackages.map(transformPackage); return { data: transformedPackages, pagination: { page, limit, total, pages }, }; }
```

# features\packages\db\queries\get-package-by-id.query.ts

```ts
// features/packages/db/queries/get-package-by-id.query.ts import { db } from '@/lib/db'; import { packages } from '@/features/packages/db/schema/package.schema'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { eq } from 'drizzle-orm'; import type { Package } from '../../types/package.types'; import { transformPackage } from './transform-package.query'; /** * Get a single package by ID */ export async function getPackageById(id: string): Promise<Package | null> { const packageResult = await db .select({ id: packages.id, trackingNumber: packages.trackingNumber, customerId: packages.customerId, customerName: customers.name, status: packages.status, weight: packages.weight, dimensions: packages.dimensions, origin: packages.origin, destination: packages.destination, estimatedDelivery: packages.estimatedDelivery, createdAt: packages.createdAt, updatedAt: packages.updatedAt, }) .from(packages) .leftJoin(customers, eq(packages.customerId, customers.id)) .where(eq(packages.id, id)) .limit(1); if (packageResult.length === 0) { return null; } return transformPackage(packageResult[0]); }
```

# features\packages\db\queries\delete-package.query.ts

```ts
// features/packages/db/queries/delete-package.query.ts import { db } from '@/lib/db'; import { packages } from '@/features/packages/db/schema/package.schema'; import { eq } from 'drizzle-orm'; /** * Delete a package */ export async function deletePackage(id: string): Promise<boolean> { // Check if package exists const existingPackage = await db .select() .from(packages) .where(eq(packages.id, id)) .limit(1); if (existingPackage.length === 0) { return false; } // Delete package await db.delete(packages).where(eq(packages.id, id)); return true; }
```

# features\packages\db\queries\create-package.query.ts

```ts
// features/packages/db/queries/create-package.query.ts import { db } from '@/lib/db'; import { packages } from '@/features/packages/db/schema/package.schema'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { eq } from 'drizzle-orm'; import type { Package, CreatePackageData } from '../../types/package.types'; import { transformPackageWithCustomerName } from './transform-package.query'; /** * Create a new package */ export async function createPackage(data: CreatePackageData): Promise<Package> { // Check if customer exists const customerExists = await db .select() .from(customers) .where(eq(customers.id, data.customerId)) .limit(1); if (customerExists.length === 0) { throw new Error('Customer not found'); } // Check if tracking number already exists const existingPackage = await db .select() .from(packages) .where(eq(packages.trackingNumber, data.trackingNumber)) .limit(1); if (existingPackage.length > 0) { throw new Error('Package with this tracking number already exists'); } // Create new package const newPackageData = { trackingNumber: data.trackingNumber, customerId: data.customerId, status: data.status || 'pending' as const, weight: data.weight || null, dimensions: data.dimensions || null, origin: data.origin || null, destination: data.destination, estimatedDelivery: data.estimatedDelivery ? new Date(data.estimatedDelivery) : null, }; const [newPackage] = await db .insert(packages) .values(newPackageData) .returning(); // Get customer name for response const customer = customerExists[0]; return transformPackageWithCustomerName(newPackage, customer.name); }
```

# features\packages\db\queries\bulk-update-status.query.ts

```ts
// features/packages/db/queries/bulk-update-status.query.ts import { db } from '@/lib/db'; import { packages } from '@/features/packages/db/schema/package.schema'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { eq, inArray } from 'drizzle-orm'; import type { Package } from '../../types/package.types'; import { transformPackage } from './transform-package.query'; /** * Update package status (bulk operation) */ export async function bulkUpdateStatus(ids: string[], status: string): Promise<Package[]> { // Validate status const validStatuses = ['pending', 'processing', 'shipped', 'delivered', 'returned']; if (!validStatuses.includes(status)) { throw new Error('Invalid status value'); } // Check if all packages exist const existingPackages = await db .select({ id: packages.id }) .from(packages) .where(inArray(packages.id, ids)); if (existingPackages.length !== ids.length) { throw new Error('One or more packages not found'); } // Update package statuses await db .update(packages) .set({ status: status as any, updatedAt: new Date(), }) .where(inArray(packages.id, ids)); // Get updated packages with customer information const updatedPackages = await db .select({ id: packages.id, trackingNumber: packages.trackingNumber, customerId: packages.customerId, customerName: customers.name, status: packages.status, weight: packages.weight, dimensions: packages.dimensions, origin: packages.origin, destination: packages.destination, estimatedDelivery: packages.estimatedDelivery, createdAt: packages.createdAt, updatedAt: packages.updatedAt, }) .from(packages) .leftJoin(customers, eq(packages.customerId, customers.id)) .where(inArray(packages.id, ids)); return updatedPackages.map(transformPackage); }
```

# features\customers\db\schema\index.ts

```ts
// features/customers/db/schema/index.ts // Enhanced Customer Management schemas (Profiles and Companies only - Addresses moved to Settings) import { AddressType, addressTypeEnum, EntityAddress, NewEntityAddress } from '@/features/settings/db/schema'; import { pgTable, uuid, varchar, text, timestamp, decimal, integer, jsonb, date, boolean } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; import { users } from '@/features/auth/db/schema'; // Enums export const kycStatusEnum = ['not_required', 'pending', 'approved', 'rejected'] as const; export const riskLevelEnum = ['low', 'medium', 'high'] as const; export const companyTypeEnum = ['LLC', 'Corp', 'Ltd', 'Partnership', 'Sole_Proprietorship', 'Other'] as const; export const verificationStatusEnum = ['unverified', 'pending', 'verified', 'rejected'] as const; export type KycStatus = typeof kycStatusEnum[number]; export type RiskLevel = typeof riskLevelEnum[number]; export type CompanyType = typeof companyTypeEnum[number]; export type VerificationStatus = typeof verificationStatusEnum[number]; // ============================================================================= // CUSTOMER MANAGEMENT SCHEMA // ============================================================================= export const customerProfiles = pgTable('customer_profiles', { id: uuid('id').primaryKey().defaultRandom(), userId: uuid('user_id').unique().references(() => users.id, { onDelete: 'cascade' }).notNull(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // Unique customer identifier customerId: varchar('customer_id', { length: 50 }).unique().notNull(), // Personal details dateOfBirth: date('date_of_birth'), nationality: varchar('nationality', { length: 2 }), idNumber: varchar('id_number', { length: 100 }), // KYC/Compliance kycStatus: varchar('kyc_status', { length: 20 }).default('not_required'), kycDocuments: jsonb('kyc_documents').default('[]'), kycNotes: text('kyc_notes'), kycVerifiedAt: timestamp('kyc_verified_at'), kycVerifiedBy: uuid('kyc_verified_by').references(() => users.id), // Risk assessment riskLevel: varchar('risk_level', { length: 10 }).default('low'), riskNotes: text('risk_notes'), lastRiskAssessment: timestamp('last_risk_assessment'), // Customer lifetime value tracking totalSpent: decimal('total_spent', { precision: 12, scale: 2 }).default('0.00'), totalPackages: integer('total_packages').default(0), totalShipments: integer('total_shipments').default(0), averagePackageValue: decimal('average_package_value', { precision: 12, scale: 2 }).default('0.00'), // Subscription & Billing stripeCustomerId: varchar('stripe_customer_id', { length: 255 }), stripeSubscriptionId: varchar('stripe_subscription_id', { length: 255 }), stripeProductId: varchar('stripe_product_id', { length: 255 }), planName: varchar('plan_name', { length: 100 }), planFeatures: jsonb('plan_features').default('{}'), subscriptionStatus: varchar('subscription_status', { length: 50 }).default('inactive'), subscriptionStartedAt: timestamp('subscription_started_at'), subscriptionEndsAt: timestamp('subscription_ends_at'), // Referral system referralCode: varchar('referral_code', { length: 50 }).unique(), referredBy: uuid('referred_by'), // Self-reference to customer_profiles referralReward: decimal('referral_reward', { precision: 8, scale: 2 }).default('0.00'), totalReferrals: integer('total_referrals').default(0), // Preferences preferredCurrency: varchar('preferred_currency', { length: 3 }).default('USD'), communicationPreferences: jsonb('communication_preferences').default('{}'), shippingPreferences: jsonb('shipping_preferences').default('{}'), // Customer service customerServiceNotes: text('customer_service_notes'), isVip: boolean('is_vip').default(false), vipSince: timestamp('vip_since'), // Account status accountStatus: varchar('account_status', { length: 20 }).default('active'), // active, suspended, closed suspensionReason: text('suspension_reason'), suspendedAt: timestamp('suspended_at'), suspendedBy: uuid('suspended_by').references(() => users.id), // Marketing marketingOptIn: boolean('marketing_opt_in').default(true), smsOptIn: boolean('sms_opt_in').default(false), emailOptIn: boolean('email_opt_in').default(true), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const companies = pgTable('companies', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), ownerId: uuid('owner_id').references(() => customerProfiles.id, { onDelete: 'cascade' }).notNull(), // Company details name: varchar('name', { length: 255 }).notNull(), legalName: varchar('legal_name', { length: 255 }), registrationNumber: varchar('registration_number', { length: 100 }), taxNumber: varchar('tax_number', { length: 100 }), taxNumberType: varchar('tax_number_type', { length: 50 }), vatNumber: varchar('vat_number', { length: 100 }), // Business information companyType: varchar('company_type', { length: 30 }), industry: varchar('industry', { length: 100 }), businessDescription: text('business_description'), yearEstablished: integer('year_established'), numberOfEmployees: varchar('number_of_employees', { length: 20 }), annualRevenue: varchar('annual_revenue', { length: 20 }), // Contact details website: varchar('website', { length: 255 }), primaryContactName: varchar('primary_contact_name', { length: 255 }), primaryContactTitle: varchar('primary_contact_title', { length: 100 }), primaryContactEmail: varchar('primary_contact_email', { length: 255 }), primaryContactPhone: varchar('primary_contact_phone', { length: 50 }), // Legal and compliance verificationStatus: varchar('verification_status', { length: 20 }).default('unverified'), verificationDocuments: jsonb('verification_documents').default('[]'), verifiedAt: timestamp('verified_at'), verifiedBy: uuid('verified_by').references(() => users.id), verificationNotes: text('verification_notes'), // Business settings showInAddress: boolean('show_in_address').default(false), useForCustoms: boolean('use_for_customs').default(false), customsExporterNumber: varchar('customs_exporter_number', { length: 100 }), // Financial creditLimit: decimal('credit_limit', { precision: 12, scale: 2 }), creditTerms: varchar('credit_terms', { length: 50 }), paymentTerms: varchar('payment_terms', { length: 50 }).default('net_30'), // Account management accountManagerId: uuid('account_manager_id').references(() => users.id), isActive: boolean('is_active').default(true), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // Customer communication log export const customerCommunications = pgTable('customer_communications', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), customerProfileId: uuid('customer_profile_id').references(() => customerProfiles.id, { onDelete: 'cascade' }).notNull(), // Communication details communicationType: varchar('communication_type', { length: 50 }).notNull(), // email, phone, chat, meeting direction: varchar('direction', { length: 10 }).notNull(), // inbound, outbound subject: varchar('subject', { length: 255 }), content: text('content'), // Participants staffMemberId: uuid('staff_member_id').references(() => users.id), externalParticipants: jsonb('external_participants').default('[]'), // Metadata duration: integer('duration'), // in minutes for calls/meetings outcome: varchar('outcome', { length: 100 }), followUpRequired: boolean('follow_up_required').default(false), followUpDate: timestamp('follow_up_date'), // Reference referenceType: varchar('reference_type', { length: 50 }), // package, shipment, invoice, etc. referenceId: uuid('reference_id'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // Customer preferences and settings export const customerPreferences = pgTable('customer_preferences', { id: uuid('id').primaryKey().defaultRandom(), customerProfileId: uuid('customer_profile_id').references(() => customerProfiles.id, { onDelete: 'cascade' }).notNull(), // Preference details category: varchar('category', { length: 50 }).notNull(), // notification, shipping, billing, etc. key: varchar('key', { length: 100 }).notNull(), value: text('value').notNull(), // Metadata isDefault: boolean('is_default').default(false), isEditable: boolean('is_editable').default(true), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // Type exports export type CustomerProfile = InferSelectModel<typeof customerProfiles>; export type NewCustomerProfile = InferInsertModel<typeof customerProfiles>; export type Company = InferSelectModel<typeof companies>; export type NewCompany = InferInsertModel<typeof companies>; export type CustomerCommunication = InferSelectModel<typeof customerCommunications>; export type NewCustomerCommunication = InferInsertModel<typeof customerCommunications>; export type CustomerPreference = InferSelectModel<typeof customerPreferences>; export type NewCustomerPreference = InferInsertModel<typeof customerPreferences>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface CustomerFilters { kycStatus?: KycStatus | KycStatus[]; riskLevel?: RiskLevel | RiskLevel[]; subscriptionStatus?: string; accountStatus?: string; isVip?: boolean; planName?: string; search?: string; country?: string; dateFrom?: string; dateTo?: string; minSpent?: string; maxSpent?: string; minPackages?: number; maxPackages?: number; page?: number; limit?: number; } export interface CompanyFilters { companyType?: CompanyType | CompanyType[]; verificationStatus?: VerificationStatus | VerificationStatus[]; industry?: string; numberOfEmployees?: string; annualRevenue?: string; isActive?: boolean; accountManagerId?: string; search?: string; page?: number; limit?: number; } export interface CustomerCommunicationFilters { customerProfileId?: string; communicationType?: string; direction?: string; staffMemberId?: string; followUpRequired?: boolean; referenceType?: string; referenceId?: string; fromDate?: string; toDate?: string; search?: string; page?: number; limit?: number; } export interface CustomerPreferenceFilters { customerProfileId?: string; category?: string; key?: string; isDefault?: boolean; isEditable?: boolean; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateCustomerProfileData { customerId: string; dateOfBirth?: string; nationality?: string; idNumber?: string; kycStatus?: KycStatus; riskLevel?: RiskLevel; referralCode?: string; referredBy?: string; preferredCurrency?: string; communicationPreferences?: Record<string, any>; shippingPreferences?: Record<string, any>; marketingOptIn?: boolean; smsOptIn?: boolean; emailOptIn?: boolean; } export interface UpdateCustomerProfileData { dateOfBirth?: string; nationality?: string; idNumber?: string; kycStatus?: KycStatus; kycNotes?: string; riskLevel?: RiskLevel; riskNotes?: string; lastRiskAssessment?: string; stripeCustomerId?: string; stripeSubscriptionId?: string; stripeProductId?: string; planName?: string; planFeatures?: Record<string, any>; subscriptionStatus?: string; subscriptionStartedAt?: string; subscriptionEndsAt?: string; referralReward?: string; totalReferrals?: number; preferredCurrency?: string; communicationPreferences?: Record<string, any>; shippingPreferences?: Record<string, any>; customerServiceNotes?: string; isVip?: boolean; vipSince?: string; accountStatus?: string; suspensionReason?: string; suspendedAt?: string; suspendedBy?: string; marketingOptIn?: boolean; smsOptIn?: boolean; emailOptIn?: boolean; } export interface CreateCompanyData { name: string; legalName?: string; registrationNumber?: string; taxNumber?: string; taxNumberType?: string; vatNumber?: string; companyType?: CompanyType; industry?: string; businessDescription?: string; yearEstablished?: number; numberOfEmployees?: string; annualRevenue?: string; website?: string; primaryContactName?: string; primaryContactTitle?: string; primaryContactEmail?: string; primaryContactPhone?: string; showInAddress?: boolean; useForCustoms?: boolean; customsExporterNumber?: string; creditLimit?: string; creditTerms?: string; paymentTerms?: string; accountManagerId?: string; } export interface UpdateCompanyData { name?: string; legalName?: string; registrationNumber?: string; taxNumber?: string; taxNumberType?: string; vatNumber?: string; companyType?: CompanyType; industry?: string; businessDescription?: string; yearEstablished?: number; numberOfEmployees?: string; annualRevenue?: string; website?: string; primaryContactName?: string; primaryContactTitle?: string; primaryContactEmail?: string; primaryContactPhone?: string; verificationStatus?: VerificationStatus; verifiedAt?: string; verifiedBy?: string; verificationNotes?: string; showInAddress?: boolean; useForCustoms?: boolean; customsExporterNumber?: string; creditLimit?: string; creditTerms?: string; paymentTerms?: string; accountManagerId?: string; isActive?: boolean; } export interface CreateCustomerCommunicationData { customerProfileId: string; communicationType: string; direction: string; subject?: string; content?: string; staffMemberId?: string; externalParticipants?: string[]; duration?: number; outcome?: string; followUpRequired?: boolean; followUpDate?: string; referenceType?: string; referenceId?: string; } export interface CreateCustomerPreferenceData { customerProfileId: string; category: string; key: string; value: string; isDefault?: boolean; isEditable?: boolean; } export interface UpdateCustomerPreferenceData { value?: string; isDefault?: boolean; isEditable?: boolean; } // ============================================================================= // BUSINESS LOGIC HELPERS // ============================================================================= export interface CustomerStats { totalCustomers: number; activeCustomers: number; vipCustomers: number; newCustomersThisMonth: number; totalRevenue: string; averageOrderValue: string; topCustomersBySpent: CustomerProfile[]; kycStatusDistribution: Record<KycStatus, number>; riskLevelDistribution: Record<RiskLevel, number>; subscriptionStatusDistribution: Record<string, number>; } export interface CustomerLifetimeValue { customerId: string; totalSpent: string; totalPackages: number; totalShipments: number; averagePackageValue: string; firstOrderDate: string; lastOrderDate: string; daysSinceFirstOrder: number; daysSinceLastOrder: number; predictedLifetimeValue: string; } // Address helper types (since addresses are now in settings) export interface CustomerAddressReference { entityType: 'customer_profile'; entityId: string; addressType: AddressType; } export interface CompanyAddressReference { entityType: 'company'; entityId: string; addressType: AddressType; } // Helper functions for polymorphic address associations export const createCustomerAddressLink = (customerId: string, addressId: string, addressType: AddressType): NewEntityAddress => ({ entityType: 'customer_profile', entityId: customerId, addressId, addressType, }); export const createCompanyAddressLink = (companyId: string, addressId: string, addressType: AddressType): NewEntityAddress => ({ entityType: 'company', entityId: companyId, addressId, addressType, }); // Helper types for working with customer addresses export interface CustomerWithAddresses extends CustomerProfile { addresses?: EntityAddress[]; } export interface CompanyWithAddresses extends Company { addresses?: EntityAddress[]; }
```

# features\auth\db\schema\index.ts

```ts
// features/auth/db/schema/index.ts // Authentication, Users, Tenancy, and RBAC schemas import { pgTable, uuid, varchar, timestamp, boolean, inet, text, integer, jsonb } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; // ============================================================================= // ENUMS // ============================================================================= export const tenantStatusEnum = ['active', 'suspended', 'cancelled'] as const; export const userTypeEnum = ['customer', 'admin', 'staff'] as const; export const userStatusEnum = ['active', 'inactive', 'suspended'] as const; export const roleTypeEnum = ['customer', 'admin', 'staff'] as const; export type TenantStatus = typeof tenantStatusEnum[number]; export type UserType = typeof userTypeEnum[number]; export type UserStatus = typeof userStatusEnum[number]; export type RoleType = typeof roleTypeEnum[number]; // ============================================================================= // TENANCY MANAGEMENT // ============================================================================= export const tenants = pgTable('tenants', { id: uuid('id').primaryKey().defaultRandom(), name: varchar('name', { length: 255 }).notNull(), slug: varchar('slug', { length: 100 }).unique().notNull(), domain: varchar('domain', { length: 255 }), // Business details companyName: varchar('company_name', { length: 255 }), companyRegistration: varchar('company_registration', { length: 100 }), taxNumber: varchar('tax_number', { length: 100 }), // Tenant settings settings: jsonb('settings').default('{}'), branding: jsonb('branding').default('{}'), // Subscription/billing planType: varchar('plan_type', { length: 50 }).default('standard'), billingEmail: varchar('billing_email', { length: 255 }), // Status and limits status: varchar('status', { length: 20 }).notNull().default('active'), maxUsers: integer('max_users').default(1000), maxPackagesMonthly: integer('max_packages_monthly').default(10000), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), deletedAt: timestamp('deleted_at'), }); // ============================================================================= // USER MANAGEMENT // ============================================================================= export const users = pgTable('users', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // Authentication email: varchar('email', { length: 255 }).notNull(), emailVerifiedAt: timestamp('email_verified_at'), passwordHash: varchar('password_hash', { length: 255 }).notNull(), // Profile firstName: varchar('first_name', { length: 100 }), lastName: varchar('last_name', { length: 100 }), phone: varchar('phone', { length: 50 }), avatarUrl: varchar('avatar_url', { length: 500 }), // User type and status userType: varchar('user_type', { length: 20 }).notNull().default('customer'), status: varchar('status', { length: 20 }).notNull().default('active'), // Security twoFactorEnabled: boolean('two_factor_enabled').default(false), twoFactorSecret: varchar('two_factor_secret', { length: 255 }), lastLoginAt: timestamp('last_login_at'), lastLoginIp: inet('last_login_ip'), // Preferences language: varchar('language', { length: 10 }).default('en'), timezone: varchar('timezone', { length: 100 }).default('UTC'), currencyPreference: varchar('currency_preference', { length: 3 }).default('USD'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), deletedAt: timestamp('deleted_at'), }); // ============================================================================= // RBAC SYSTEM // ============================================================================= export const roles = pgTable('roles', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), name: varchar('name', { length: 100 }).notNull(), slug: varchar('slug', { length: 100 }).notNull(), description: text('description'), roleType: varchar('role_type', { length: 20 }).notNull(), isSystemRole: boolean('is_system_role').default(false), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const permissions = pgTable('permissions', { id: uuid('id').primaryKey().defaultRandom(), name: varchar('name', { length: 100 }).unique().notNull(), slug: varchar('slug', { length: 100 }).unique().notNull(), description: text('description'), category: varchar('category', { length: 50 }).notNull(), action: varchar('action', { length: 50 }).notNull(), createdAt: timestamp('created_at').notNull().defaultNow(), }); export const rolePermissions = pgTable('role_permissions', { id: uuid('id').primaryKey().defaultRandom(), roleId: uuid('role_id').references(() => roles.id, { onDelete: 'cascade' }).notNull(), permissionId: uuid('permission_id').references(() => permissions.id, { onDelete: 'cascade' }).notNull(), createdAt: timestamp('created_at').notNull().defaultNow(), }); export const userRoles = pgTable('user_roles', { id: uuid('id').primaryKey().defaultRandom(), userId: uuid('user_id').references(() => users.id, { onDelete: 'cascade' }).notNull(), roleId: uuid('role_id').references(() => roles.id, { onDelete: 'cascade' }).notNull(), expiresAt: timestamp('expires_at'), assignedBy: uuid('assigned_by').references(() => users.id), createdAt: timestamp('created_at').notNull().defaultNow(), }); // ============================================================================= // TYPE EXPORTS // ============================================================================= // Tenant types export type Tenant = InferSelectModel<typeof tenants>; export type NewTenant = InferInsertModel<typeof tenants>; // User types export type User = InferSelectModel<typeof users>; export type NewUser = InferInsertModel<typeof users>; // RBAC types export type Role = InferSelectModel<typeof roles>; export type NewRole = InferInsertModel<typeof roles>; export type Permission = InferSelectModel<typeof permissions>; export type NewPermission = InferInsertModel<typeof permissions>; export type RolePermission = InferSelectModel<typeof rolePermissions>; export type NewRolePermission = InferInsertModel<typeof rolePermissions>; export type UserRole = InferSelectModel<typeof userRoles>; export type NewUserRole = InferInsertModel<typeof userRoles>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface TenantFilters { status?: TenantStatus; planType?: string; search?: string; page?: number; limit?: number; } export interface UserFilters { userType?: UserType; status?: UserStatus; search?: string; tenantId?: string; page?: number; limit?: number; } export interface RoleFilters { roleType?: RoleType; isSystemRole?: boolean; search?: string; tenantId?: string; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateTenantData { name: string; slug: string; domain?: string; companyName?: string; companyRegistration?: string; taxNumber?: string; planType?: string; billingEmail?: string; settings?: Record<string, any>; branding?: Record<string, any>; } export interface UpdateTenantData { name?: string; domain?: string; companyName?: string; companyRegistration?: string; taxNumber?: string; planType?: string; billingEmail?: string; status?: TenantStatus; maxUsers?: number; maxPackagesMonthly?: number; settings?: Record<string, any>; branding?: Record<string, any>; } export interface CreateUserData { email: string; passwordHash: string; firstName?: string; lastName?: string; phone?: string; userType?: UserType; status?: UserStatus; language?: string; timezone?: string; currencyPreference?: string; } export interface UpdateUserData { firstName?: string; lastName?: string; phone?: string; avatarUrl?: string; status?: UserStatus; language?: string; timezone?: string; currencyPreference?: string; twoFactorEnabled?: boolean; } export interface CreateRoleData { name: string; slug: string; description?: string; roleType: RoleType; isSystemRole?: boolean; } export interface UpdateRoleData { name?: string; description?: string; roleType?: RoleType; }
```

# features\customers\db\queries\update-customer.query.ts

```ts
// features/customers/db/queries/update-customer.query.ts import { db } from '@/lib/db'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { eq } from 'drizzle-orm'; import type { Customer, UpdateCustomerData } from '../../types/customer.types'; import { transformCustomer } from './transform-customer.query'; /** * Update an existing customer */ export async function updateCustomer(id: string, data: UpdateCustomerData): Promise<Customer | null> { // Check if customer exists const existingCustomer = await db .select() .from(customers) .where(eq(customers.id, id)) .limit(1); if (existingCustomer.length === 0) { return null; } // Check if email is being changed and already exists if (data.email && data.email !== existingCustomer[0].email) { const emailExists = await db .select() .from(customers) .where(eq(customers.email, data.email)) .limit(1); if (emailExists.length > 0) { throw new Error('Customer with this email already exists'); } } // Prepare update data const updateData: any = { updatedAt: new Date(), }; if (data.name) { updateData.name = data.name; } if (data.email) { updateData.email = data.email; } if (data.phone !== undefined) { updateData.phone = data.phone || null; } if (data.address !== undefined) { updateData.address = data.address; } if (data.city !== undefined) { updateData.city = data.city; } if (data.state !== undefined) { updateData.state = data.state; } if (data.country !== undefined) { updateData.country = data.country; } if (data.postalCode !== undefined) { updateData.postalCode = data.postalCode; } if (data.notes !== undefined) { updateData.notes = data.notes; } if (data.status) { updateData.status = data.status; } // Update customer const [updatedCustomer] = await db .update(customers) .set(updateData) .where(eq(customers.id, id)) .returning(); return transformCustomer({ ...updatedCustomer, packageCount: 0, // We'll get this from a separate query in getCustomerById }); }
```

# features\customers\db\queries\transform-customer.query.ts

```ts
// features/customers/db/queries/transform-customer.query.ts import type { Customer } from '../../types/customer.types'; /** * Transform database customer to frontend format */ export function transformCustomer(customer: any): Customer { return { id: customer.id, email: customer.email, name: customer.name, phone: customer.phone, address: customer.address || '', city: customer.city || '', state: customer.state || '', country: customer.country || '', postalCode: customer.postalCode || '', status: customer.status, packageCount: customer.packageCount || 0, notes: customer.notes, createdAt: customer.createdAt?.toISOString() || '', updatedAt: customer.updatedAt?.toISOString() || '', }; }
```

# features\customers\db\queries\search-customers.query.ts

```ts
// features/customers/db/queries/search-customers.query.ts import { db } from '@/lib/db'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { packages } from '@/features/packages/db/schema/package.schema'; import { eq, ilike, or, desc, count, sql } from 'drizzle-orm'; import type { Customer } from '../../types/customer.types'; import { transformCustomer } from './transform-customer.query'; /** * Search customers */ export async function searchCustomers(query: string): Promise<Customer[]> { const searchResults = await db .select({ id: customers.id, name: customers.name, email: customers.email, phone: customers.phone, address: customers.address, city: customers.city, state: customers.state, country: customers.country, postalCode: customers.postalCode, status: customers.status, notes: customers.notes, createdAt: customers.createdAt, updatedAt: customers.updatedAt, packageCount: count(packages.id), }) .from(customers) .leftJoin(packages, eq(customers.id, packages.customerId)) .where( sql`(${customers.name} ILIKE ${`%${query}%`} OR ${customers.email} ILIKE ${`%${query}%`})` ) .groupBy(customers.id) .orderBy(desc(customers.createdAt)) .limit(20); return searchResults.map(transformCustomer); }
```

# features\customers\db\queries\index.ts

```ts
// features/customers/db/queries/index.ts export { getCustomers } from './get-customers.query'; export { getCustomerById } from './get-customer-by-id.query'; export { createCustomer } from './create-customer.query'; export { updateCustomer } from './update-customer.query'; export { deleteCustomer } from './delete-customer.query'; export { searchCustomers } from './search-customers.query'; export { transformCustomer } from './transform-customer.query';
```

# features\customers\db\queries\get-customers.query.ts

```ts
// features/customers/db/queries/get-customers.query.ts import { db } from '@/lib/db'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { packages } from '@/features/packages/db/schema/package.schema'; import { eq, ilike, and, desc, count, sql } from 'drizzle-orm'; import type { CustomerFilters } from '../../types/customer.types'; import { transformCustomer } from './transform-customer.query'; /** * Get customers with filters and pagination */ export async function getCustomers(filters: CustomerFilters = {}) { const { page = 1, limit = 10, status, search, country } = filters; // Build where conditions const conditions = []; if (status && status !== 'all') { conditions.push(eq(customers.status, status as any)); } if (country) { conditions.push(eq(customers.country, country)); } if (search) { conditions.push( sql`(${customers.name} ILIKE ${`%${search}%`} OR ${customers.email} ILIKE ${`%${search}%`})` ); } // Get customers with package counts let query = db .select({ id: customers.id, name: customers.name, email: customers.email, phone: customers.phone, address: customers.address, city: customers.city, state: customers.state, country: customers.country, postalCode: customers.postalCode, status: customers.status, notes: customers.notes, createdAt: customers.createdAt, updatedAt: customers.updatedAt, packageCount: count(packages.id), }) .from(customers) .leftJoin(packages, eq(customers.id, packages.customerId)) .groupBy(customers.id); // Apply where conditions if any exist const finalQuery = conditions.length > 0 ? query.where(and(...conditions)) : query; const allCustomers = await finalQuery.orderBy(desc(customers.createdAt)); // Calculate pagination const total = allCustomers.length; const pages = Math.ceil(total / limit); const startIndex = (page - 1) * limit; const endIndex = startIndex + limit; const paginatedCustomers = allCustomers.slice(startIndex, endIndex); // Transform data to match frontend expectations const transformedCustomers = paginatedCustomers.map(transformCustomer); return { data: transformedCustomers, pagination: { page, limit, total, pages }, }; }
```

# features\customers\db\queries\get-customer-by-id.query.ts

```ts
// features/customers/db/queries/get-customer-by-id.query.ts import { db } from '@/lib/db'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { packages } from '@/features/packages/db/schema/package.schema'; import { eq, count } from 'drizzle-orm'; import type { Customer } from '../../types/customer.types'; import { transformCustomer } from './transform-customer.query'; /** * Get a single customer by ID */ export async function getCustomerById(id: string): Promise<Customer | null> { const customerResult = await db .select({ id: customers.id, name: customers.name, email: customers.email, phone: customers.phone, address: customers.address, city: customers.city, state: customers.state, country: customers.country, postalCode: customers.postalCode, status: customers.status, notes: customers.notes, createdAt: customers.createdAt, updatedAt: customers.updatedAt, packageCount: count(packages.id), }) .from(customers) .leftJoin(packages, eq(customers.id, packages.customerId)) .where(eq(customers.id, id)) .groupBy(customers.id) .limit(1); if (customerResult.length === 0) { return null; } return transformCustomer(customerResult[0]); }
```

# features\customers\db\queries\delete-customer.query.ts

```ts
// features/customers/db/queries/delete-customer.query.ts import { db } from '@/lib/db'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { packages } from '@/features/packages/db/schema/package.schema'; import { eq, count } from 'drizzle-orm'; /** * Delete a customer */ export async function deleteCustomer(id: string): Promise<boolean> { // Check if customer exists const existingCustomer = await db .select() .from(customers) .where(eq(customers.id, id)) .limit(1); if (existingCustomer.length === 0) { return false; } // Check if customer has packages const packageCount = await db .select({ count: count() }) .from(packages) .where(eq(packages.customerId, id)); if (packageCount[0].count > 0) { throw new Error('Cannot delete customer with existing packages'); } // Delete customer await db.delete(customers).where(eq(customers.id, id)); return true; }
```

# features\customers\db\queries\create-customer.query.ts

```ts
// features/customers/db/queries/create-customer.query.ts import { db } from '@/lib/db'; import { customers } from '@/features/customers/db/schema/customer.schema'; import { eq } from 'drizzle-orm'; import type { Customer, CreateCustomerData } from '../../types/customer.types'; import { transformCustomer } from './transform-customer.query'; /** * Create a new customer */ export async function createCustomer(data: CreateCustomerData): Promise<Customer> { // Check if email already exists const existingCustomer = await db .select() .from(customers) .where(eq(customers.email, data.email)) .limit(1); if (existingCustomer.length > 0) { throw new Error('Customer with this email already exists'); } // Create new customer const newCustomerData = { name: data.name, email: data.email, phone: data.phone || null, address: data.address || null, city: data.city || null, state: data.state || null, country: data.country || null, postalCode: data.postalCode || null, status: data.status || 'pending', notes: data.notes || null, }; const [newCustomer] = await db .insert(customers) .values(newCustomerData) .returning(); // Transform response using the common transformer return transformCustomer({ ...newCustomer, packageCount: 0 }); }
```

# features\audit\db\schema\index.ts

```ts
// features/audit/db/schema/index.ts // Audit & Communications schemas (Activity Logs, Notifications, Compliance) import { pgTable, uuid, varchar, text, timestamp, jsonb, boolean } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; // ============================================================================= // ENUMS // ============================================================================= export const notificationStatusEnum = [ 'pending', 'sent', 'delivered', 'failed', 'bounced', 'unread' ] as const; export const notificationTypeEnum = [ 'package_received', 'package_shipped', 'storage_reminder', 'payment_due', 'quote_ready', 'system_announcement', 'security_alert', 'personal_shopper_update', 'customs_delay', 'delivery_notification' ] as const; export const activityActionEnum = [ 'create', 'update', 'delete', 'login', 'logout', 'view', 'download', 'upload', 'approve', 'reject', 'assign', 'unassign', 'process', 'ship', 'deliver', 'payment_received', 'invoice_generated' ] as const; export type NotificationStatus = typeof notificationStatusEnum[number]; export type NotificationType = typeof notificationTypeEnum[number]; export type ActivityAction = typeof activityActionEnum[number]; // ============================================================================= // ACTIVITY LOGGING // ============================================================================= export const activityLogs = pgTable('activity_logs', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), userId: uuid('user_id'), // References users.id, nullable for system actions customerProfileId: uuid('customer_profile_id'), // References customer_profiles.id // Activity details action: varchar('action', { length: 50 }).notNull(), resourceType: varchar('resource_type', { length: 50 }).notNull(), resourceId: uuid('resource_id'), // Details description: text('description'), metadata: jsonb('metadata').default('{}'), // IP and user agent for security auditing ipAddress: varchar('ip_address', { length: 50 }), userAgent: varchar('user_agent', { length: 500 }), // Changes tracking previousValues: jsonb('previous_values'), newValues: jsonb('new_values'), // Additional context sessionId: varchar('session_id', { length: 255 }), requestId: varchar('request_id', { length: 255 }), // Severity for filtering important events severity: varchar('severity', { length: 20 }).default('info'), // debug, info, warn, error, critical // Tags for categorization tags: jsonb('tags').default('[]'), createdAt: timestamp('created_at').notNull().defaultNow(), }); // ============================================================================= // NOTIFICATION SYSTEM // ============================================================================= export const notifications = pgTable('notifications', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), userId: uuid('user_id'), // References users.id customerProfileId: uuid('customer_profile_id'), // References customer_profiles.id // Notification content title: varchar('title', { length: 255 }).notNull(), message: text('message').notNull(), // Type and status notificationType: varchar('notification_type', { length: 50 }).notNull(), status: varchar('status', { length: 20 }).default('pending'), // Priority for ordering and filtering priority: varchar('priority', { length: 10 }).default('normal'), // low, normal, high, urgent // Reference to source object referenceType: varchar('reference_type', { length: 50 }), referenceId: uuid('reference_id'), // Delivery channels channels: jsonb('channels').default('["in_app"]'), // in_app, email, sms, push // Delivery tracking sentViaEmail: boolean('sent_via_email').default(false), sentViaSms: boolean('sent_via_sms').default(false), sentViaPush: boolean('sent_via_push').default(false), sentViaInApp: boolean('sent_via_in_app').default(true), // Email specific emailAddress: varchar('email_address', { length: 255 }), emailSubject: varchar('email_subject', { length: 255 }), emailTemplate: varchar('email_template', { length: 100 }), // SMS specific phoneNumber: varchar('phone_number', { length: 50 }), smsTemplate: varchar('sms_template', { length: 100 }), // Push notification specific pushDeviceTokens: jsonb('push_device_tokens').default('[]'), pushTemplate: varchar('push_template', { length: 100 }), // Interaction tracking readAt: timestamp('read_at'), clickedAt: timestamp('clicked_at'), dismissedAt: timestamp('dismissed_at'), // Delivery attempts and results emailDeliveredAt: timestamp('email_delivered_at'), emailFailedAt: timestamp('email_failed_at'), emailFailureReason: text('email_failure_reason'), smsDeliveredAt: timestamp('sms_delivered_at'), smsFailedAt: timestamp('sms_failed_at'), smsFailureReason: text('sms_failure_reason'), pushDeliveredAt: timestamp('push_delivered_at'), pushFailedAt: timestamp('push_failed_at'), pushFailureReason: text('push_failure_reason'), // Retry logic retryCount: varchar('retry_count', { length: 2 }).default('0'), maxRetries: varchar('max_retries', { length: 2 }).default('3'), nextRetryAt: timestamp('next_retry_at'), // Additional data metadata: jsonb('metadata').default('{}'), // Expiration expiresAt: timestamp('expires_at'), // Grouping for bulk operations groupId: varchar('group_id', { length: 100 }), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // NOTIFICATION TEMPLATES // ============================================================================= export const notificationTemplates = pgTable('notification_templates', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // Template identification name: varchar('name', { length: 100 }).notNull(), code: varchar('code', { length: 50 }).notNull(), notificationType: varchar('notification_type', { length: 50 }).notNull(), // Template content title: varchar('title', { length: 255 }).notNull(), messageTemplate: text('message_template').notNull(), // Channel-specific templates emailSubjectTemplate: varchar('email_subject_template', { length: 255 }), emailBodyTemplate: text('email_body_template'), smsTemplate: text('sms_template'), pushTemplate: text('push_template'), // Template variables (for documentation) availableVariables: jsonb('available_variables').default('[]'), // Settings isActive: boolean('is_active').default(true), isDefault: boolean('is_default').default(false), // Localization language: varchar('language', { length: 10 }).default('en'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // COMPLIANCE TRACKING // ============================================================================= export const complianceEvents = pgTable('compliance_events', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), // Event identification eventType: varchar('event_type', { length: 50 }).notNull(), eventCategory: varchar('event_category', { length: 50 }).notNull(), // Related entities userId: uuid('user_id'), // References users.id customerProfileId: uuid('customer_profile_id'), // References customer_profiles.id resourceType: varchar('resource_type', { length: 50 }), resourceId: uuid('resource_id'), // Compliance details regulationType: varchar('regulation_type', { length: 50 }), // GDPR, PCI, SOX, etc. complianceStatus: varchar('compliance_status', { length: 20 }), // compliant, non_compliant, pending // Event data eventData: jsonb('event_data').default('{}'), evidence: jsonb('evidence').default('{}'), // Risk assessment riskLevel: varchar('risk_level', { length: 10 }).default('low'), // low, medium, high, critical // Resolution tracking resolvedAt: timestamp('resolved_at'), resolvedBy: uuid('resolved_by'), // References users.id resolutionNotes: text('resolution_notes'), // Retention retentionPeriod: varchar('retention_period', { length: 20 }).default('7_years'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); // ============================================================================= // TYPE EXPORTS // ============================================================================= // Activity log types export type ActivityLog = InferSelectModel<typeof activityLogs>; export type NewActivityLog = InferInsertModel<typeof activityLogs>; // Notification types export type Notification = InferSelectModel<typeof notifications>; export type NewNotification = InferInsertModel<typeof notifications>; export type NotificationTemplate = InferSelectModel<typeof notificationTemplates>; export type NewNotificationTemplate = InferInsertModel<typeof notificationTemplates>; // Compliance types export type ComplianceEvent = InferSelectModel<typeof complianceEvents>; export type NewComplianceEvent = InferInsertModel<typeof complianceEvents>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface ActivityLogFilters { userId?: string; customerProfileId?: string; action?: ActivityAction | ActivityAction[]; resourceType?: string; resourceId?: string; severity?: string; fromDate?: string; toDate?: string; search?: string; tags?: string[]; page?: number; limit?: number; } export interface NotificationFilters { userId?: string; customerProfileId?: string; notificationType?: NotificationType | NotificationType[]; status?: NotificationStatus | NotificationStatus[]; priority?: string; isRead?: boolean; channel?: string; fromDate?: string; toDate?: string; search?: string; page?: number; limit?: number; } export interface ComplianceEventFilters { eventType?: string; eventCategory?: string; regulationType?: string; complianceStatus?: string; riskLevel?: string; userId?: string; customerProfileId?: string; fromDate?: string; toDate?: string; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateActivityLogData { userId?: string; customerProfileId?: string; action: ActivityAction; resourceType: string; resourceId?: string; description?: string; metadata?: Record<string, any>; ipAddress?: string; userAgent?: string; previousValues?: Record<string, any>; newValues?: Record<string, any>; sessionId?: string; requestId?: string; severity?: string; tags?: string[]; } export interface CreateNotificationData { userId?: string; customerProfileId?: string; title: string; message: string; notificationType: NotificationType; priority?: string; referenceType?: string; referenceId?: string; channels?: string[]; emailAddress?: string; emailSubject?: string; emailTemplate?: string; phoneNumber?: string; smsTemplate?: string; pushDeviceTokens?: string[]; pushTemplate?: string; metadata?: Record<string, any>; expiresAt?: string; groupId?: string; } export interface UpdateNotificationData { status?: NotificationStatus; readAt?: string; clickedAt?: string; dismissedAt?: string; retryCount?: string; nextRetryAt?: string; emailDeliveredAt?: string; emailFailedAt?: string; emailFailureReason?: string; smsDeliveredAt?: string; smsFailedAt?: string; smsFailureReason?: string; pushDeliveredAt?: string; pushFailedAt?: string; pushFailureReason?: string; } export interface CreateNotificationTemplateData { name: string; code: string; notificationType: NotificationType; title: string; messageTemplate: string; emailSubjectTemplate?: string; emailBodyTemplate?: string; smsTemplate?: string; pushTemplate?: string; availableVariables?: string[]; isActive?: boolean; isDefault?: boolean; language?: string; } export interface CreateComplianceEventData { eventType: string; eventCategory: string; userId?: string; customerProfileId?: string; resourceType?: string; resourceId?: string; regulationType?: string; complianceStatus?: string; eventData?: Record<string, any>; evidence?: Record<string, any>; riskLevel?: string; retentionPeriod?: string; }
```

# features\finance\db\schema\index.ts

```ts
// features/finance/db/schema/index.ts // Finance & Services schemas (Invoicing, Billing, Payments, Personal Shopping) import { pgTable, uuid, varchar, text, timestamp, decimal, integer, jsonb, boolean } from 'drizzle-orm/pg-core'; import { InferSelectModel, InferInsertModel } from 'drizzle-orm'; import { tenants } from '@/features/auth/db/schema'; // ============================================================================= // ENUMS // ============================================================================= export const invoiceTypeEnum = [ 'shipping', 'storage', 'handling', 'personal_shopper', 'customs_duty', 'insurance', 'other' ] as const; export const paymentStatusEnum = [ 'pending', 'paid', 'partially_paid', 'overdue', 'cancelled', 'refunded' ] as const; export const personalShopperRequestStatusEnum = [ 'draft', 'submitted', 'quoted', 'approved', 'purchasing', 'purchased', 'received', 'cancelled', 'completed' ] as const; export const shippingPreferenceEnum = [ 'send_together', 'send_as_available', 'send_by_category', 'fastest_delivery' ] as const; export type InvoiceType = typeof invoiceTypeEnum[number]; export type PaymentStatus = typeof paymentStatusEnum[number]; export type PersonalShopperRequestStatus = typeof personalShopperRequestStatusEnum[number]; export type ShippingPreference = typeof shippingPreferenceEnum[number]; // ============================================================================= // FINANCIAL MANAGEMENT // ============================================================================= export const invoices = pgTable('invoices', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').references(() => tenants.id, { onDelete: 'cascade' }).notNull(), customerProfileId: uuid('customer_profile_id').notNull(), // References customer_profiles.id invoiceNumber: varchar('invoice_number', { length: 50 }).unique().notNull(), invoiceType: varchar('invoice_type', { length: 30 }).notNull(), // References shipmentId: uuid('shipment_id'), // References shipments.id personalShopperRequestId: uuid('personal_shopper_request_id'), // References personal_shopper_requests.id // Financial details subtotal: decimal('subtotal', { precision: 12, scale: 2 }).notNull(), taxAmount: decimal('tax_amount', { precision: 12, scale: 2 }).default('0.00'), discountAmount: decimal('discount_amount', { precision: 12, scale: 2 }).default('0.00'), totalAmount: decimal('total_amount', { precision: 12, scale: 2 }).notNull(), currencyCode: varchar('currency_code', { length: 3 }).notNull(), // Payment status paymentStatus: varchar('payment_status', { length: 20 }).default('pending'), // Payment tracking paidAmount: decimal('paid_amount', { precision: 12, scale: 2 }).default('0.00'), paymentMethod: varchar('payment_method', { length: 50 }), paymentReference: varchar('payment_reference', { length: 255 }), paidAt: timestamp('paid_at'), // Important dates issuedAt: timestamp('issued_at').notNull().defaultNow(), dueDate: timestamp('due_date'), // Additional info notes: text('notes'), paymentTerms: text('payment_terms'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const invoiceLines = pgTable('invoice_lines', { id: uuid('id').primaryKey().defaultRandom(), invoiceId: uuid('invoice_id').references(() => invoices.id, { onDelete: 'cascade' }).notNull(), description: text('description').notNull(), quantity: decimal('quantity', { precision: 10, scale: 3 }).default('1.000'), unitPrice: decimal('unit_price', { precision: 12, scale: 2 }).notNull(), lineTotal: decimal('line_total', { precision: 12, scale: 2 }).notNull(), // Tax information taxRate: decimal('tax_rate', { precision: 5, scale: 4 }).default('0.0000'), taxAmount: decimal('tax_amount', { precision: 12, scale: 2 }).default('0.00'), // Reference to source object referenceType: varchar('reference_type', { length: 50 }), referenceId: uuid('reference_id'), sortOrder: integer('sort_order').default(0), createdAt: timestamp('created_at').notNull().defaultNow(), }); // ============================================================================= // PERSONAL SHOPPING SERVICE // ============================================================================= export const personalShopperRequests = pgTable('personal_shopper_requests', { id: uuid('id').primaryKey().defaultRandom(), tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }), customerProfileId: uuid('customer_profile_id').notNull(), // References customer_profiles.id // Request metadata requestNumber: varchar('request_number', { length: 50 }).notNull().unique(), status: varchar('status', { length: 20 }).notNull().default('draft'), // Shipping preferences shippingOption: varchar('shipping_option', { length: 100 }), shippingPreference: varchar('shipping_preference', { length: 20 }).default('send_together'), // Retailer preferences allowAlternateRetailers: boolean('allow_alternate_retailers').default(true), // Financial info estimatedCost: decimal('estimated_cost', { precision: 12, scale: 2 }).default('0.00'), actualCost: decimal('actual_cost', { precision: 12, scale: 2 }).default('0.00'), serviceFee: decimal('service_fee', { precision: 12, scale: 2 }).default('0.00'), totalAmount: decimal('total_amount', { precision: 12, scale: 2 }).default('0.00'), currencyCode: varchar('currency_code', { length: 3 }).default('USD'), // Processing info quotedAt: timestamp('quoted_at'), quotedBy: uuid('quoted_by'), // References users.id approvedAt: timestamp('approved_at'), purchasedAt: timestamp('purchased_at'), purchasedBy: uuid('purchased_by'), // References users.id // Notes and instructions specialInstructions: text('special_instructions'), internalNotes: text('internal_notes'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const personalShopperRequestItems = pgTable('personal_shopper_request_items', { id: uuid('id').primaryKey().defaultRandom(), personalShopperRequestId: uuid('personal_shopper_request_id').notNull() .references(() => personalShopperRequests.id, { onDelete: 'cascade' }), // Item details name: text('name').notNull(), url: text('url'), description: text('description'), // Variants size: varchar('size', { length: 50 }), color: varchar('color', { length: 50 }), variant: varchar('variant', { length: 100 }), // Quantity and pricing quantity: decimal('quantity', { precision: 10, scale: 0 }).notNull().default('1'), maxBudgetPerItem: decimal('max_budget_per_item', { precision: 12, scale: 2 }), actualPrice: decimal('actual_price', { precision: 12, scale: 2 }), totalItemCost: decimal('total_item_cost', { precision: 12, scale: 2 }), // Instructions additionalInstructions: text('additional_instructions'), // Purchase details retailerName: varchar('retailer_name', { length: 255 }), retailerOrderNumber: varchar('retailer_order_number', { length: 100 }), purchasedAt: timestamp('purchased_at'), // Tracking retailerTrackingNumber: varchar('retailer_tracking_number', { length: 100 }), packageId: uuid('package_id'), // Links to packages table when received // Status status: varchar('status', { length: 50 }).default('pending'), // Sort order for display sortOrder: decimal('sort_order', { precision: 3, scale: 0 }).default('0'), createdAt: timestamp('created_at').notNull().defaultNow(), updatedAt: timestamp('updated_at').notNull().defaultNow(), }); export const personalShopperRequestStatusHistory = pgTable('personal_shopper_request_status_history', { id: uuid('id').primaryKey().defaultRandom(), personalShopperRequestId: uuid('personal_shopper_request_id').notNull() .references(() => personalShopperRequests.id, { onDelete: 'cascade' }), status: varchar('status', { length: 20 }).notNull(), notes: text('notes'), changedBy: uuid('changed_by'), // References users.id changeReason: varchar('change_reason', { length: 255 }), createdAt: timestamp('created_at').notNull().defaultNow(), }); // ============================================================================= // TYPE EXPORTS // ============================================================================= // Financial types export type Invoice = InferSelectModel<typeof invoices>; export type NewInvoice = InferInsertModel<typeof invoices>; export type InvoiceLine = InferSelectModel<typeof invoiceLines>; export type NewInvoiceLine = InferInsertModel<typeof invoiceLines>; // Personal shopping types export type PersonalShopperRequest = InferSelectModel<typeof personalShopperRequests>; export type NewPersonalShopperRequest = InferInsertModel<typeof personalShopperRequests>; export type PersonalShopperRequestItem = InferSelectModel<typeof personalShopperRequestItems>; export type NewPersonalShopperRequestItem = InferInsertModel<typeof personalShopperRequestItems>; export type PersonalShopperRequestStatusHistory = InferSelectModel<typeof personalShopperRequestStatusHistory>; export type NewPersonalShopperRequestStatusHistory = InferInsertModel<typeof personalShopperRequestStatusHistory>; // ============================================================================= // FILTER INTERFACES // ============================================================================= export interface FinancialInvoiceFilters { invoiceType?: InvoiceType | InvoiceType[]; paymentStatus?: PaymentStatus | PaymentStatus[]; customerProfileId?: string; shipmentId?: string; personalShopperRequestId?: string; fromDate?: string; toDate?: string; search?: string; page?: number; limit?: number; } export interface PersonalShopperRequestFilters { status?: PersonalShopperRequestStatus | PersonalShopperRequestStatus[]; customerProfileId?: string; quotedBy?: string; purchasedBy?: string; fromDate?: string; toDate?: string; search?: string; page?: number; limit?: number; } export interface PersonalShopperRequestItemFilters { personalShopperRequestId?: string; status?: string; retailerName?: string; packageId?: string; page?: number; limit?: number; } // ============================================================================= // CREATE/UPDATE INTERFACES // ============================================================================= export interface CreateFinancialInvoiceData { customerProfileId: string; invoiceNumber: string; invoiceType: InvoiceType; shipmentId?: string; personalShopperRequestId?: string; subtotal: string; taxAmount?: string; discountAmount?: string; totalAmount: string; currencyCode: string; dueDate?: string; notes?: string; paymentTerms?: string; lines: CreateFinancialInvoiceLineData[]; } export interface UpdateFinancialInvoiceData { paymentStatus?: PaymentStatus; paidAmount?: string; paymentMethod?: string; paymentReference?: string; paidAt?: string; dueDate?: string; notes?: string; paymentTerms?: string; } export interface CreateFinancialInvoiceLineData { description: string; quantity?: string; unitPrice: string; lineTotal: string; taxRate?: string; taxAmount?: string; referenceType?: string; referenceId?: string; sortOrder?: number; } export interface CreatePersonalShopperRequestData { requestNumber: string; shippingOption?: string; shippingPreference?: ShippingPreference; allowAlternateRetailers?: boolean; specialInstructions?: string; items: CreatePersonalShopperRequestItemData[]; } export interface UpdatePersonalShopperRequestData { status?: PersonalShopperRequestStatus; shippingOption?: string; shippingPreference?: ShippingPreference; allowAlternateRetailers?: boolean; estimatedCost?: string; actualCost?: string; serviceFee?: string; totalAmount?: string; quotedAt?: string; quotedBy?: string; approvedAt?: string; purchasedAt?: string; purchasedBy?: string; specialInstructions?: string; internalNotes?: string; } export interface CreatePersonalShopperRequestItemData { name: string; url?: string; description?: string; size?: string; color?: string; variant?: string; quantity?: string; maxBudgetPerItem?: string; additionalInstructions?: string; sortOrder?: string; } export interface UpdatePersonalShopperRequestItemData { name?: string; url?: string; description?: string; size?: string; color?: string; variant?: string; quantity?: string; maxBudgetPerItem?: string; actualPrice?: string; totalItemCost?: string; additionalInstructions?: string; retailerName?: string; retailerOrderNumber?: string; purchasedAt?: string; retailerTrackingNumber?: string; packageId?: string; status?: string; sortOrder?: string; }
```

# app\api\packages\[id]\route.ts

```ts
// app/api/packages/[id]/route.ts import { NextRequest, NextResponse } from 'next/server'; import { getPackageById, updatePackage, deletePackage } from '@/features/packages/db/queries'; interface RouteParams { params: Promise<{ id: string }>; } export async function GET( request: NextRequest, context: RouteParams ) { try { const { id } = await context.params; const packageItem = await getPackageById(id); if (!packageItem) { return NextResponse.json( { success: false, message: 'Package not found' }, { status: 404 } ); } return NextResponse.json({ success: true, data: packageItem, }); } catch (error) { console.error('Error fetching package:', error); return NextResponse.json( { success: false, message: 'Failed to fetch package' }, { status: 500 } ); } } export async function PATCH( request: NextRequest, context: RouteParams ) { try { const { id } = await context.params; const body = await request.json(); const packageItem = await updatePackage(id, body); if (!packageItem) { return NextResponse.json( { success: false, message: 'Package not found' }, { status: 404 } ); } return NextResponse.json({ success: true, data: packageItem, message: 'Package updated successfully', }); } catch (error) { console.error('Error updating package:', error); return NextResponse.json( { success: false, message: 'Failed to update package' }, { status: 500 } ); } } export async function DELETE( request: NextRequest, context: RouteParams ) { try { const { id } = await context.params; const success = await deletePackage(id); if (!success) { return NextResponse.json( { success: false, message: 'Package not found' }, { status: 404 } ); } return NextResponse.json({ success: true, message: 'Package deleted successfully', }); } catch (error) { console.error('Error deleting package:', error); return NextResponse.json( { success: false, message: 'Failed to delete package' }, { status: 500 } ); } }
```

# app\api\packages\bulk-status\route.ts

```ts
// app/api/packages/bulk-status/route.ts import { NextRequest, NextResponse } from 'next/server'; import { updatePackagesStatus } from '@/features/packages/db/queries/update-packages-status.query'; import type { PackageStatus } from '@/features/packages/types/package.types'; export async function PATCH(request: NextRequest) { try { const body = await request.json(); // Validate required fields if (!body.ids || !Array.isArray(body.ids) || body.ids.length === 0) { return NextResponse.json( { success: false, message: 'Package IDs array is required' }, { status: 400 } ); } if (!body.status) { return NextResponse.json( { success: false, message: 'Status is required' }, { status: 400 } ); } // Validate status value const validStatuses = ['pending', 'processing', 'shipped', 'delivered', 'returned']; if (!validStatuses.includes(body.status)) { return NextResponse.json( { success: false, message: 'Invalid status value' }, { status: 400 } ); } // Use the query layer to update package statuses const result = await updatePackagesStatus(body.ids, body.status as PackageStatus); if (!result.success) { return NextResponse.json( { success: false, message: result.message }, { status: result.status } ); } return NextResponse.json({ success: true, data: result.data, message: result.message, }); } catch (error) { console.error('Error bulk updating package status:', error); return NextResponse.json( { success: false, message: 'Failed to update package status' }, { status: 500 } ); } }
```

# app\api\customers\[id]\route.ts

```ts
// app/api/customers/[id]/route.ts import { NextRequest, NextResponse } from 'next/server'; import { getCustomerById, updateCustomer, deleteCustomer } from '@/features/customers/db/queries'; interface RouteParams { params: Promise<{ id: string }>; } export async function GET( request: NextRequest, context: RouteParams ) { try { const { id } = await context.params; const customer = await getCustomerById(id); if (!customer) { return NextResponse.json( { success: false, message: 'Customer not found' }, { status: 404 } ); } return NextResponse.json({ success: true, data: customer, }); } catch (error) { console.error('Error fetching customer:', error); return NextResponse.json( { success: false, message: 'Failed to fetch customer' }, { status: 500 } ); } } export async function PATCH( request: NextRequest, context: RouteParams ) { try { const { id } = await context.params; const body = await request.json(); const customer = await updateCustomer(id, body); if (!customer) { return NextResponse.json( { success: false, message: 'Customer not found' }, { status: 404 } ); } return NextResponse.json({ success: true, data: customer, message: 'Customer updated successfully', }); } catch (error) { console.error('Error updating customer:', error); return NextResponse.json( { success: false, message: 'Failed to update customer' }, { status: 500 } ); } } export async function DELETE( request: NextRequest, context: RouteParams ) { try { const { id } = await context.params; const success = await deleteCustomer(id); if (!success) { return NextResponse.json( { success: false, message: 'Customer not found' }, { status: 404 } ); } return NextResponse.json({ success: true, message: 'Customer deleted successfully', }); } catch (error) { console.error('Error deleting customer:', error); return NextResponse.json( { success: false, message: 'Failed to delete customer' }, { status: 500 } ); } }
```

# features\warehouses\db\queries\storage\calculate-storage-charges.query.ts

```ts
// features/warehouse/db/queries/storage/calculate-storage-charges.query.ts import { db } from '@/lib/db'; import { storageCharges, storagePricing, packageBinAssignments, binLocations } from '@/features/warehouses/db/schema'; import { eq, and, lte, gte, isNull, sql } from 'drizzle-orm'; import type { CreateStorageChargeData } from '@/features/warehouses/db/schema'; interface StorageCalculationParams { packageId: string; warehouseId: string; tenantId: string; fromDate: string; toDate: string; } export async function calculateStorageCharges(params: StorageCalculationParams) { const { packageId, warehouseId, tenantId, fromDate, toDate } = params; // Get active storage pricing for the warehouse const pricingResult = await db .select() .from(storagePricing) .where( and( eq(storagePricing.tenantId, tenantId), eq(storagePricing.warehouseId, warehouseId), eq(storagePricing.isActive, true), lte(storagePricing.effectiveFrom, fromDate), sql`(${storagePricing.effectiveUntil} IS NULL OR ${storagePricing.effectiveUntil} >= ${toDate})` ) ) .limit(1); if (pricingResult.length === 0) { throw new Error('No active storage pricing found for this warehouse'); } const pricing = pricingResult[0]; // Calculate number of days const startDate = new Date(fromDate); const endDate = new Date(toDate); const timeDiff = endDate.getTime() - startDate.getTime(); const totalDays = Math.ceil(timeDiff / (1000 * 3600 * 24)); if (totalDays <= 0) { throw new Error('Invalid date range for storage calculation'); } // Calculate chargeable days (after free period) const freeDaysApplied = Math.min(totalDays, pricing.freeDays); const chargeableDays = Math.max(0, totalDays - pricing.freeDays); // Get bin location details for premium charges const binAssignmentResult = await db .select({ binLocationId: packageBinAssignments.binId, dailyPremium: binLocations.dailyPremium, currency: binLocations.currency, }) .from(packageBinAssignments) .leftJoin(binLocations, eq(packageBinAssignments.binId, binLocations.id)) .where( and( eq(packageBinAssignments.packageId, packageId), isNull(packageBinAssignments.removedAt), // Currently assigned lte(packageBinAssignments.assignedAt, new Date(toDate)) ) ) .limit(1); // Calculate fees const dailyRate = parseFloat(pricing.dailyRateAfterFree); const baseStorageFee = chargeableDays * dailyRate; let binLocationFee = 0; let binLocationId = null; if (binAssignmentResult.length > 0 && binAssignmentResult[0].dailyPremium) { const premiumRate = parseFloat(binAssignmentResult[0].dailyPremium); binLocationFee = chargeableDays * premiumRate; binLocationId = binAssignmentResult[0].binLocationId; } const totalStorageFee = baseStorageFee + binLocationFee; // Create storage charge record const storageChargeData: CreateStorageChargeData = { packageId, chargeFromDate: fromDate, chargeToDate: toDate, daysCharged: chargeableDays, baseStorageFee: baseStorageFee.toFixed(2), binLocationFee: binLocationFee.toFixed(2), totalStorageFee: totalStorageFee.toFixed(2), currency: pricing.currency, binLocationId: binLocationId ?? undefined, dailyRate: dailyRate.toFixed(2), freeDaysApplied, notes: `Storage charge calculated for ${totalDays} total days, ${freeDaysApplied} free days applied, ${chargeableDays} chargeable days`, }; const [newStorageCharge] = await db .insert(storageCharges) .values({ ...storageChargeData, tenantId, }) .returning(); return { storageCharge: newStorageCharge, calculation: { totalDays, freeDaysApplied, chargeableDays, baseStorageFee, binLocationFee, totalStorageFee, dailyRate, currency: pricing.currency, }, }; }
```

# features\warehouses\db\queries\warehouses\update-warehouse.query.ts

```ts
// features/warehouse/db/queries/warehouses/update-warehouse.query.ts import { db } from '@/lib/db'; import { warehouses } from '@/features/warehouses/db/schema'; import { eq } from 'drizzle-orm'; import type { UpdateWarehouseData, Warehouse } from '@/features/warehouses/db/schema'; export async function updateWarehouse( id: string, data: UpdateWarehouseData ): Promise<Warehouse | null> { // Check if warehouse exists const existingWarehouse = await db .select() .from(warehouses) .where(eq(warehouses.id, id)) .limit(1); if (existingWarehouse.length === 0) { return null; } // Prepare update data const updateData: any = { updatedAt: new Date(), }; // Only update fields that are provided if (data.name !== undefined) updateData.name = data.name; if (data.description !== undefined) updateData.description = data.description; if (data.addressLine1 !== undefined) updateData.addressLine1 = data.addressLine1; if (data.addressLine2 !== undefined) updateData.addressLine2 = data.addressLine2; if (data.city !== undefined) updateData.city = data.city; if (data.stateProvince !== undefined) updateData.stateProvince = data.stateProvince; if (data.postalCode !== undefined) updateData.postalCode = data.postalCode; if (data.phone !== undefined) updateData.phone = data.phone; if (data.email !== undefined) updateData.email = data.email; if (data.timezone !== undefined) updateData.timezone = data.timezone; if (data.status !== undefined) updateData.status = data.status; if (data.acceptsNewPackages !== undefined) updateData.acceptsNewPackages = data.acceptsNewPackages; if (data.taxTreatment !== undefined) updateData.taxTreatment = data.taxTreatment; if (data.storageFreeDays !== undefined) updateData.storageFreeDays = data.storageFreeDays; if (data.storageFeePerDay !== undefined) updateData.storageFeePerDay = data.storageFeePerDay; if (data.maxPackageWeightKg !== undefined) updateData.maxPackageWeightKg = data.maxPackageWeightKg; if (data.maxPackageValue !== undefined) updateData.maxPackageValue = data.maxPackageValue; if (data.operatingHours !== undefined) updateData.operatingHours = data.operatingHours; // Update warehouse const [updatedWarehouse] = await db .update(warehouses) .set(updateData) .where(eq(warehouses.id, id)) .returning(); return updatedWarehouse; }
```

# features\warehouses\db\queries\warehouses\get-warehouses.query.ts

```ts
// features/warehouse/db/queries/warehouses/get-warehouses.query.ts import { db } from '@/lib/db'; import { warehouses } from '@/features/warehouses/db/schema'; import { eq, and, desc, sql, ilike } from 'drizzle-orm'; import type { WarehouseFilters } from '@/features/warehouses/db/schema'; export async function getWarehouses(filters: WarehouseFilters = {}) { const { page = 1, limit = 10, status, countryCode, acceptsNewPackages, search } = filters; // Build where conditions const conditions = []; if (status) { conditions.push(eq(warehouses.status, status)); } if (countryCode) { conditions.push(eq(warehouses.countryCode, countryCode)); } if (acceptsNewPackages !== undefined) { conditions.push(eq(warehouses.acceptsNewPackages, acceptsNewPackages)); } if (search) { conditions.push( sql`(${warehouses.name} ILIKE ${`%${search}%`} OR ${warehouses.code} ILIKE ${`%${search}%`} OR ${warehouses.city} ILIKE ${`%${search}%`})` ); } // Create base query const baseQuery = db .select({ id: warehouses.id, tenantId: warehouses.tenantId, code: warehouses.code, name: warehouses.name, description: warehouses.description, countryCode: warehouses.countryCode, addressLine1: warehouses.addressLine1, addressLine2: warehouses.addressLine2, city: warehouses.city, stateProvince: warehouses.stateProvince, postalCode: warehouses.postalCode, phone: warehouses.phone, email: warehouses.email, timezone: warehouses.timezone, currencyCode: warehouses.currencyCode, taxTreatment: warehouses.taxTreatment, storageFreeDays: warehouses.storageFreeDays, storageFeePerDay: warehouses.storageFeePerDay, maxPackageWeightKg: warehouses.maxPackageWeightKg, maxPackageValue: warehouses.maxPackageValue, status: warehouses.status, acceptsNewPackages: warehouses.acceptsNewPackages, operatingHours: warehouses.operatingHours, createdAt: warehouses.createdAt, updatedAt: warehouses.updatedAt, }) .from(warehouses); // Apply conditions const finalQuery = conditions.length > 0 ? baseQuery.where(and(...conditions)) : baseQuery; // Execute query with ordering const allWarehouses = await finalQuery.orderBy(desc(warehouses.createdAt)); // Calculate pagination const total = allWarehouses.length; const pages = Math.ceil(total / limit); const startIndex = (page - 1) * limit; const endIndex = startIndex + limit; const paginatedWarehouses = allWarehouses.slice(startIndex, endIndex); return { data: paginatedWarehouses, pagination: { page, limit, total, pages, }, }; }
```

# features\warehouses\db\queries\warehouses\get-warehouse-by-id.query.ts

```ts
// features/warehouse/db/queries/warehouses/get-warehouse-by-id.query.ts import { db } from '@/lib/db'; import { warehouses } from '@/features/warehouses/db/schema'; import { eq } from 'drizzle-orm'; import type { Warehouse } from '@/features/warehouses/db/schema'; export async function getWarehouseById(id: string): Promise<Warehouse | null> { const warehouseResult = await db .select() .from(warehouses) .where(eq(warehouses.id, id)) .limit(1); if (warehouseResult.length === 0) { return null; } return warehouseResult[0]; }
```

# features\warehouses\db\queries\warehouses\delete-warehouse.query.ts

```ts
// features/warehouse/db/queries/warehouses/delete-warehouse.query.ts import { db } from '@/lib/db'; import { warehouses, customerWarehouseAssignments } from '@/features/warehouses/db/schema'; import { eq, count } from 'drizzle-orm'; export async function deleteWarehouse(id: string): Promise<boolean> { // Check if warehouse exists const existingWarehouse = await db .select() .from(warehouses) .where(eq(warehouses.id, id)) .limit(1); if (existingWarehouse.length === 0) { return false; } // Check if warehouse has active customer assignments const assignmentCount = await db .select({ count: count() }) .from(customerWarehouseAssignments) .where(eq(customerWarehouseAssignments.warehouseId, id)); if (assignmentCount[0].count > 0) { throw new Error('Cannot delete warehouse with active customer assignments'); } // Note: In a real application, you might also want to check for: // - Active packages in this warehouse // - Active storage charges // - Bin locations with packages // For now, we'll rely on database cascade deletes // Delete warehouse await db.delete(warehouses).where(eq(warehouses.id, id)); return true; }
```

# features\warehouses\db\queries\warehouses\create-warehouse.query.ts

```ts
// features/warehouse/db/queries/warehouses/create-warehouse.query.ts import { db } from '@/lib/db'; import { warehouses } from '@/features/warehouses/db/schema'; import { eq } from 'drizzle-orm'; import type { CreateWarehouseData, Warehouse } from '@/features/warehouses/db/schema'; export async function createWarehouse( tenantId: string, data: CreateWarehouseData ): Promise<Warehouse> { // Check if warehouse code already exists for this tenant const existingWarehouse = await db .select() .from(warehouses) .where(eq(warehouses.code, data.code)) .limit(1); if (existingWarehouse.length > 0) { throw new Error('Warehouse with this code already exists'); } // Create new warehouse const newWarehouseData = { tenantId, code: data.code, name: data.name, description: data.description || null, countryCode: data.countryCode, addressLine1: data.addressLine1, addressLine2: data.addressLine2 || null, city: data.city, stateProvince: data.stateProvince || null, postalCode: data.postalCode, phone: data.phone || null, email: data.email || null, timezone: data.timezone || 'UTC', currencyCode: data.currencyCode, taxTreatment: data.taxTreatment || 'standard', storageFreeDays: data.storageFreeDays || 30, storageFeePerDay: data.storageFeePerDay || '1.00', maxPackageWeightKg: data.maxPackageWeightKg || '30.00', maxPackageValue: data.maxPackageValue || '10000.00', operatingHours: data.operatingHours || {}, }; const [newWarehouse] = await db .insert(warehouses) .values(newWarehouseData) .returning(); return newWarehouse; }
```

# features\warehouses\db\queries\bins\get-available-bin-locations.query.ts

```ts
// features/warehouse/db/queries/bins/get-available-bin-locations.query.ts import { db } from '@/lib/db'; import { binLocations, packageBinAssignments } from '@/features/warehouses/db/schema'; import { eq, and, count, isNull, sql } from 'drizzle-orm'; interface AvailableBinLocationFilters { warehouseId: string; zoneName?: string; minCapacity?: number; maxWeightKg?: number; isClimateControlled?: boolean; isSecured?: boolean; } export async function getAvailableBinLocations(filters: AvailableBinLocationFilters) { const { warehouseId, zoneName, minCapacity, maxWeightKg, isClimateControlled, isSecured } = filters; // Build base query with current occupancy calculation const query = db .select({ id: binLocations.id, tenantId: binLocations.tenantId, warehouseId: binLocations.warehouseId, binCode: binLocations.binCode, zoneName: binLocations.zoneName, description: binLocations.description, maxCapacity: binLocations.maxCapacity, currentOccupancy: sql<number>`COALESCE(${ db .select({ count: count() }) .from(packageBinAssignments) .where( and( eq(packageBinAssignments.binId, binLocations.id), isNull(packageBinAssignments.removedAt) ) ) }, 0)`.as('currentOccupancy'), maxWeightKg: binLocations.maxWeightKg, dailyPremium: binLocations.dailyPremium, currency: binLocations.currency, isClimateControlled: binLocations.isClimateControlled, isSecured: binLocations.isSecured, isAccessible: binLocations.isAccessible, availableCapacity: sql<number>`${binLocations.maxCapacity} - COALESCE(${ db .select({ count: count() }) .from(packageBinAssignments) .where( and( eq(packageBinAssignments.binId, binLocations.id), isNull(packageBinAssignments.removedAt) ) ) }, 0)`.as('availableCapacity'), createdAt: binLocations.createdAt, updatedAt: binLocations.updatedAt, }) .from(binLocations); // Build where conditions const conditions = [ eq(binLocations.warehouseId, warehouseId), eq(binLocations.isActive, true), // Only show bins with available capacity sql`${binLocations.maxCapacity} > COALESCE(${ db .select({ count: count() }) .from(packageBinAssignments) .where( and( eq(packageBinAssignments.binId, binLocations.id), isNull(packageBinAssignments.removedAt) ) ) }, 0)`, ]; if (zoneName) { conditions.push(eq(binLocations.zoneName, zoneName)); } if (minCapacity) { conditions.push(sql`${binLocations.maxCapacity} >= ${minCapacity}`); } if (maxWeightKg) { conditions.push( sql`(${binLocations.maxWeightKg} IS NULL OR ${binLocations.maxWeightKg} >= ${maxWeightKg})` ); } if (isClimateControlled !== undefined) { conditions.push(eq(binLocations.isClimateControlled, isClimateControlled)); } if (isSecured !== undefined) { conditions.push(eq(binLocations.isSecured, isSecured)); } // Execute query const availableBins = await query .where(and(...conditions)) .orderBy(binLocations.zoneName, binLocations.binCode); return availableBins; } // Helper function to find the best available bin for a package export async function findBestAvailableBin( warehouseId: string, packageRequirements: { isFragile?: boolean; isHighValue?: boolean; estimatedWeightKg?: number; preferredZone?: string; } ) { const { isFragile, isHighValue, estimatedWeightKg, preferredZone } = packageRequirements; // Define requirements based on package characteristics const filters: AvailableBinLocationFilters = { warehouseId, maxWeightKg: estimatedWeightKg, }; // High-value packages should go to secured locations if (isHighValue) { filters.isSecured = true; } // Fragile packages might benefit from climate control if (isFragile) { filters.isClimateControlled = true; } // Try preferred zone first if (preferredZone) { filters.zoneName = preferredZone; } let availableBins = await getAvailableBinLocations(filters); // If no bins found with all requirements, try with relaxed constraints if (availableBins.length === 0 && (filters.isClimateControlled || filters.isSecured)) { // Remove climate control requirement first if (filters.isClimateControlled) { delete filters.isClimateControlled; availableBins = await getAvailableBinLocations(filters); } // If still no bins, remove security requirement (but keep for high-value items) if (availableBins.length === 0 && filters.isSecured && !isHighValue) { delete filters.isSecured; availableBins = await getAvailableBinLocations(filters); } } // If preferred zone has no space, try any zone if (availableBins.length === 0 && preferredZone) { delete filters.zoneName; availableBins = await getAvailableBinLocations(filters); } // Sort by preference (secured > climate controlled > most available capacity) const sortedBins = availableBins.sort((a, b) => { // Prioritize secured locations for valuable items if (isHighValue && a.isSecured !== b.isSecured) { return b.isSecured ? 1 : -1; } // Prioritize climate controlled for fragile items if (isFragile && a.isClimateControlled !== b.isClimateControlled) { return b.isClimateControlled ? 1 : -1; } // Prioritize bins with more available capacity return b.availableCapacity - a.availableCapacity; }); return sortedBins[0] || null; }
```

